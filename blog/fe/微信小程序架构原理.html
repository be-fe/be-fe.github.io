<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 微信小程序架构原理 | 百度EUX </title>
    <link rel="stylesheet" href="/style.css">
    <script>
      (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?d232748d06c1fe09a6db3db0077669b7";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();

      var _vds = _vds || [];
      window._vds = _vds;
      (function () {
        _vds.push(['setAccountId', '66707fb8b27442d5b3ccca57a56800fa']);
        _vds.push(['trackBot', false]);

        (function () {
          var vds = document.createElement('script');
          vds.type = 'text/javascript';
          vds.async = true;
          vds.src = '//dn-growing.qbox.me/vds.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(vds, s);
        })();
      })();
    </script>
</head>
<body>
<div id="root">
    <div class="main" data-reactroot="" data-reactid="1" data-react-checksum="-1873040479"><!-- react-empty: 2 --><header class="eux-header clearfix" data-reactid="3"><div class="eux-header-top" data-reactid="4"><a href="javascript:void(0);" class="eux-portable-menu" data-reactid="5"><span data-reactid="6"></span><span data-reactid="7"></span><span data-reactid="8"></span></a><!-- react-empty: 9 --><nav class="menu-primary-container" data-reactid="10"><ul id="menu-primary" class="menu" data-reactid="11"><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-25" data-reactid="12"><a href="/" data-reactid="13">HOME</a></li><li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-ancestor current-menu-parent menu-item-has-children menu-item-45" data-reactid="14"><a href="/" data-reactid="15">BLOG</a><ul class="sub-menu" data-reactid="16"><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="17"><a href="/ue" data-reactid="18">交互</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="19"><a href="/ui" data-reactid="20">视觉</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="21"><a href="/fe" data-reactid="22">前端</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="23"><a href="/team" data-reactid="24">团队</a></li></ul></li><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-46" data-reactid="25"><a href="/tools" data-reactid="26">TOOLS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-112" data-reactid="27"><a href="/works" data-reactid="28">WORKS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-138" data-reactid="29"><a href="/jobs" data-reactid="30">JOBS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-50" data-reactid="31"><a href="/about-us" data-reactid="32">ABOUT US</a></li></ul></nav></div></header><div class="eux-singular clearfix" data-reactid="33"><div class="container-singular clearfix" data-reactid="34"><nav class="menu-categories-container" data-reactid="35"><ul id="menu-categories" class="menu" data-reactid="36"><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="37"><span data-reactid="38"><a href="/" data-reactid="39">全部</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="40"><span data-reactid="41"><a href="/ue" data-reactid="42">交互</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="43"><span data-reactid="44"><a href="/ui" data-reactid="45">视觉</a></span></li><li class="current-menu-item menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="46"><span data-reactid="47"><a href="/fe" data-reactid="48">前端</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="49"><span data-reactid="50"><a href="/team" data-reactid="51">团队</a></span></li></ul></nav><div class="inner clearfix" data-reactid="52"><div class="article-meta" data-reactid="53"><h1 class="title" data-reactid="54">微信小程序架构原理</h1><div class="eux-page-detail" data-reactid="55"><span data-reactid="56"><em data-reactid="57">by.</em><!-- react-text: 58 -->田光宇<!-- /react-text --></span><span data-reactid="59">2018-9-3</span></div></div><article data-reactid="60"><h2 id="微信小程序" data-reactid="61"><a href="#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F" aria-hidden="true" data-reactid="62"><span class="icon icon-link" data-reactid="63"></span></a><!-- react-text: 64 -->微信小程序<!-- /react-text --></h2><p data-reactid="65">微信小程序包含下面四种文件：</p><ul data-reactid="66"><li data-reactid="67">js</li><li data-reactid="68">json 配置文件</li><li data-reactid="69">wxml 小程序专用 xml 文件</li><li data-reactid="70">wxss 小程序专用 css 文件</li></ul><pre data-reactid="71"><code class="hljs language-html" data-query="{}" data-lang="html" data-reactid="72"><span class="hljs-tag" data-reactid="73"><!-- react-text: 74 -->&lt;<!-- /react-text --><span class="hljs-name" data-reactid="75">view</span><!-- react-text: 76 -->&gt;<!-- /react-text --></span><!-- react-text: 77 -->
    <!-- /react-text --><span class="hljs-tag" data-reactid="78"><!-- react-text: 79 -->&lt;<!-- /react-text --><span class="hljs-name" data-reactid="80">text</span><!-- react-text: 81 --> <!-- /react-text --><span class="hljs-attr" data-reactid="82">class</span><!-- react-text: 83 -->=<!-- /react-text --><span class="hljs-string" data-reactid="84">&quot;window&quot;</span><!-- react-text: 85 -->&gt;<!-- /react-text --></span><!-- react-text: 86 -->{{ text }}<!-- /react-text --><span class="hljs-tag" data-reactid="87"><!-- react-text: 88 -->&lt;/<!-- /react-text --><span class="hljs-name" data-reactid="89">text</span><!-- react-text: 90 -->&gt;<!-- /react-text --></span><!-- react-text: 91 -->
<!-- /react-text --><span class="hljs-tag" data-reactid="92"><!-- react-text: 93 -->&lt;/<!-- /react-text --><span class="hljs-name" data-reactid="94">view</span><!-- react-text: 95 -->&gt;<!-- /react-text --></span><!-- react-text: 96 --> <!-- /react-text --></code></pre><pre data-reactid="97"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="98"><!-- react-text: 99 -->Page({
  <!-- /react-text --><span class="hljs-attr" data-reactid="100">data</span><!-- react-text: 101 -->:{
    <!-- /react-text --><span class="hljs-attr" data-reactid="102">text</span><!-- react-text: 103 -->:<!-- /react-text --><span class="hljs-string" data-reactid="104">&quot;这是一个页面&quot;</span><!-- react-text: 105 -->
  },
  <!-- /react-text --><span class="hljs-attr" data-reactid="106">onLoad</span><!-- react-text: 107 -->:<!-- /react-text --><span class="hljs-function" data-reactid="108"><span class="hljs-keyword" data-reactid="109">function</span><!-- react-text: 110 -->(<!-- /react-text --><span class="hljs-params" data-reactid="111">options</span><!-- react-text: 112 -->)<!-- /react-text --></span><!-- react-text: 113 -->{
    <!-- /react-text --><span class="hljs-comment" data-reactid="114">// 页面初始化 options为页面跳转所带来的参数</span><!-- react-text: 115 -->
  },
  <!-- /react-text --><span class="hljs-comment" data-reactid="116">// ........</span><!-- react-text: 117 -->
}) <!-- /react-text --></code></pre><p data-reactid="118">微信小程序只能通过其 mvvm 的模板语法来动态改变页面，本身 js 并不支持 BOM 和 DOM 操作。</p><h2 id="从开发工具看微信小程序架构" data-reactid="119"><a href="#%E4%BB%8E%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9C%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84" aria-hidden="true" data-reactid="120"><span class="icon icon-link" data-reactid="121"></span></a><!-- react-text: 122 -->从开发工具看微信小程序架构<!-- /react-text --></h2><p data-reactid="123"><!-- react-text: 124 -->在 mac 端直接解压应用 发现 app.nw 文件夹，即开发工具源码。可以知道该项目由 nw.js 编写； 在 package.json 文件下找到应用入口：<!-- /react-text --><code data-reactid="125">app/html/index.html</code><!-- react-text: 126 -->。入口 js 为 <!-- /react-text --><code data-reactid="127">dist/app.js</code><!-- react-text: 128 --> 我们可以看到整个编辑器的大致逻辑。<!-- /react-text --><br data-reactid="129"/><!-- react-text: 130 -->但我们关心的是构建过程，在 weapp 文件夹下存在 build.js 文件。没有找到有用的信息，只看到了 <!-- /react-text --><code data-reactid="131">upload</code><!-- react-text: 132 --> 模块，包括对大小限制，上传包命名。<!-- /react-text --><br data-reactid="133"/><!-- react-text: 134 -->为此怀疑，微信小程序本身和 RN 类似。是在服务端打包成 native 语言的。但是通过 android 边框测试发现，微信小程序根本不是 native 原生内容。<!-- /react-text --></p><p data-reactid="135">原生界面效果：</p><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-a.jpg" alt="alt" width="295" height="397" data-reactid="136"/><h3 id="编译过程" data-reactid="137"><a href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B" aria-hidden="true" data-reactid="138"><span class="icon icon-link" data-reactid="139"></span></a><!-- react-text: 140 -->编译过程<!-- /react-text --></h3><p data-reactid="141">继续在 trans 文件夹下发现了编译模板。</p><ul data-reactid="142"><li data-reactid="143">transWxmlToJs wxml 转 js</li><li data-reactid="144">transWxssToCss wxss 转 css</li><li data-reactid="145">transConfigToPf 模板页配置</li><li data-reactid="146">transWxmlToHtml wxml 转 html</li><li data-reactid="147">transManager 管理器</li></ul><p data-reactid="148">用到的内容：</p><ul data-reactid="149"><li data-reactid="150"><!-- react-text: 151 -->发现用到了一个模板：<!-- /react-text --><code data-reactid="152">app.nw/app/dist/weapp/tpl/pageFrameTpl.js</code><!-- react-text: 153 -->, <!-- /react-text --><code data-reactid="154">app.mw/app.dist.weapp/tpl/appserviceTpl.js</code></li><li data-reactid="155">wcc 可执行程序，wcc 用于转转 wxml 中的自定义 tag 为 virtual_dom</li><li data-reactid="156"><!-- react-text: 157 -->wcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 <!-- /react-text --><code data-reactid="158">wcsc xxx.wxss</code></li></ul><p data-reactid="159"><!-- react-text: 160 -->在模板中，我们发现使用了 <!-- /react-text --><code data-reactid="161">WAWebview.js</code><!-- react-text: 162 --> 文件，<!-- /react-text --><code data-reactid="163">WAService.js</code><!-- react-text: 164 -->文件。 在 transWxmlToJs 中我们发现一段 generateFuncReady 事件的函数。对比注册该事件的函数在 <!-- /react-text --><code data-reactid="165">WAWebview.js</code><!-- react-text: 166 --> 中。<!-- /react-text --><br data-reactid="167"/><!-- react-text: 168 -->我们尝试使用 wcc 对input.xml 文件进行编译。<!-- /react-text --></p><blockquote data-reactid="169"><p data-reactid="170">wcc -d input.xml</p></blockquote><p data-reactid="171">生成了一段脚本：</p><pre data-reactid="172"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="173"><span class="hljs-built_in" data-reactid="174">window</span><!-- react-text: 175 -->.__wcc_version__ = <!-- /react-text --><span class="hljs-string" data-reactid="176">&#x27;v0.6vv_20161230_fbi&#x27;</span><!-- react-text: 177 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="178">var</span><!-- react-text: 179 --> $gwxc
<!-- /react-text --><span class="hljs-keyword" data-reactid="180">var</span><!-- react-text: 181 --> $gaic = 
$gwx = <!-- /react-text --><span class="hljs-function" data-reactid="182"><span class="hljs-keyword" data-reactid="183">function</span><!-- react-text: 184 --> (<!-- /react-text --><span class="hljs-params" data-reactid="185">path, global</span><!-- react-text: 186 -->) <!-- /react-text --></span><!-- react-text: 187 -->{
    <!-- /react-text --><span class="hljs-function" data-reactid="188"><span class="hljs-keyword" data-reactid="189">function</span><!-- react-text: 190 --> <!-- /react-text --><span class="hljs-title" data-reactid="191">_</span><!-- react-text: 192 -->(<!-- /react-text --><span class="hljs-params" data-reactid="193">a, b</span><!-- react-text: 194 -->) <!-- /react-text --></span><!-- react-text: 195 -->{
        b &amp;&amp; a.children.push(b);
    }
    ....<!-- /react-text --></code></pre><p data-reactid="196">通过代码我们发现，调用 $gwx 函数会再生成一个有返回值的函数(前提是 path 填写正确)；于是我们执行如下代码：</p><pre data-reactid="197"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="198"><!-- react-text: 199 -->$gwx(<!-- /react-text --><span class="hljs-string" data-reactid="200">&quot;input.xml&quot;</span><!-- react-text: 201 -->)(<!-- /react-text --><span class="hljs-string" data-reactid="202">&quot;test&quot;</span><!-- react-text: 203 -->)<!-- /react-text --></code></pre><p data-reactid="204">得出如下内容：</p><pre data-reactid="205"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="206"><!-- react-text: 207 -->{
    <!-- /react-text --><span class="hljs-string" data-reactid="208">&quot;tag&quot;</span><!-- react-text: 209 -->: <!-- /react-text --><span class="hljs-string" data-reactid="210">&quot;wx-page&quot;</span><!-- react-text: 211 -->,
    <!-- /react-text --><span class="hljs-string" data-reactid="212">&quot;children&quot;</span><!-- react-text: 213 -->: [
        {
            <!-- /react-text --><span class="hljs-string" data-reactid="214">&quot;tag&quot;</span><!-- react-text: 215 -->: <!-- /react-text --><span class="hljs-string" data-reactid="216">&quot;wx-view&quot;</span><!-- react-text: 217 -->,
            <!-- /react-text --><span class="hljs-string" data-reactid="218">&quot;attr&quot;</span><!-- react-text: 219 -->: {
                <!-- /react-text --><span class="hljs-string" data-reactid="220">&quot;class&quot;</span><!-- react-text: 221 -->: <!-- /react-text --><span class="hljs-string" data-reactid="222">&quot;section&quot;</span><!-- react-text: 223 -->
            },
            <!-- /react-text --><span class="hljs-string" data-reactid="224">&quot;children&quot;</span><!-- react-text: 225 -->: [
                {
                    <!-- /react-text --><span class="hljs-string" data-reactid="226">&quot;tag&quot;</span><!-- react-text: 227 -->: <!-- /react-text --><span class="hljs-string" data-reactid="228">&quot;wx-input&quot;</span><!-- react-text: 229 -->,
                    <!-- /react-text --><span class="hljs-string" data-reactid="230">&quot;attr&quot;</span><!-- react-text: 231 -->: {
                        <!-- /react-text --><span class="hljs-string" data-reactid="232">&quot;autoFocus&quot;</span><!-- react-text: 233 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="234">true</span><!-- react-text: 235 -->,
                        <!-- /react-text --><span class="hljs-string" data-reactid="236">&quot;placeholder&quot;</span><!-- react-text: 237 -->: <!-- /react-text --><span class="hljs-string" data-reactid="238">&quot;这是一个可以自动聚焦的input&quot;</span><!-- react-text: 239 -->
                    },
                    <!-- /react-text --><span class="hljs-string" data-reactid="240">&quot;children&quot;</span><!-- react-text: 241 -->: []
                }
            ]
        }
    ]
} <!-- /react-text --></code></pre><p data-reactid="242"><!-- react-text: 243 -->这应该是一个类似 Virtual dom 的对象，交给了 WAWebivew.js 来渲染，标签名为 <!-- /react-text --><code data-reactid="244">wx-view</code><!-- react-text: 245 -->, <!-- /react-text --><code data-reactid="246">wx-input</code><!-- react-text: 247 -->。<!-- /react-text --></p><h4 id="wawebviewjs" data-reactid="248"><a href="#wawebviewjs" aria-hidden="true" data-reactid="249"><span class="icon icon-link" data-reactid="250"></span></a><!-- react-text: 251 -->WAWebview.js<!-- /react-text --></h4><ol data-reactid="252"><li data-reactid="253"><p data-reactid="254"><!-- react-text: 255 -->代码在最一开始提供的是兼容性工具，还有一个 <!-- /react-text --><code data-reactid="256">WeixinJSBridge</code><!-- react-text: 257 --> 引入。<!-- /react-text --></p></li><li data-reactid="258"><p data-reactid="259"><!-- react-text: 260 -->接下来是一个 <!-- /react-text --><code data-reactid="261">Reporter</code><!-- react-text: 262 --> 对象，它的作用就是发送错误和性能统计数据给后台。<!-- /react-text --></p></li></ol><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-b.jpg" alt="alt" width="380" height="126" data-reactid="263"/><ol start="3" data-reactid="264"><li data-reactid="265"><code data-reactid="266">wx</code><!-- react-text: 267 --> 核心对象，包含了 <!-- /react-text --><code data-reactid="268">wx</code><!-- react-text: 269 --> 对象下的 <!-- /react-text --><code data-reactid="270">api</code><!-- react-text: 271 -->。但是这里的 <!-- /react-text --><code data-reactid="272">api</code><!-- react-text: 273 --> 数量远远少于官方的 <!-- /react-text --><code data-reactid="274">api</code><!-- react-text: 275 --> 文档数量。<!-- /react-text --></li></ol><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-c.jpg" alt="alt" width="333" height="170" data-reactid="276"/><p data-reactid="277"><!-- react-text: 278 -->我们可以在代码里面发现，<!-- /react-text --><code data-reactid="279">wx</code><!-- react-text: 280 --> 下注册的 <!-- /react-text --><code data-reactid="281">api</code><!-- react-text: 282 --> 最终都会调用 <!-- /react-text --><code data-reactid="283">WeixinJSBridge</code><!-- react-text: 284 --> 方法。这个方法应该是在打包的时候端上注入的。我们也可以在 <!-- /react-text --><code data-reactid="285">WAServeice.js</code><!-- react-text: 286 --> 中找到该方法的定义。<!-- /react-text --></p><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-d.jpg" alt="alt" width="773" height="179" data-reactid="287"/><p data-reactid="288"><!-- react-text: 289 -->所以我们得到了一个结论，<!-- /react-text --><code data-reactid="290">WAService.js</code><!-- react-text: 291 --> 是编辑器用来接受 <!-- /react-text --><code data-reactid="292">wx</code><!-- react-text: 293 --> 方法回调的代码。<!-- /react-text --></p><ol start="4" data-reactid="294"><li data-reactid="295"><p data-reactid="296"><code data-reactid="297">wxparser</code><!-- react-text: 298 --> 对象，提供 <!-- /react-text --><code data-reactid="299">dom</code><!-- react-text: 300 --> 到 <!-- /react-text --><code data-reactid="301">wx element</code><!-- react-text: 302 --> 对象之间的映射操作，提供元素操作管理和事件管理功能。<!-- /react-text --></p></li><li data-reactid="303"><p data-reactid="304"><!-- react-text: 305 -->之后代码是对 <!-- /react-text --><code data-reactid="306">exparser</code><!-- react-text: 307 --> 对象的处理，包括注册 <!-- /react-text --><code data-reactid="308">WeixinJSBridge</code><!-- react-text: 309 --> 全局事件，Virtual dom 算法实现，样式注入等。介绍几个组件重要的内容<!-- /react-text --></p></li></ol><ul data-reactid="310"><li data-reactid="311"><p data-reactid="312"><code data-reactid="313">exparser.registerBehavior</code><!-- react-text: 314 --> 注册组件基础行为，供组件继承。 <!-- /react-text --><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-e.jpg" alt="alt" width="280" height="221" data-reactid="315"/></p></li><li data-reactid="316"><p data-reactid="317"><code data-reactid="318">exparser.registerElement</code><!-- react-text: 319 --> 为各种内置组件，注册模板，行为，属性，监听器等内容 <!-- /react-text --><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-f.jpg" alt="alt" width="350" height="186" data-reactid="320"/></p></li></ul><p data-reactid="321"><!-- react-text: 322 -->这里我们观察到，组件：<!-- /react-text --><code data-reactid="323">wx-video</code><!-- react-text: 324 -->, <!-- /react-text --><code data-reactid="325">wx-canvas</code><!-- react-text: 326 -->, <!-- /react-text --><code data-reactid="327">wx-contact-button</code><!-- react-text: 328 -->, <!-- /react-text --><code data-reactid="329">wx-map</code><!-- react-text: 330 -->, <!-- /react-text --><code data-reactid="331">wx-textarea</code><!-- react-text: 332 --> 等 behaviors 都含有 &quot;wx-native&quot; 属性。这是不是意味着，这类组件都是 native 原生实现的呢。我们打开边框检查，发现这类组件确实都是原生的组件。<!-- /react-text --></p><p data-reactid="333"><a href="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-g.jpg" data-reactid="334"></a></p><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-h.jpg" alt="alt" width="338" height="426" data-reactid="335"/><p data-reactid="336">综上，微信小程序的界面有部分组件使用原生方式实现的，native 组件层在 WebView 层之上。大部分还是用前端实现的，这样解释了微信小程序的一个bug。</p><blockquote data-reactid="337"><p data-reactid="338"><!-- react-text: 339 -->微信官方文档：<!-- /react-text --><br data-reactid="340"/><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-i.jpg" alt="alt" width="568" height="53" data-reactid="341"/></p></blockquote><p data-reactid="342">因为 scroll-view 是前端实现，在里面使用 native 组件，这样就无法监听滚动了。</p><h4 id="weixinjsbridge" data-reactid="343"><a href="#weixinjsbridge" aria-hidden="true" data-reactid="344"><span class="icon icon-link" data-reactid="345"></span></a><!-- react-text: 346 -->WeixinJSBridge<!-- /react-text --></h4><p data-reactid="347"><!-- react-text: 348 -->组件是需要数据来渲染的，查看文档我们知道发送请求的 api 为 <!-- /react-text --><code data-reactid="349">wx.request</code><!-- react-text: 350 -->;通过上面分析，我们知道 wx.request 实际调用的是 <!-- /react-text --><code data-reactid="351">WeixinJSBridge</code><!-- react-text: 352 -->。现在我们看看 <!-- /react-text --><code data-reactid="353">WeixinJSBridge</code></p><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-j.jpg" alt="alt" width="616" height="332" data-reactid="354"/><p data-reactid="355"><code data-reactid="356">WeixinJSBridge</code><!-- react-text: 357 --> 真正发送处理数据请求的是这段代码；如果当前环境是 <!-- /react-text --><code data-reactid="358">ios</code><!-- react-text: 359 -->, 那么调用 <!-- /react-text --><code data-reactid="360">WKWebview</code><!-- react-text: 361 --> 的 <!-- /react-text --><code data-reactid="362">window.webkit.messageHandlers.invokeHandler.postMessage</code><!-- react-text: 363 -->。如果所处环境是 <!-- /react-text --><code data-reactid="364">android</code><!-- react-text: 365 --> 则调用 <!-- /react-text --><code data-reactid="366">WeixinJSCore.invokeHandler</code><!-- react-text: 367 --> (调用的时候，默认会带上当前 <!-- /react-text --><code data-reactid="368">webviewID</code><!-- react-text: 369 -->)。<!-- /react-text --></p><h4 id="waservicejs" data-reactid="370"><a href="#waservicejs" aria-hidden="true" data-reactid="371"><span class="icon icon-link" data-reactid="372"></span></a><!-- react-text: 373 -->WAService.js<!-- /react-text --></h4><p data-reactid="374"><!-- react-text: 375 -->在对 <!-- /react-text --><code data-reactid="376">WeixinJSBridge.js</code><!-- react-text: 377 --> 分析中，我们并没有发现前端的通讯功能，路由能力，数据绑定等内容。进一步查看找到了一个 <!-- /react-text --><code data-reactid="378">WAService.js</code><!-- react-text: 379 --> 文件。 查看 <!-- /react-text --><code data-reactid="380">WAService.js</code><!-- react-text: 381 --> 文件源码：<!-- /react-text --></p><ol data-reactid="382"><li data-reactid="383"><!-- react-text: 384 -->在代码最开始，跟 <!-- /react-text --><code data-reactid="385">WAWebview.js</code><!-- react-text: 386 --> 一样的 <!-- /react-text --><code data-reactid="387">WeixinJSBridge</code><!-- react-text: 388 --> 兼容模块<!-- /react-text --></li><li data-reactid="389"><!-- react-text: 390 -->然后是跟 <!-- /react-text --><code data-reactid="391">WAWebview.js</code><!-- react-text: 392 --> 一样的 <!-- /react-text --><code data-reactid="393">Reporter</code><!-- react-text: 394 --> 模块。<!-- /react-text --></li><li data-reactid="395"><!-- react-text: 396 -->比 <!-- /react-text --><code data-reactid="397">WAWebview.js</code><!-- react-text: 398 --> 中 <!-- /react-text --><code data-reactid="399">wx</code><!-- react-text: 400 --> 功能更为丰富 <!-- /react-text --><code data-reactid="401">wx</code><!-- react-text: 402 --> 接口模块。(剩余部分 <!-- /react-text --><code data-reactid="403">wx api</code><!-- react-text: 404 --> 都在这里)<!-- /react-text --></li><li data-reactid="405"><code data-reactid="406">appServiceEngine</code><!-- react-text: 407 --> 模块，提供 <!-- /react-text --><code data-reactid="408">Page</code><!-- react-text: 409 -->，<!-- /react-text --><code data-reactid="410">App</code><!-- react-text: 411 -->，<!-- /react-text --><code data-reactid="412">GetApp</code><!-- react-text: 413 --> 接口<!-- /react-text --></li><li data-reactid="414"><!-- react-text: 415 -->为 <!-- /react-text --><code data-reactid="416">window</code><!-- react-text: 417 --> 对象添加 <!-- /react-text --><code data-reactid="418">AMD</code><!-- react-text: 419 --> 接口 <!-- /react-text --><code data-reactid="420">require define</code></li></ol><p data-reactid="421"><!-- react-text: 422 -->综上，<!-- /react-text --><code data-reactid="423">WAService.js</code><!-- react-text: 424 --> 主要实现的功能：<!-- /react-text --></p><ul data-reactid="425"><li data-reactid="426">App( ) 小程序的入口；Page( ) 页面的入口</li><li data-reactid="427">wx API;</li><li data-reactid="428">页面有的作用域，提供模块化能力</li><li data-reactid="429">数据绑定、事件分发、生命周期管理、路由管理</li></ul><p data-reactid="430"><!-- react-text: 431 -->到这里我们得出结论，小程序的架构方案： <!-- /react-text --><img src="https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-k.jpg" alt="alt" width="800" height="440" data-reactid="432"/></p><p data-reactid="433"><!-- react-text: 434 -->整个小程序由两个 <!-- /react-text --><code data-reactid="435">webview</code><!-- react-text: 436 --> 组成，代码分为 <!-- /react-text --><code data-reactid="437">UI</code><!-- react-text: 438 --> 层和逻辑层。<!-- /react-text --><code data-reactid="439">UI</code><!-- react-text: 440 --> 层运行在第一个 <!-- /react-text --><code data-reactid="441">WebView</code><!-- react-text: 442 --> 当中，执行 <!-- /react-text --><code data-reactid="443">DOM</code><!-- react-text: 444 --> 操作和交互事件的响应，里面是 <!-- /react-text --><code data-reactid="445">WAWebview.js</code><!-- react-text: 446 --> 代码及编译后的内容。逻辑层执行在（第二个<!-- /react-text --><code data-reactid="447">webview</code><!-- react-text: 448 --> 中）独立的 <!-- /react-text --><code data-reactid="449">JS</code><!-- react-text: 450 --> 引擎中（iOS：<!-- /react-text --><code data-reactid="451">JavaScriptCore</code><!-- react-text: 452 -->, android：<!-- /react-text --><code data-reactid="453">X5</code><!-- react-text: 454 --> JS解析器；统称 <!-- /react-text --><code data-reactid="455">JSCore</code><!-- react-text: 456 -->；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。<!-- /react-text --></p><p data-reactid="457"><!-- react-text: 458 -->当我们对 <!-- /react-text --><code data-reactid="459">view</code><!-- react-text: 460 --> 层进行事件操作后，会通过 <!-- /react-text --><code data-reactid="461">WeixinJSBridge</code><!-- react-text: 462 --> 将数据传递到 <!-- /react-text --><code data-reactid="463">Native</code><!-- react-text: 464 --> 系统层。<!-- /react-text --><code data-reactid="465">Native</code><!-- react-text: 466 --> 系统层决定是否要用 <!-- /react-text --><code data-reactid="467">native</code><!-- react-text: 468 --> 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 <!-- /react-text --><code data-reactid="469">WeixinJSBridge</code><!-- react-text: 470 --> 返给 <!-- /react-text --><code data-reactid="471">View</code><!-- react-text: 472 --> 层。<!-- /react-text --><code data-reactid="473">View</code><!-- react-text: 474 --> 渲染更新视图。<!-- /react-text --></p><h2 id="架构的讨论" data-reactid="475"><a href="#%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%A8%E8%AE%BA" aria-hidden="true" data-reactid="476"><span class="icon icon-link" data-reactid="477"></span></a><!-- react-text: 478 -->架构的讨论<!-- /react-text --></h2><p data-reactid="479"><!-- react-text: 480 -->微信的这种架构，对逻辑和UI进行了完全隔离，小程序逻辑和UI完全运行在2个独立的Webview里面来处理。那么这么做的好处是啥？总感觉更加麻烦了。除了小程序外，还有人采用这种架构设计么？<!-- /react-text --><br data-reactid="481"/><!-- react-text: 482 -->在网上搜索了一下，目前使用这种架构的项目还真有一个：<!-- /react-text --><a href="http://ued.qunar.com/yis/index.html" data-reactid="483">去哪儿最新的 YIS 框架</a></p><blockquote data-reactid="484"><p data-reactid="485">YIS 采取了类似小程序的架构，分为逻辑层和UI层。UI 层运行在 WebView 中，而逻辑层运行在独立的 JS 引擎中。相应地，整个应用的代码，也分为两个大的部分，一部分运行在 WebView 中，一部分运行在JS引擎中。JS引擎计算DOM结构输出给WebView，WebView转发用户的点击事件给JS引擎。</p></blockquote><p data-reactid="486">该项目做法和小程序十分类似，唯一缺少的就是没有 native 的组件吧。然而官方文档上也没有任何介绍，为什么要这么做，只是说更流畅了。</p><h3 id="一些看法" data-reactid="487"><a href="#%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95" aria-hidden="true" data-reactid="488"><span class="icon icon-link" data-reactid="489"></span></a><!-- react-text: 490 -->一些看法<!-- /react-text --></h3><p data-reactid="491">传统 web 页面显示需要经历一下几个步骤:</p><ol data-reactid="492"><li data-reactid="493"><code data-reactid="494">webview</code><!-- react-text: 495 --> 初始化<!-- /react-text --></li><li data-reactid="496"><!-- react-text: 497 -->加载 <!-- /react-text --><code data-reactid="498">HTML</code><!-- react-text: 499 -->, <!-- /react-text --><code data-reactid="500">CSS</code><!-- react-text: 501 -->, <!-- /react-text --><code data-reactid="502">JS</code></li><li data-reactid="503"><!-- react-text: 504 -->编译 <!-- /react-text --><code data-reactid="505">JS</code></li><li data-reactid="506"><code data-reactid="507">Render</code><!-- react-text: 508 --> 计算<!-- /react-text --></li><li data-reactid="509"><code data-reactid="510">DOM Path</code></li></ol><p data-reactid="511"><!-- react-text: 512 -->而利用小程序架构后，我们就可以将上述过程拆解成两部分并行执行： <!-- /react-text --><code data-reactid="513">webview</code><!-- react-text: 514 --> 部分：<!-- /react-text --></p><ol data-reactid="515"><li data-reactid="516"><code data-reactid="517">webview</code><!-- react-text: 518 --> 初始化<!-- /react-text --></li><li data-reactid="519"><!-- react-text: 520 -->加载 <!-- /react-text --><code data-reactid="521">HTML</code><!-- react-text: 522 -->，<!-- /react-text --><code data-reactid="523">CSS</code><!-- react-text: 524 -->, <!-- /react-text --><code data-reactid="525">JS</code><!-- react-text: 526 --> (经过拆分后，体积大幅度减小)<!-- /react-text --></li><li data-reactid="527"><!-- react-text: 528 -->编译 <!-- /react-text --><code data-reactid="529">JS</code></li><li data-reactid="530">等待页面需要的数据</li><li data-reactid="531">反序列化数据</li><li data-reactid="532"><!-- react-text: 533 -->执行 <!-- /react-text --><code data-reactid="534">Patch</code></li><li data-reactid="535">渲染页面</li><li data-reactid="536">等待更多消息</li></ol><p data-reactid="537"><code data-reactid="538">jscore</code><!-- react-text: 539 --> 部分：<!-- /react-text --></p><ol data-reactid="540"><li data-reactid="541">初始化</li><li data-reactid="542"><!-- react-text: 543 -->加载框架 <!-- /react-text --><code data-reactid="544">js</code><!-- react-text: 545 --> 代码<!-- /react-text --></li><li data-reactid="546"><!-- react-text: 547 -->编译 <!-- /react-text --><code data-reactid="548">js</code></li><li data-reactid="549"><!-- react-text: 550 -->加载业务逻辑 <!-- /react-text --><code data-reactid="551">js</code><!-- react-text: 552 --> 代码<!-- /react-text --></li><li data-reactid="553"><!-- react-text: 554 -->编译 <!-- /react-text --><code data-reactid="555">js</code></li><li data-reactid="556"><!-- react-text: 557 -->计算首屏虚拟 <!-- /react-text --><code data-reactid="558">DOM</code><!-- react-text: 559 --> 结构<!-- /react-text --></li><li data-reactid="560">序列化数据，传输</li><li data-reactid="561"><!-- react-text: 562 -->等待 <!-- /react-text --><code data-reactid="563">webview</code><!-- react-text: 564 --> 消息，或者 <!-- /react-text --><code data-reactid="565">Native</code><!-- react-text: 566 --> 消息<!-- /react-text --></li></ol><p data-reactid="567"><!-- react-text: 568 -->这样渲染进程和逻辑进程分离，并行处理：加速首屏渲染速度；避免单线程模型下，<!-- /react-text --><code data-reactid="569">js</code><!-- react-text: 570 --> 运算时间过长，UI 出现卡顿。 完全采用数据驱动的方式，不能直接操作 DOM，利用定制开发规范的方式避免低质量的代码的出现。<!-- /react-text --></p><p data-reactid="571">当然这种架构方案也有一定的缺点：</p><ol data-reactid="572"><li data-reactid="573"><!-- react-text: 574 -->不能灵活操作 <!-- /react-text --><code data-reactid="575">DOM</code><!-- react-text: 576 -->，无法实现较为复杂的效果<!-- /react-text --></li><li data-reactid="577"><!-- react-text: 578 -->部分和 <!-- /react-text --><code data-reactid="579">NA</code><!-- react-text: 580 --> 相关的视图有使用限制，如微信的 <!-- /react-text --><code data-reactid="581">scrollView</code><!-- react-text: 582 --> 内不能有 <!-- /react-text --><code data-reactid="583">textarea</code><!-- react-text: 584 -->。<!-- /react-text --></li><li data-reactid="585">页面大小、打开页面数量都受到限制</li><li data-reactid="586">需要单独开发适配，不能复用现有代码资源。</li><li data-reactid="587">在 jscore 中JS 体积比较大的情况下，其初始化时间会产生影响。</li><li data-reactid="588">传输数据中，序列化和反序列化耗时需要考虑</li></ol><h1 id="参考资料" data-reactid="589"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" aria-hidden="true" data-reactid="590"><span class="icon icon-link" data-reactid="591"></span></a><!-- react-text: 592 -->参考资料<!-- /react-text --></h1><ul data-reactid="593"><li data-reactid="594"><a href="https://www.zhihu.com/question/50920642" data-reactid="595">微信小程序底层的实现原理是怎样的</a></li><li data-reactid="596"><a href="http://www.bbs0101.com/archives/1495.html" data-reactid="597">微信小程序架构解析，工作原理解析</a></li><li data-reactid="598"><a href="https://zhuanlan.zhihu.com/p/22754296" data-reactid="599">微信小程序架构分析</a></li></ul></article><div data-reactid="600"></div><nav class="single-bar clearfix" data-reactid="601"><span class="next" data-reactid="602"><a rel="next" href="/blog/fe/npm aduit二三事" data-reactid="603"><em class="eux-icon eux-icon-page-next" data-reactid="604"></em><!-- react-text: 605 -->npm audit 二三事<!-- /react-text --></a></span></nav></div></div></div><footer class="footer" data-reactid="606"><div class="eux-footer-area-wrapper container-singular" role="complementary" data-reactid="607"><div class="inner clearfix" data-reactid="608"><aside id="simple-links-2" class="widget sl-links-main" data-reactid="609"><h2 class="widgettitle" data-reactid="610">友情链接</h2><ul class="simple-links-list simple-links-2-list" id="simple-links-2-list" data-reactid="611"><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="612"><a target="_blank" href="http://sux.baidu.com/" title="百度 FEX 团队" data-reactid="613">百度 FEX</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="614"><a target="_blank" href="http://efe.baidu.com/" title="百度 EFE 团队" data-reactid="615">百度 EFE</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="616"><a target="_blank" href="http://sux.baidu.com/" title="百度 SUX 团队" data-reactid="617">百度 SUX</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="618"><a target="_blank" href="https://aotu.io/" title="京东凹凸实验室，面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。" data-reactid="619">凹凸实验室</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="620"><a target="_blank" href="https://fed.renren.com/" title="人人网FED" data-reactid="621">人人网FED</a></li></ul></aside></div></div><div class="eux-icp" data-reactid="622"><!-- react-text: 623 -->百度EUX 版权所有 ©百度EUX    All rights reserved. 骄傲地采用 <!-- /react-text --><a target="_blank" href="https://github.com/picidaejs/picidaejs" data-reactid="624">Picidae</a><!-- react-text: 625 -->。<!-- /react-text --></div></footer></div>
</div>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>