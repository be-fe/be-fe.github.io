{"version":3,"sources":["webpack:///blog/fe/832.js","webpack:///./doc/fe/832.md"],"names":["webpackJsonp","799","module","exports","content","extra","_image-loader_"],"mappings":"AAAAA,cAAc,GAAG,KAEXC,IACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA;AACAC,OACAC","file":"blog/fe/832.js","sourcesContent":["webpackJsonp([55,56],{\n\n/***/ 799:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<h2 id=背景介绍><a href=#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>背景介绍</h2><p>OpenGL -> OpenGL ES -> OpenGL ES 2.0 -> WebGL</p><img src=http://eux-blog-static.bj.bcebos.com/relations.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A10%3A58Z%2F-1%2Fhost%2F4a71a255776a0d2ccad6e3770850dd41f3084c637ee63baa27380577e955bea4 alt=image width=748 height=273><p>OpenGL Embeded Subset是OpenGL的一个子集, 针对嵌入式和移动端做了功能精简和性能优化</p><p>WebGL基于OpenGL ES 2.0标准, 基本就是将原来C语言的API和配置项迁移到Javascript, 去掉了一些实在不兼容的部分</p><p>WebGL 2.0基于OpenGL ES 3.0</p><h2 id=渲染管道pipeline><a href=#%E6%B8%B2%E6%9F%93%E7%AE%A1%E9%81%93pipeline aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>渲染管道(PipeLine)</h2><img src=http://eux-blog-static.bj.bcebos.com/pipeLine.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A11%3A28Z%2F-1%2Fhost%2F05b7a0082971623bc87bfde081711104b5c83f3d206e1cce2bae0f5f4927de3d alt=image width=748 height=537><h3 id=vertex-array-顶点数组><a href=#vertex-array-%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Vertex Array: 顶点数组</h3><p>初始化数据(利用3D建模工具等生成的模型顶点)</p><h3 id=vertex-shader-顶点着色器><a href=#vertex-shader-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Vertex Shader: 顶点着色器</h3><p>计算坐标, 颜色等顶点相关数据, 相关概念:</p><ul><li>Attributes: 从顶点数组获取的每个顶点的初始数据</li><li>Uniforms: 计算需要的常量数据</li><li>Samplers: 代表材质(Texture)的一类特殊常量, 在顶点着色器中是可选的</li><li>Shader Program: 着色器程序, 使用着色器语言(Shading Language, 类似C语言)编写的可执行程序代码, 指定需要在顶点上作什么样的计算和处理</li><li>Varying Variables: 顶点着色器的输出, 计算出的每个顶点相关数据</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>attribute vec4 a_Position;\\nattribute vec4 a_Color;\\nuniform mat4 u_MvpMatrix;\\nvarying vec4 v_Color;\\n<span class=hljs-keyword>void</span> main() {\\n    gl_Position = u_MvpMatrix * a_Position;\\n    v_Color = a_Color;\\n}</code></pre><h3 id=primitive-assemply-图元组装><a href=#primitive-assemply-%E5%9B%BE%E5%85%83%E7%BB%84%E8%A3%85 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Primitive Assemply: 图元组装</h3><p>根据计算出的顶点信息和绘图命令绘制基本图形, 包括: 三角形(Triangle), 直线(Line), 点(Point-Sprite); 一般3d图形都是由三角形组成的</p><h3 id=rasterization-栅格化><a href=#rasterization-%E6%A0%85%E6%A0%BC%E5%8C%96 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Rasterization: 栅格化</h3><p>利用插值(interpolation)的方法计算顶点之间的边及边之间的内部点的数据, 计算出的数据就是所有需要绘制的像素点, 作为输入传给Fragment Shader</p><img src=http://eux-blog-static.bj.bcebos.com/rasterization.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A11%3A57Z%2F-1%2Fhost%2Fce034b581502a98d42b48880299e4ac87674a2c8d81706d1e898cb67f79225bc alt=image width=748 height=155><p>一般栅格化之前还要经过裁剪(clipping, 把不在可见区域范围内的点去掉); 剔除(culling, 把背对可见方向, 完全不会被看见的面去掉), 来减少计算量</p><h3 id=fragment-shader-片段着色器-像素着色器><a href=#fragment-shader-%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8-%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Fragment Shader: 片段着色器, 像素着色器</h3><p>在这个阶段可以应用材质(Texture), 进行逐像素的颜色处理, 相关概念:</p><ul><li>Varying Variables: 栅格化的结果, 计算出的每个像素点相关数据</li><li>Uniforms: 计算需要的常量数据</li><li>Samplers: 代表材质(Texture)的一类特殊常量</li><li>Shader Program: 着色器程序, 使用着色器语言(Shading Language, 类似C语言)编写的可执行程序代码, 指定需要在像素点上作什么样的计算和处理</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>varying vec4 v_Color;\\n<span class=hljs-keyword>void</span> main() {\\n    gl_FragColor = v_Color;\\n}</code></pre><h3 id=per-fragment-operations-逐像素处理><a href=#per-fragment-operations-%E9%80%90%E5%83%8F%E7%B4%A0%E5%A4%84%E7%90%86 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Per-Fragment Operations: 逐像素处理</h3><p>对像素执行一些可选的后处理</p><img src=http://eux-blog-static.bj.bcebos.com/per-fragment-operation.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A12%3A39Z%2F-1%2Fhost%2Fead684c7662d16a8407267409586cd8d156115a856838c73a77ca48c729fc286 alt=image width=748 height=230><ul><li>scissor test: 限制只在一个矩形区域更新像素</li><li>stencil test: 像素级的蒙板(stecil buffer), 可以定义哪些蒙板区域更新, 哪些不更新</li><li>depth test: 默认需要开启, 测试像素的深度, 决定哪些像素</li></ul><h3 id=framebuffer-帧缓存><a href=#framebuffer-%E5%B8%A7%E7%BC%93%E5%AD%98 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Framebuffer: 帧缓存</h3><p>一个GL Context可以有多个帧缓存, 存储可渲染区域的像素相关数据</p><h2 id=坐标变换-图形变换><a href=#%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2-%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>坐标变换 &amp图形变换</h2><p>通常在顶点着色器中应用坐标变换, 计算每个顶点的最终坐标位置</p><img src=http://eux-blog-static.bj.bcebos.com/coordinate-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A18Z%2F-1%2Fhost%2F37db9570c8314c6b16fc0bd81b51cdb343731cf358d4b5e48744c55e6ddf3c5a alt=image width=748 height=214><h3 id=本地坐标系local-coordinate-system><a href=#%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%B3%BBlocal-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>本地坐标系(local coordinate system)</h3><p>指通过算法或建模软件生成模型时的坐标系, 通常以模型自己的中心点为坐标原点</p><img src=http://eux-blog-static.bj.bcebos.com/local-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A39Z%2F-1%2Fhost%2F0ac6e90894094f42c2abbeb49f2aefbfe0d614c4930c3d30a88dc3a338976a20 alt=image width=400 height=379><h3 id=世界坐标系world-coordinate-system><a href=#%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E7%B3%BBworld-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>世界坐标系(world coordinate system)</h3><p>通过平移, 旋转, 放缩等图形变换方法, 把模型放置到一个更大的坐标系中</p><img src=http://eux-blog-static.bj.bcebos.com/world-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A59Z%2F-1%2Fhost%2F1e7c30d42c77b4f3fc96dc90fa37bfabc05f3e9aa287d381d4e4899f5bfafa41 alt=image width=748 height=344><h4 id=图形变换><a href=#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>图形变换</h4><p>任何图形变换都可以用矩阵的方式表达; 不同变换的叠加可以用矩阵相乘的形式来计算. 可以参考 <a href=http://glmatrix.net/docs/module-quat.html>glMatrix</a> 库的 rotate, translate, scale等方法</p><h3 id=观察坐标系view-coordinate-system><a href=#%E8%A7%82%E5%AF%9F%E5%9D%90%E6%A0%87%E7%B3%BBview-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>观察坐标系(view coordinate system)</h3><p>通过指定观察点坐标(eye point), 目标点(lookAt point), 竖直方向(up vector)来确定一个观察坐标系</p><img src=http://eux-blog-static.bj.bcebos.com/view-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A01Z%2F-1%2Fhost%2F98df745d508e5fc824b8748a15628ae0d00b98b1b6f00d0f8969cde13698da40 alt=image width=748 height=239><p>观察矩阵的生成可以参考<a href=http://glmatrix.net/docs/module-quat.html>glMatrix</a> 库的lookAt方法</p><img src=http://eux-blog-static.bj.bcebos.com/lookAt-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A29Z%2F-1%2Fhost%2Ff087aec8d1cc64e42116443a78373d568ef015d2966be2c0caedd9bc8a6b794a alt=image width=748 height=144><p>观察矩阵和图形变换矩阵有时是可以互换的, 把物体位置向观察点靠近和把观察点向物体靠近, 两种变化效果是一样的</p><p>只是一个应用了图形变换, 一个应用了观察坐标系变换. 通常这两种变换是结合使用, 各有各的目的</p><h3 id=剪裁坐标系clipping-coordinate-system><a href=#%E5%89%AA%E8%A3%81%E5%9D%90%E6%A0%87%E7%B3%BBclipping-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>剪裁坐标系(clipping coordinate system)</h3><p>在这一步会利用投影的方法, 把一个3D的物体投影的2D的屏幕中去</p><p>这一步可以确认物体是否在可见范围内, 哪一部分在可见范围内, 所以叫剪裁坐标系</p><h4 id=正交投影orthographic-projection><a href=#%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1orthographic-projection aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>正交投影(orthographic projection)</h4><p>用一个盒子状的可见范围平行投影物体, 没有近大远小的概念, left, right, bottom, top, near, far分别表示盒子的六个面的坐标</p><img src=http://eux-blog-static.bj.bcebos.com/orthographic-projection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A57Z%2F-1%2Fhost%2F90ad01daebdb5c7b7565cee6906d1ec2d30faf3dd9e494d2ea2c4684536b7277 alt=image width=748 height=437><p>glMatrix中的对应方法</p><img src=http://eux-blog-static.bj.bcebos.com/ortho-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A18%3A23Z%2F-1%2Fhost%2Fd50d52f7366f517051a94bbe4f57faacb1153857f4c8af042fe28c0661371ff4 alt=image width=748 height=104><p>矩阵公式</p><img src=http://eux-blog-static.bj.bcebos.com/ortho-matrix.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A18%3A48Z%2F-1%2Fhost%2F8794b1092eb2d52dd4bdca29f2469ca05560ab4221ad3e9bfc2d9cdc1e1855b9 alt=image width=500 height=227><h4 id=透视投影perspective-projection><a href=#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1perspective-projection aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>透视投影(perspective projection)</h4><p>类似素描里近大远小的透视方法, 用一个四面梯形定义可见范围, fov表示视角(上下平面之间角度), aspect表示剪裁矩形的宽高比, near和far表示剪裁近平面和远平面</p><img src=http://eux-blog-static.bj.bcebos.com/perspective-projection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A11Z%2F-1%2Fhost%2F8bdae66dd39c5c9450ec65b5a58174218535381a1a5cc52dfad550c4c9a03f66 alt=image width=748 height=347><p>glMatrix的方法</p><img src=http://eux-blog-static.bj.bcebos.com/perspective-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A33Z%2F-1%2Fhost%2F199a2df06bf15c70d14438e2945200ef6db70f61973b93c40e816997c68ccb19 alt=image width=748 height=109><p>矩阵公式</p><img src=http://eux-blog-static.bj.bcebos.com/perspective-matrix.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A49Z%2F-1%2Fhost%2F1f36856449c354990b71b02b62dcb2fb27cd35f4619a588e6bc44a3540e247b8 alt=image width=500 height=256><p>最终的剪裁坐标系x, y, z轴都会标准化为[-1, 1]的范围, z轴表示物体的前后覆盖关系; 在剪裁阶段所有坐标不在[-1, 1]范围内的点都会认为不可见(z轴是0到-1, 因为观察点在0点且向负方向看)</p><img src=http://eux-blog-static.bj.bcebos.com/cliping-system-1.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A09Z%2F-1%2Fhost%2Fe40dc957de2cfbf9e1399eaafbfe6dba0953f1995aa0c8fbfbe55ba056663cb9 alt=image width=748 height=272> <img src=http://eux-blog-static.bj.bcebos.com/cliping-system-2.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A21Z%2F-1%2Fhost%2F13361f77c179c166e2fcc46fbc0f785bf1b31585b2e978ecd69593a925020a18 alt=image width=500 height=403><h2 id=光照-材质><a href=#%E5%85%89%E7%85%A7-%E6%9D%90%E8%B4%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>光照 &amp材质</h2><h3 id=光照类型><a href=#%E5%85%89%E7%85%A7%E7%B1%BB%E5%9E%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>光照类型</h3><ul><li>平行光源: 类似太阳光, 可以认为发光光源距离无限远, 因此所有光线方向相同, 光照强度相同; 计算时只用考虑方向和颜色 <img src=http://eux-blog-static.bj.bcebos.com/directional-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A49Z%2F-1%2Fhost%2Faaa86929c4a748214bc37ef1d48cd31e8f6b815f34093338c9acf84ebc288a35 alt=image width=400 height=409></li><li>点光源: 类似聚光灯效果, 照射到物体上的光线方向不同, 强度也不同 <img src=http://eux-blog-static.bj.bcebos.com/point-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A06Z%2F-1%2Fhost%2F65f09f44063bd50c9ec10aa120044602989613a673be148f57e5f652fe422f2a alt=image width=400 height=501></li><li>环境光: 从各个方向以相同强度照射到物体上的光线, 计算时只考虑颜色 <img src=http://eux-blog-static.bj.bcebos.com/ambient-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A24Z%2F-1%2Fhost%2Fca1a609564e8e654e69fdbbdbea4700c46d1113d23ef2ccd7f36729131268c6a alt=image width=400 height=312></li></ul><h3 id=反射类型><a href=#%E5%8F%8D%E5%B0%84%E7%B1%BB%E5%9E%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>反射类型</h3><ul><li><p>漫反射(diffuse reflection) 光线照射在纸张, 木头等表面粗糙的物体上会发生漫反射, 光线会向各个方向均匀的反射, 强度与入射方向和表面方向夹角theta有关; 与观察方向无关</p><img src=http://eux-blog-static.bj.bcebos.com/diffuse-reflection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A48Z%2F-1%2Fhost%2Ff80a74eb2efcb4eb95e07ca196bc2930689d4c5d542f130b2e97640579ff7904 alt=image width=400 height=355></li></ul><pre><code data-query={} data-lang>计算公式: Diffuse = kDiffuse × N • L × CBase\\n    Diffuse表示漫反射颜色\\n    KDiffuse表示入射光颜色\\n    N表示物体表面法线方向\\n    L表示入射光方向\\n    CBase表示物体本身颜色\\n</code></pre><ul><li>环境反射(Ambient reflection) 环境光照射的效果, 由各个方向入射再反射到各个方向 <img src=http://eux-blog-static.bj.bcebos.com/ambient-reflection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A07Z%2F-1%2Fhost%2F1a52158474134fd9130f6d2da5ce8a6374e1d5c47538e6bb929bde9355457154 alt=image width=400 height=299></li></ul><pre><code data-query={} data-lang>计算公式: Ambient = kAmbient × CBase\\n    Ambient表示环境反射颜色\\n    kAmbient表示入射光颜色\\n    CBase表示物体本身颜色\\n</code></pre><ul><li>镜面反射(specular reflection) 在镜面, 金属等表面光滑物体表面, 入射光大部分会从单一方向反射出去, 因此反射强度跟入射方向, 物体表面方向和观察方向都有关系</li></ul><pre><code data-query={} data-lang>计算公式: Specular = kSpecular × pow(max(R • V, 0), kSpecularPower)\\n    Specular表示镜面反射颜色\\n    kSpecular表示入射光颜色\\n    R = 2 × N × (N • L) – L\\n    N, L分别表示法线方向和入射光方向\\n    V表示观察方向\\n    kSpecularPower表示高光系数, 代表物体表面反射光的能力\\n</code></pre><p>环境反射和平行光的漫反射可以在顶点着色器阶段计算, 因为不考虑光的方向或入射光方向一致;</p><p>聚光灯的漫反射和镜面反射效果需要在片段着色器阶段计算, 因为照射到物体表面的每个点光线方向不同(聚光灯漫反射)或对于每个点观察方向都不同(镜面反射)</p><p>物体表面某点的颜色 = 漫反射颜色 + 环境反射颜色 + 镜面反射颜色 (也可以没有镜面反射)</p><pre><code data-query={} data-lang>影响物体材质的因素:\\n    物体本身颜色(CBase)\\n    入射光颜色(kDiffuse, kAmbient, kSpecular)\\n    法线方向(N)\\n    入射方向(L)\\n    观察方向(V)\\n    高光系数(kSpecularPower)\\n</code></pre><h2 id=纹理贴图><a href=#%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>纹理贴图</h2><h3 id=贴图类型><a href=#%E8%B4%B4%E5%9B%BE%E7%B1%BB%E5%9E%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>贴图类型</h3><ul><li>色彩贴图: 将贴图的数据赋值给物体的本身颜色 <img src=http://eux-blog-static.bj.bcebos.com/basic-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A40Z%2F-1%2Fhost%2Fbf711f75e879569daeed43eaa4ee8b1e5c1d67619a9c24dec09e2ee99c0af420 alt=image width=400 height=391></li><li>法线贴图: 将贴图数据复制给法线N <img src=http://eux-blog-static.bj.bcebos.com/normal-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A58Z%2F-1%2Fhost%2F7ae0742678271df02115bb1bed9cde4a0ec84a10992490ff62939096a3b00607 alt=image width=400 height=389></li><li>高光贴图 类似法线贴图, 将贴图数据赋值给高光系数</li><li>凹凸贴图 类似法线贴图, 不过存储的是物体表面的相对高度, 也是通过高度参数影响原始的法线方向达到凹凸效果; 效果不如法线贴图</li><li>光照贴图: 模拟阴影效果 <img src=http://eux-blog-static.bj.bcebos.com/light-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A15Z%2F-1%2Fhost%2F1b9a02ff6794da9dd29226cf09d82460406c92f4e44cfca532b22646e89df7a2 alt=image width=400 height=389></li><li>环境贴图: 模拟物体的反光效果 <img src=http://eux-blog-static.bj.bcebos.com/env-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A29Z%2F-1%2Fhost%2Fe5935a030290a63bf27bed062175a75736021b35e1eef600b09dc99ef8ccb5fb alt=image width=400 height=313></li><li>立方环境贴图: 用六张图组成一个立方体, 将物体置于立方体中, 模拟全景效果 <img src=http://eux-blog-static.bj.bcebos.com/cube-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A52Z%2F-1%2Fhost%2F874ffa6f6b2d34c6885669db7c4cac62332c801971ce4d81d5a1a3ba4a824c2e alt=image width=400 height=272></li><li>... ...</li></ul><h3 id=uv贴图><a href=#uv%E8%B4%B4%E5%9B%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>UV贴图</h3><p>uv指2d图形的坐标名称, 在贴图时可以指定一个矩形的坐标; 可以指定放大缩小模式; 重复(repeat)模式等高级操作</p><img src=http://eux-blog-static.bj.bcebos.com/uv-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A24%3A13Z%2F-1%2Fhost%2F3b13b17cc4204b26de85a9a12cd7f12b6c2c86dba02917220347802746117431 alt=image width=700 height=437><p>[The uv coordinates are often used. However, we are using st coordinates because GLSL ES uses the component names to access the texture image.]</p><h2 id=webgl初始化流程及代码><a href=#webgl%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%BB%A3%E7%A0%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>webGL初始化流程及代码</h2><ul><li><p>获取webgl上下文</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> canvas = <span class=hljs-built_in>document</span>.querySelector(<span class=hljs-string>'#canvas'</span>);\\ngl = canvas.getContext(<span class=hljs-string>'webgl'</span>);</code></pre></li><li><p>初始化视窗(viewport)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>gl.viewportWidth = canvas.width;\\ngl.viewportHeight = canvas.height;\\ngl.viewport(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>, gl.viewportWidth, gl.viewportHeight);</code></pre></li><li><p>初始化顶点着色器(vertex shader)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> vertexShader = gl.createShader(gl.VERTEX_SHADER);\\n<span class=hljs-comment>// 这一步一般需要先load着色器源代码</span>\\ngl.shaderSource(vertexShader, <span class=hljs-string>'attribute vec4 a_Position ......  // 顶点着色器内容'</span>);\\ngl.compileShader(vertexShader);\\n<span class=hljs-comment>// 获取着色器编译状态, 如果出错则打印log信息并结束</span>\\n<span class=hljs-keyword>if</span> (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\\n        <span class=hljs-built_in>console</span>.log(gl.getShaderInfoLog(vertexShader));\\n        <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>初始化片段着色器(fragment shader)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\\ngl.shaderSource(fragmentShader, <span class=hljs-string>'varying vec4 v_Color ......  //片段着色器内容'</span>);\\ngl.compileShader(fragmentShader);\\n<span class=hljs-keyword>if</span> (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\\n        <span class=hljs-built_in>console</span>.log(gl.getShaderInfoLog(fragmentShader));\\n        <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>初始化程序(program)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>gl.program = gl.createProgram();\\n<span class=hljs-comment>// 绑定着色器, 不同的'程序'可以绑定不同的着色器</span>\\ngl.attachShader(gl.program, vertexShader);\\ngl.attachShader(gl.program, fragmentShader);\\n<span class=hljs-comment>// 链接程序</span>\\ngl.linkProgram(gl.program);\\n<span class=hljs-comment>// 检查程序链接状态</span>\\n<span class=hljs-keyword>if</span> (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {\\n         <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'program link problem'</span>);\\n         <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>使用程序(program)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 使用刚刚初始化好的程序, 可以创建多个program来使用</span>\\ngl.useProgram(gl.program);</code></pre></li><li><p>初始化顶点数组(vertex buffer)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * initVertexBuffers: vertices, indices => n\\n *     vertices: Float32Array    // 顶点数组,一般需要是有类型的特殊Array\\n *     indices: Uint8Array       // 序号数组, 序号指顶点数组中的序号index\\n *     n: number                 // 顶点数, indices.length\\n */</span>            \\ngl.n = initVertexBuffers(vertices, indices);\\n<span class=hljs-keyword>if</span> (gl.n &lt;= <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to initialize vertex buffers&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><ul><li><p>vertices &amp indices</p><p>表示顶点数组和序号数组, 如一个正方体的顶点数组</p><img src=http://eux-blog-static.bj.bcebos.com/cube-coordinate.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A25%3A04Z%2F-1%2Fhost%2F12b107edecdaa381bf201d0bfbefbaba4e9fe095b72d4f17077f4f792860a1af alt=image width=400 height=379> ```javascript /** * vertices数组, 前三个数字代表一个三维空间坐标点, 后三个数字代表颜色 * 下面例子里列出的内容表示一个正方体的正面(front)的坐标点 **/ var vertices = new Float32Array([ 1.0, 1.0, 1.0, 0.0, 0.0, -1.0, // v0 -1.0, 1.0, 1.0, 0.0, 0.0, -1.0, // v1 -1.0, -1.0, 1.0, 0.0, 0.0, -1.0, // v2 1.0, -1.0, 1.0, 0.0, 0.0, -1.0, // v3 front ... ... ]), ```<pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * indices数组, 0,1,2  0,2,3分别表示一个三角形, 两个三角形组成正方体的一个面\\n * 三角形点的顺序要逆时针列出(右手定则), 顺序不对的话会被当成背对屏幕而不被渲染\\n **/</span>     \\n<span class=hljs-keyword>var</span> indices = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Uint8Array</span>([\\n    <span class=hljs-number>0</span>, <span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>0</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>,           <span class=hljs-comment>// front</span>\\n    <span class=hljs-number>4</span>, <span class=hljs-number>5</span>, <span class=hljs-number>6</span>, <span class=hljs-number>4</span>, <span class=hljs-number>6</span>, <span class=hljs-number>7</span>,           <span class=hljs-comment>// right</span>\\n    <span class=hljs-number>8</span>, <span class=hljs-number>9</span>, <span class=hljs-number>10</span>, <span class=hljs-number>8</span>, <span class=hljs-number>10</span>, <span class=hljs-number>11</span>,        <span class=hljs-comment>// up</span>\\n    <span class=hljs-number>12</span>, <span class=hljs-number>13</span>, <span class=hljs-number>14</span>, <span class=hljs-number>12</span>, <span class=hljs-number>14</span>, <span class=hljs-number>15</span>,     <span class=hljs-comment>// left</span>\\n    <span class=hljs-number>16</span>, <span class=hljs-number>17</span>, <span class=hljs-number>18</span>, <span class=hljs-number>16</span>, <span class=hljs-number>18</span>, <span class=hljs-number>19</span>,     <span class=hljs-comment>// down</span>\\n    <span class=hljs-number>20</span>, <span class=hljs-number>21</span>, <span class=hljs-number>22</span>, <span class=hljs-number>20</span>, <span class=hljs-number>22</span>, <span class=hljs-number>23</span>      <span class=hljs-comment>// back              </span>\\n])</code></pre></li><li><p>initVertexBuffers</p><ul><li><p>初始化buffer</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> vertexBuffer = gl.createBuffer();\\n<span class=hljs-keyword>var</span> indexBuffer = gl.createBuffer();\\n<span class=hljs-keyword>if</span> (!vertexBuffer || !indexBuffer) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to create buffer&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>绑定buffer</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 绑定vertexBuffer并填入值vertices</span>\\n<span class=hljs-comment>// 注意!! 顶点的原始数据必须用gl.ARRAY_BUFFER存储</span>\\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\\ngl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 绑定indexBuffer并填入值indices</span>\\n<span class=hljs-comment>// 注意!! 顶点的index必须用gl.ELEMENT_ARRAY_BUFFER存储</span>\\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);</code></pre></li><li><p>初始化Attributes</p><ul><li><p>定义attributes数组</p><pre><code data-query={} data-lang>attributes是vertices数组的结构定义, 必须跟vertices数组对应起来\\n\\n- vertices结构\\n\\n    &lt;img src=\\\"http://eux-blog-static.bj.bcebos.com/vertex-object-structure.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A25%3A28Z%2F-1%2Fhost%2F1359f6ce7d9adf4c7a93cd950c25d3126d6cc3d9a5a1959bd8e7c2cfbe708749\\\" alt=\\\"image\\\" width=\\\"550\\\" height=\\\"94\\\" />\\n    \\n    如图vertices数组中10个数字表示一个顶点, 分别表示坐标位置; 法向量方向; 贴图TEX0的坐标位置; 贴图TEX1的坐标位置\\n\\n    这种vertices结构叫*Array of structure*, 通常用3D软件生成的顶点数据都是这个结构;也可以为position, normal, color每种数据都建立一个buffer, 这种结构叫*Structure of Array*\\n\\n    ```javascript\\n    /**\\n     * 根据上面的结构定义的attributes\\n     * size表示当前attribute由几个元素组成, 范围大小是1~4\\n     * strip表示由几个元素代表一个顶点, 每个attribute都相同\\n     * offset表示从第几个元素开始查找, 这个要算之前的attribute占用了多少元素\\n     **/\\n    var attributes = [\\n        {name: &amp#039;a_position&amp#039;, size: 3, strip: 10, offset: 0},\\n        {name: &amp#039;a_normal&amp#039;, size: 3, strip: 10, offset: 3},\\n        {name: &amp#039;a_tex0&amp#039;, size: 2, strip: 10, offset: 6},\\n        {name: &amp#039;a_tex1&amp#039;, size: 2, strip: 10, offset: 8}\\n    ];\\n    ```\\n\\n```javascript\\n// 根据正方体vertices数组定义的attributes结构\\nvar attributes = [\\n    {name: &amp#039;a_position&amp#039;, size: 3, strip: 10, offset: 0},\\n    {name: &amp#039;a_color&amp#039;, size: 3, strip: 10, offset: 3}\\n];\\n```\\n</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 记录FSIZE, 即顶点数组每个元素的byte数, 后面需要使用</span>\\ngl.FSIZE = vertices.BYTES_PER_ELEMENT;\\n<span class=hljs-comment>// 遍历attributes并初始化</span>\\n<span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; attributes.length; i++) {\\n    initAttributes(attributes[i]);\\n}</code></pre></li><li><p>initAttributes</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 为attribute分配存储空间</span>\\n<span class=hljs-keyword>var</span> a_Loc = gl.getAttribLocation(gl.program, attribute.name);\\n<span class=hljs-comment>// a_Loc是分配的存储空间地址, 如果小于0表示分配失败</span>\\n<span class=hljs-keyword>if</span> (a_Loc &lt; <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to get location <span class=hljs-keyword>of</span>&amp#<span class=hljs-number>039</span>; + attr.name);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 定义attribute查找规则</span>\\ngl.vertexAttribPointer(\\n    a_Loc,\\n    attribute.size,    <span class=hljs-comment>// 3</span>\\n    gl.FLOAT,          <span class=hljs-comment>// 数据类型</span>\\n    <span class=hljs-literal>false</span>,             <span class=hljs-comment>// 实际类型跟FLOAT不符时的处理, 这里符合所以false</span>\\n    gl.FSIZE * attribute.strip,    <span class=hljs-comment>// 4 * 6</span>\\n    gl.FSIZE * attribute.offset   <span class=hljs-comment>// 4 * (0 | 3)</span>\\n);\\n<span class=hljs-comment>// enable分配的存储位置</span>\\ngl.enableVertexAttribArray(a_Loc);</code></pre></li><li><p>初始化Uniforms</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 定义uniforms数组: 变量名, 类型, 地址, 值</span>\\n<span class=hljs-keyword>var</span> uniforms = [\\n    {<span class=hljs-attr>name</span>: &amp#<span class=hljs-number>039</span>;u_b_direct_light&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>type</span>: &amp#<span class=hljs-number>039</span>;b&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>location</span>: <span class=hljs-literal>null</span>, <span class=hljs-attr>value</span>: <span class=hljs-literal>null</span>},\\n    {<span class=hljs-attr>name</span>: &amp#<span class=hljs-number>039</span>;u_MvpMatrix&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>type</span>: &amp#<span class=hljs-number>039</span>;mat4&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>location</span>: <span class=hljs-literal>null</span>, <span class=hljs-attr>value</span>: <span class=hljs-literal>null</span>},\\n    {<span class=hljs-attr>name</span>: &amp#<span class=hljs-number>039</span>;u_MvMatrix&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>type</span>: &amp#<span class=hljs-number>039</span>;mat4&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>location</span>: <span class=hljs-literal>null</span>, <span class=hljs-attr>value</span>: <span class=hljs-literal>null</span>},\\n    <span class=hljs-comment>// ... ...</span>\\n]</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 遍历uniforms并初始化</span>\\n<span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; uniforms.length; i++) {\\n    initUniforms(uniforms[i]);\\n}</code></pre><ul><li><p>initUniforms</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 分配uniform存储空间</span>\\n<span class=hljs-keyword>var</span> u_Loc = gl.getUniformLocation(gl.program, uniform.name);\\n<span class=hljs-keyword>if</span> (u_Loc &lt; <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to get location <span class=hljs-keyword>of</span> u_MvpMatrix&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}\\n<span class=hljs-keyword>else</span> {\\n    uniform.location = u_Loc;\\n}</code></pre></li><li><p>updateUniforms</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 给uniform赋值, 不同的类型对应不同的方法\\n * 其中f表示float, i表示integer, v表示vector; 一般matrix和vector都是数组\\n * gl.uniformxxxx的第一个参数是之前缓存的uniform地址\\n * 第二个参数表示是否需要转置矩阵(横竖反转), webGL里不具有这个功能, 必须传false\\n * 第三个参数是uniform值, 可以是数组或单个数字, 数字可以是float或inter类型\\n * 具体内容需要跟前面的api对应起来\\n **/</span>\\n<span class=hljs-keyword>if</span> (uniform.value) {\\n    <span class=hljs-keyword>try</span> {\\n        <span class=hljs-keyword>switch</span> (uniform.type) {\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;mat4&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformMatrix4fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;mat3&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformMatrix3fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;vec4&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformVec4fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;vec3&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformVec3fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;f&amp#<span class=hljs-number>039</span>;:\\n                <span class=hljs-keyword>if</span> (uniform.value.length) {\\n                    gl.uniform1fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>else</span> {\\n                    gl.uniform1f(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;i&amp#<span class=hljs-number>039</span>;:\\n                <span class=hljs-keyword>if</span> (uniform.value.length) {\\n                    gl.uniform1iv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>else</span> {\\n                    gl.uniform1i(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>break</span>;\\n        }\\n    }\\n}</code></pre></li></ul></li></ul></li></ul></li></ul></li><li><p>初始化纹理(texture)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 如果需要使用纹理</span>\\n<span class=hljs-keyword>if</span> (!initTextures(imageSrc)) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to initialize texture&amp#<span class=hljs-number>039</span>;);\\n}</code></pre><ul><li><p>initTextures</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 创建texture</span>\\n<span class=hljs-keyword>var</span> texture = gl.createTexture();\\n<span class=hljs-keyword>if</span> (!texture) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to create texture&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 为u_Sampler分配空间, texture会是u_Sampler的值</span>\\n<span class=hljs-keyword>var</span> u_Sampler = gl.getUniformLocation(gl.program, &amp#<span class=hljs-number>039</span>;u_Sampler&amp#<span class=hljs-number>039</span>;);\\n<span class=hljs-keyword>if</span> (u_Sampler &lt; <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to get location <span class=hljs-keyword>of</span> u_Sampler&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 加载图片并loadTexture</span>\\n<span class=hljs-keyword>var</span> image = <span class=hljs-keyword>new</span> Image();\\nimage.src = <span class=hljs-built_in>require</span>(imageSrc);\\nimage.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    loadTexture(texture, u_Sampler, image);\\n};</code></pre><ul><li><p>loadTexture</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 翻转图片的Y坐标; 1表示enable前面的配置项\\n * 因为贴图的uv(或st)坐标系跟html的xy坐标系, y轴方向正好相反\\n * 所以之后要使用贴图的uv坐标通常需要这步操作\\n **/</span>\\ngl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, <span class=hljs-number>1</span>);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 一个program最多可以使用8个贴图, 从gl.TEXTURE0 到 gl.TEXTURE7\\n * 这里只用了一个所以只active TEXTURE0\\n **/</span>\\ngl.activeTexture(gl.TEXTURE0);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 绑定texture, 这一步是要告诉webGL texture的类型\\n * 除了立方体贴图要用gl.TEXTURE_CUBE_MAP, 其它的基本都用gl.TEXTURE_2D\\n **/</span>\\ngl.bindTexture(gl.TEXTURE_2D, texture);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 这一步设置应用贴图时的参数, 第一个参数指定贴图类型(2d或cude)\\n * 后面两个参数分别是贴图处理方法(funcName)和对应的值(funcValue)\\n * 后面详细介绍\\n **/</span>\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);</code></pre><ul><li><p>texPrameter - funcName</p><pre><code data-query={} data-lang>gl.TEXTURE_MAG_FILTER: 放大策略; 当贴图大小比目标区域小的时候的放大策略, 可以使用gl.NEAREST和gl.LINEAR两个值\\n\\ngl.TEXTURE_MIN_FILTER: 缩小策略: 当贴图大小比目标区域大时的缩小策略, 可以使用gl.NEAREST和gl.LINEAR及MIPMAP的所有值\\n\\ngl.TEXTURE_WRAP_S: s轴(横轴)填充策略: 可以使用REPEAT, MIRRORED_REPEAT, CLAMP_TO_EDGE三种策略, 默认REPEAT\\n\\ngl.TEXTURE_WRAP_T: t轴(纵轴)填充策略: 可以使用REPEAT, MIRRORED_REPEAT, CLAMP_TO_EDGE三种策略, 默认REPEAT\\n</code></pre></li><li><p>texPrameter - funcValue</p><pre><code data-query={} data-lang>```\\ngl.NEAREST: 取与目标像素几何距离最近的点\\n\\ngl.LINEAR: 取与目标像素距离最近的四个点做权重平均(or bilinear fetch); 一般比NEAREST更清晰, 但更花时间\\n\\nMIPMAP ———— 把贴图标准化为类似16x16, 32x32, 64x64等一系列图片, 然后根据目标区域大小选取相应的图片处理; 使用MIPMAP的话后面需要手工加载不同级别的图片\\n\\n    gl.NEAREST_MIPMAP_NEAREST: 取一个跟目标区域最相近的图片, 然后再用NEAREST选一个最近的点\\n\\n    gl.LINEAR_MIPMAP_NEAREST: 取一个跟目标区域最相近的图片, 然后再用LINEAR的方式算出点\\n\\n    gl.NEAREST_MIPMAP_LINEAR: 取跟目标区域大小最相近的较大较小两个图片, 然后做插值算出点\\n\\n    gl.LINEAR_MIPMAP_LINEAR: 先取最相近的两个图片分别做LINEAR(bilinear fetch)算出两个点, 然后再做插值算出目标点; 这种方式叫: trilinear filtering, 是所有方式中质量最高的\\n\\ngl.REPEAT: 复制\\n\\ngl.MIRRORED_REPEAT: 镜像复制\\n\\ngl.CLAMP_TO_EDGE: 用贴图的边缘颜色填充\\n```\\n</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**</span></code></pre></li></ul><ul><li><p>将图片绑定到texture对象上, 第一个参数指定贴图类型(2d或cube)</p></li><li><p>第二个参数指定MIPMAP级别, 不使用时默认传0, 如果使用MIPMAP则需要绑定0~n不同级别的图片</p></li><li><p>第三个参数指定图片像素的数据类型, 有RGB, RGBA, ALPHA, LUMINANCE, LUMINANCE_ALPHA几种</p></li><li><p>第四个参数指定贴图像素被使用时的数据类型, 需要跟第三个参数保持相同</p></li><li><p>第五个参数指定贴图像素的数据类型, 有</p></li><li><p>UNSIGNED_BYTE: 每个部分占1byte</p></li><li><p>UNSIGNED_SHORT_5_6_5: RGB类型且分别占5,6,5 bits</p></li><li><p>UNSIGNED_SHORT_4_4_4_4: RGBA类型且分别占4bits</p></li><li><p>UNSIGNED_SHORT_5_5_5_1: RGBA类型前三个占4bits, 最后alpha占1bits</p></li><li><p>最后一个参数是加载的image对象 **/ gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);</p><pre><code data-query={} data-lang>```javascript\\n/**\\n</code></pre></li><li><p>给之前分配空间的uniform: u_Sampler赋值</p></li><li><p>这一步跟普通的uniform赋值一样, 只是后面的0对应gl.TEXTURE0</p></li><li><p>如果之前绑定的是TEXTUREn这里需要传n</p></li><li><p>在片段着色器中的声明方式:</p></li><li><p>uniform sampler2D u_Sampler;</p></li><li><p>如果是立方体贴图需要把sampler2D改成samplerCube **/ gl.uniform1i(u_Sampler, 0);</p><pre><code data-query={} data-lang></code></pre></li></ul></li></ul></li></ul></li><li><p>开启深度检测(depth test)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 一般需要开启深度检测</span>\\ngl.enable(gl.DEPTH_TEST);</code></pre></li><li><p>开启其它可选的后处理</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>gl.enable(gl.BLEND);\\ngl.enable(gl.STENCIL_TEST);\\n<span class=hljs-comment>// ... ...</span>\\n<span class=hljs-comment>// 除了enable之外一般还需要设置其它相关参数和方法, 如</span>\\n<span class=hljs-comment>// gl.blendFunc(... ....);</span>\\n<span class=hljs-comment>// gl.stencilFunc(... ....);</span></code></pre></li><li><p>初始化颜色及buffer</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 清空颜色</span>\\ngl.clearColor(<span class=hljs-number>0.0</span>, <span class=hljs-number>0.0</span>, <span class=hljs-number>0.0</span>, <span class=hljs-number>1.0</span>);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 清空buffer, 如果使用了stencilTest, 需要清空 gl.STENCIL_BUFFER_BIT</span>\\ngl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</code></pre></li></ul><h2 id=webgl渲染流程及代码><a href=#webgl%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%BB%A3%E7%A0%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>webGL渲染流程及代码</h2><ul><li><p>跟进用户交互及时间等参数更新uniform值 (参考updateUniforms)</p></li><li><p>清空buffer (参考初始化颜色及buffer)</p></li><li><p>绘制图形</p><ul><li><p>drawElements: 使用的是之前初始化的indexBuffer (参考绑定vertexBuffer)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 第一个参数表示绘制的图元mode, 后面有详细介绍\\n * 第二个参数表示需要绘制的顶点序号数量, 这里绘制全部所以是gl.n\\n * 第三个参数表示存储的顶点序号的数据类型, 有gl.UNSIGNED_BYTE | gl.UNSIGNED_SHORT两种\\n * 对应js里Uint8Array | Uint16Array两种数据定义\\n * 第四个参数是offset, 从indexBuffer的第几个元素开始绘制\\n **/</span>\\ngl.drawElements(gl.TRIANGLES, gl.n, gl.UNSIGNED_BYTE, <span class=hljs-number>0</span>);        </code></pre></li><li><p>drawArrays: 使用的是之前初始化的vertexBuffer, 即顶点原始数据 (参考绑定indexBuffer)</p><pre><code data-query={} data-lang>```javascript\\n/**\\n * 第一个参数表示绘制的图元mode, 后面有详细介绍\\n * 第二个参数是offset, 从vertexBuffer的第几个元素开始绘制\\n * 第三个参数表示需要绘制的顶点序号数量\\n **/\\ngl.drawArrays(gl.TRIANGLE_STRIP, 0, gl.n);\\n```\\n</code></pre><p>drawArrays跟drawElement不同的是它只能顺序的使用vertexBuffer的顶点, 不能指定序号;</p><p>因为3D建模工具导出的数据一般都会有顶点的复用, 不能顺序使用, 所以一般复杂模型都会使用indexBuffer绘制</p></li><li><p>draw mode:</p><img src=http://eux-blog-static.bj.bcebos.com/draw-mode.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A26%3A27Z%2F-1%2Fhost%2Fbc9d30732869b61a5375c171fd63875c2bce7e65fa6ea3f522bb434408aeec56 alt=image width=700 height=424><pre><code data-query={} data-lang>gl.POINTS: 根据使用的是vertexBuffer还是indexBuffer, 顺序的画点\\n\\ngl.LINES: 以v0-v1, v2-v3, v4-v5,的顺序画线\\n\\ngl.LINE_STRIP: 以v0-v1-v2-v3-v4-v5的顺序画整条线\\n\\ngl.LINE_LOOP: 以v0-v1-v2-v3-v4-v5-v0的顺序连接起点和终点\\n\\ngl.TRIANGLES: 以v0-v1-v2, v3-v4-v5的顺序画三角形\\n\\ngl.TRIANGLES_STRIP: 以v0-v1-v2, v2-v1-v3, v2-v3-v4, v4-v3-v5的顺序画连续的三角形\\n\\ngl.TRIANGLES_FAN: 以v0-v1-v2, v0-v2-v3, v0-v3-v4, v0-v4-v5的顺序画扇形的三角形\\n</code></pre></li></ul></li></ul><h2 id=一些后续学习内容><a href=#%E4%B8%80%E4%BA%9B%E5%90%8E%E7%BB%AD%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>一些后续学习内容:</h2><ul><li>理解和灵活运用 (坐标变换 &amp图形变换) 部分的矩阵变换公式和api</li><li>(光照 &amp材质) 相关的高级光照效果</li><li>(纹理贴图) 相关的高级贴图效果及uv贴图应用</li><li>顶点着色器和片段着色器的使用, <a href=https://www.shadertoy.com/>shadertoy</a> 上有大量着色器可以参考</li><li>一些高级效果, 如阴影, 反射, 雾, 使用多个gl program, 用户键盘及鼠标交互, 动画及骨架原理等等... ...</li><li>如何转换并使用3d建模工具(如blender)导出的模型相关数据</li></ul><h2 id=参考资料><a href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>参考资料:</h2><ul><li>WebGL Programming Guide (webGL编程指南)</li><li>OpenGL ES 2.0 Programming Guide (OpenGL ES 2.0编程指南)</li><li><a href=https://threejs.org/>threejs</a> 例子, 教程, 源码学习</li></ul>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// blog/fe/832.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<h2 id=背景介绍><a href=#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>背景介绍</h2><p>OpenGL -> OpenGL ES -> OpenGL ES 2.0 -> WebGL</p><img src=http://eux-blog-static.bj.bcebos.com/relations.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A10%3A58Z%2F-1%2Fhost%2F4a71a255776a0d2ccad6e3770850dd41f3084c637ee63baa27380577e955bea4 alt=image width=748 height=273><p>OpenGL Embeded Subset是OpenGL的一个子集, 针对嵌入式和移动端做了功能精简和性能优化</p><p>WebGL基于OpenGL ES 2.0标准, 基本就是将原来C语言的API和配置项迁移到Javascript, 去掉了一些实在不兼容的部分</p><p>WebGL 2.0基于OpenGL ES 3.0</p><h2 id=渲染管道pipeline><a href=#%E6%B8%B2%E6%9F%93%E7%AE%A1%E9%81%93pipeline aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>渲染管道(PipeLine)</h2><img src=http://eux-blog-static.bj.bcebos.com/pipeLine.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A11%3A28Z%2F-1%2Fhost%2F05b7a0082971623bc87bfde081711104b5c83f3d206e1cce2bae0f5f4927de3d alt=image width=748 height=537><h3 id=vertex-array-顶点数组><a href=#vertex-array-%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Vertex Array: 顶点数组</h3><p>初始化数据(利用3D建模工具等生成的模型顶点)</p><h3 id=vertex-shader-顶点着色器><a href=#vertex-shader-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Vertex Shader: 顶点着色器</h3><p>计算坐标, 颜色等顶点相关数据, 相关概念:</p><ul><li>Attributes: 从顶点数组获取的每个顶点的初始数据</li><li>Uniforms: 计算需要的常量数据</li><li>Samplers: 代表材质(Texture)的一类特殊常量, 在顶点着色器中是可选的</li><li>Shader Program: 着色器程序, 使用着色器语言(Shading Language, 类似C语言)编写的可执行程序代码, 指定需要在顶点上作什么样的计算和处理</li><li>Varying Variables: 顶点着色器的输出, 计算出的每个顶点相关数据</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>attribute vec4 a_Position;\\nattribute vec4 a_Color;\\nuniform mat4 u_MvpMatrix;\\nvarying vec4 v_Color;\\n<span class=hljs-keyword>void</span> main() {\\n    gl_Position = u_MvpMatrix * a_Position;\\n    v_Color = a_Color;\\n}</code></pre><h3 id=primitive-assemply-图元组装><a href=#primitive-assemply-%E5%9B%BE%E5%85%83%E7%BB%84%E8%A3%85 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Primitive Assemply: 图元组装</h3><p>根据计算出的顶点信息和绘图命令绘制基本图形, 包括: 三角形(Triangle), 直线(Line), 点(Point-Sprite); 一般3d图形都是由三角形组成的</p><h3 id=rasterization-栅格化><a href=#rasterization-%E6%A0%85%E6%A0%BC%E5%8C%96 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Rasterization: 栅格化</h3><p>利用插值(interpolation)的方法计算顶点之间的边及边之间的内部点的数据, 计算出的数据就是所有需要绘制的像素点, 作为输入传给Fragment Shader</p><img src=http://eux-blog-static.bj.bcebos.com/rasterization.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A11%3A57Z%2F-1%2Fhost%2Fce034b581502a98d42b48880299e4ac87674a2c8d81706d1e898cb67f79225bc alt=image width=748 height=155><p>一般栅格化之前还要经过裁剪(clipping, 把不在可见区域范围内的点去掉); 剔除(culling, 把背对可见方向, 完全不会被看见的面去掉), 来减少计算量</p><h3 id=fragment-shader-片段着色器-像素着色器><a href=#fragment-shader-%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8-%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Fragment Shader: 片段着色器, 像素着色器</h3><p>在这个阶段可以应用材质(Texture), 进行逐像素的颜色处理, 相关概念:</p><ul><li>Varying Variables: 栅格化的结果, 计算出的每个像素点相关数据</li><li>Uniforms: 计算需要的常量数据</li><li>Samplers: 代表材质(Texture)的一类特殊常量</li><li>Shader Program: 着色器程序, 使用着色器语言(Shading Language, 类似C语言)编写的可执行程序代码, 指定需要在像素点上作什么样的计算和处理</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>varying vec4 v_Color;\\n<span class=hljs-keyword>void</span> main() {\\n    gl_FragColor = v_Color;\\n}</code></pre><h3 id=per-fragment-operations-逐像素处理><a href=#per-fragment-operations-%E9%80%90%E5%83%8F%E7%B4%A0%E5%A4%84%E7%90%86 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Per-Fragment Operations: 逐像素处理</h3><p>对像素执行一些可选的后处理</p><img src=http://eux-blog-static.bj.bcebos.com/per-fragment-operation.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A12%3A39Z%2F-1%2Fhost%2Fead684c7662d16a8407267409586cd8d156115a856838c73a77ca48c729fc286 alt=image width=748 height=230><ul><li>scissor test: 限制只在一个矩形区域更新像素</li><li>stencil test: 像素级的蒙板(stecil buffer), 可以定义哪些蒙板区域更新, 哪些不更新</li><li>depth test: 默认需要开启, 测试像素的深度, 决定哪些像素</li></ul><h3 id=framebuffer-帧缓存><a href=#framebuffer-%E5%B8%A7%E7%BC%93%E5%AD%98 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Framebuffer: 帧缓存</h3><p>一个GL Context可以有多个帧缓存, 存储可渲染区域的像素相关数据</p><h2 id=坐标变换-图形变换><a href=#%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2-%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>坐标变换 &amp图形变换</h2><p>通常在顶点着色器中应用坐标变换, 计算每个顶点的最终坐标位置</p><img src=http://eux-blog-static.bj.bcebos.com/coordinate-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A18Z%2F-1%2Fhost%2F37db9570c8314c6b16fc0bd81b51cdb343731cf358d4b5e48744c55e6ddf3c5a alt=image width=748 height=214><h3 id=本地坐标系local-coordinate-system><a href=#%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%B3%BBlocal-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>本地坐标系(local coordinate system)</h3><p>指通过算法或建模软件生成模型时的坐标系, 通常以模型自己的中心点为坐标原点</p><img src=http://eux-blog-static.bj.bcebos.com/local-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A39Z%2F-1%2Fhost%2F0ac6e90894094f42c2abbeb49f2aefbfe0d614c4930c3d30a88dc3a338976a20 alt=image width=400 height=379><h3 id=世界坐标系world-coordinate-system><a href=#%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E7%B3%BBworld-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>世界坐标系(world coordinate system)</h3><p>通过平移, 旋转, 放缩等图形变换方法, 把模型放置到一个更大的坐标系中</p><img src=http://eux-blog-static.bj.bcebos.com/world-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A59Z%2F-1%2Fhost%2F1e7c30d42c77b4f3fc96dc90fa37bfabc05f3e9aa287d381d4e4899f5bfafa41 alt=image width=748 height=344><h4 id=图形变换><a href=#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>图形变换</h4><p>任何图形变换都可以用矩阵的方式表达; 不同变换的叠加可以用矩阵相乘的形式来计算. 可以参考 <a href=http://glmatrix.net/docs/module-quat.html>glMatrix</a> 库的 rotate, translate, scale等方法</p><h3 id=观察坐标系view-coordinate-system><a href=#%E8%A7%82%E5%AF%9F%E5%9D%90%E6%A0%87%E7%B3%BBview-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>观察坐标系(view coordinate system)</h3><p>通过指定观察点坐标(eye point), 目标点(lookAt point), 竖直方向(up vector)来确定一个观察坐标系</p><img src=http://eux-blog-static.bj.bcebos.com/view-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A01Z%2F-1%2Fhost%2F98df745d508e5fc824b8748a15628ae0d00b98b1b6f00d0f8969cde13698da40 alt=image width=748 height=239><p>观察矩阵的生成可以参考<a href=http://glmatrix.net/docs/module-quat.html>glMatrix</a> 库的lookAt方法</p><img src=http://eux-blog-static.bj.bcebos.com/lookAt-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A29Z%2F-1%2Fhost%2Ff087aec8d1cc64e42116443a78373d568ef015d2966be2c0caedd9bc8a6b794a alt=image width=748 height=144><p>观察矩阵和图形变换矩阵有时是可以互换的, 把物体位置向观察点靠近和把观察点向物体靠近, 两种变化效果是一样的</p><p>只是一个应用了图形变换, 一个应用了观察坐标系变换. 通常这两种变换是结合使用, 各有各的目的</p><h3 id=剪裁坐标系clipping-coordinate-system><a href=#%E5%89%AA%E8%A3%81%E5%9D%90%E6%A0%87%E7%B3%BBclipping-coordinate-system aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>剪裁坐标系(clipping coordinate system)</h3><p>在这一步会利用投影的方法, 把一个3D的物体投影的2D的屏幕中去</p><p>这一步可以确认物体是否在可见范围内, 哪一部分在可见范围内, 所以叫剪裁坐标系</p><h4 id=正交投影orthographic-projection><a href=#%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1orthographic-projection aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>正交投影(orthographic projection)</h4><p>用一个盒子状的可见范围平行投影物体, 没有近大远小的概念, left, right, bottom, top, near, far分别表示盒子的六个面的坐标</p><img src=http://eux-blog-static.bj.bcebos.com/orthographic-projection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A57Z%2F-1%2Fhost%2F90ad01daebdb5c7b7565cee6906d1ec2d30faf3dd9e494d2ea2c4684536b7277 alt=image width=748 height=437><p>glMatrix中的对应方法</p><img src=http://eux-blog-static.bj.bcebos.com/ortho-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A18%3A23Z%2F-1%2Fhost%2Fd50d52f7366f517051a94bbe4f57faacb1153857f4c8af042fe28c0661371ff4 alt=image width=748 height=104><p>矩阵公式</p><img src=http://eux-blog-static.bj.bcebos.com/ortho-matrix.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A18%3A48Z%2F-1%2Fhost%2F8794b1092eb2d52dd4bdca29f2469ca05560ab4221ad3e9bfc2d9cdc1e1855b9 alt=image width=500 height=227><h4 id=透视投影perspective-projection><a href=#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1perspective-projection aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>透视投影(perspective projection)</h4><p>类似素描里近大远小的透视方法, 用一个四面梯形定义可见范围, fov表示视角(上下平面之间角度), aspect表示剪裁矩形的宽高比, near和far表示剪裁近平面和远平面</p><img src=http://eux-blog-static.bj.bcebos.com/perspective-projection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A11Z%2F-1%2Fhost%2F8bdae66dd39c5c9450ec65b5a58174218535381a1a5cc52dfad550c4c9a03f66 alt=image width=748 height=347><p>glMatrix的方法</p><img src=http://eux-blog-static.bj.bcebos.com/perspective-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A33Z%2F-1%2Fhost%2F199a2df06bf15c70d14438e2945200ef6db70f61973b93c40e816997c68ccb19 alt=image width=748 height=109><p>矩阵公式</p><img src=http://eux-blog-static.bj.bcebos.com/perspective-matrix.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A49Z%2F-1%2Fhost%2F1f36856449c354990b71b02b62dcb2fb27cd35f4619a588e6bc44a3540e247b8 alt=image width=500 height=256><p>最终的剪裁坐标系x, y, z轴都会标准化为[-1, 1]的范围, z轴表示物体的前后覆盖关系; 在剪裁阶段所有坐标不在[-1, 1]范围内的点都会认为不可见(z轴是0到-1, 因为观察点在0点且向负方向看)</p><img src=http://eux-blog-static.bj.bcebos.com/cliping-system-1.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A09Z%2F-1%2Fhost%2Fe40dc957de2cfbf9e1399eaafbfe6dba0953f1995aa0c8fbfbe55ba056663cb9 alt=image width=748 height=272> <img src=http://eux-blog-static.bj.bcebos.com/cliping-system-2.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A21Z%2F-1%2Fhost%2F13361f77c179c166e2fcc46fbc0f785bf1b31585b2e978ecd69593a925020a18 alt=image width=500 height=403><h2 id=光照-材质><a href=#%E5%85%89%E7%85%A7-%E6%9D%90%E8%B4%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>光照 &amp材质</h2><h3 id=光照类型><a href=#%E5%85%89%E7%85%A7%E7%B1%BB%E5%9E%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>光照类型</h3><ul><li>平行光源: 类似太阳光, 可以认为发光光源距离无限远, 因此所有光线方向相同, 光照强度相同; 计算时只用考虑方向和颜色 <img src=http://eux-blog-static.bj.bcebos.com/directional-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A49Z%2F-1%2Fhost%2Faaa86929c4a748214bc37ef1d48cd31e8f6b815f34093338c9acf84ebc288a35 alt=image width=400 height=409></li><li>点光源: 类似聚光灯效果, 照射到物体上的光线方向不同, 强度也不同 <img src=http://eux-blog-static.bj.bcebos.com/point-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A06Z%2F-1%2Fhost%2F65f09f44063bd50c9ec10aa120044602989613a673be148f57e5f652fe422f2a alt=image width=400 height=501></li><li>环境光: 从各个方向以相同强度照射到物体上的光线, 计算时只考虑颜色 <img src=http://eux-blog-static.bj.bcebos.com/ambient-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A24Z%2F-1%2Fhost%2Fca1a609564e8e654e69fdbbdbea4700c46d1113d23ef2ccd7f36729131268c6a alt=image width=400 height=312></li></ul><h3 id=反射类型><a href=#%E5%8F%8D%E5%B0%84%E7%B1%BB%E5%9E%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>反射类型</h3><ul><li><p>漫反射(diffuse reflection) 光线照射在纸张, 木头等表面粗糙的物体上会发生漫反射, 光线会向各个方向均匀的反射, 强度与入射方向和表面方向夹角theta有关; 与观察方向无关</p><img src=http://eux-blog-static.bj.bcebos.com/diffuse-reflection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A48Z%2F-1%2Fhost%2Ff80a74eb2efcb4eb95e07ca196bc2930689d4c5d542f130b2e97640579ff7904 alt=image width=400 height=355></li></ul><pre><code data-query={} data-lang>计算公式: Diffuse = kDiffuse × N • L × CBase\\n    Diffuse表示漫反射颜色\\n    KDiffuse表示入射光颜色\\n    N表示物体表面法线方向\\n    L表示入射光方向\\n    CBase表示物体本身颜色\\n</code></pre><ul><li>环境反射(Ambient reflection) 环境光照射的效果, 由各个方向入射再反射到各个方向 <img src=http://eux-blog-static.bj.bcebos.com/ambient-reflection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A07Z%2F-1%2Fhost%2F1a52158474134fd9130f6d2da5ce8a6374e1d5c47538e6bb929bde9355457154 alt=image width=400 height=299></li></ul><pre><code data-query={} data-lang>计算公式: Ambient = kAmbient × CBase\\n    Ambient表示环境反射颜色\\n    kAmbient表示入射光颜色\\n    CBase表示物体本身颜色\\n</code></pre><ul><li>镜面反射(specular reflection) 在镜面, 金属等表面光滑物体表面, 入射光大部分会从单一方向反射出去, 因此反射强度跟入射方向, 物体表面方向和观察方向都有关系</li></ul><pre><code data-query={} data-lang>计算公式: Specular = kSpecular × pow(max(R • V, 0), kSpecularPower)\\n    Specular表示镜面反射颜色\\n    kSpecular表示入射光颜色\\n    R = 2 × N × (N • L) – L\\n    N, L分别表示法线方向和入射光方向\\n    V表示观察方向\\n    kSpecularPower表示高光系数, 代表物体表面反射光的能力\\n</code></pre><p>环境反射和平行光的漫反射可以在顶点着色器阶段计算, 因为不考虑光的方向或入射光方向一致;</p><p>聚光灯的漫反射和镜面反射效果需要在片段着色器阶段计算, 因为照射到物体表面的每个点光线方向不同(聚光灯漫反射)或对于每个点观察方向都不同(镜面反射)</p><p>物体表面某点的颜色 = 漫反射颜色 + 环境反射颜色 + 镜面反射颜色 (也可以没有镜面反射)</p><pre><code data-query={} data-lang>影响物体材质的因素:\\n    物体本身颜色(CBase)\\n    入射光颜色(kDiffuse, kAmbient, kSpecular)\\n    法线方向(N)\\n    入射方向(L)\\n    观察方向(V)\\n    高光系数(kSpecularPower)\\n</code></pre><h2 id=纹理贴图><a href=#%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>纹理贴图</h2><h3 id=贴图类型><a href=#%E8%B4%B4%E5%9B%BE%E7%B1%BB%E5%9E%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>贴图类型</h3><ul><li>色彩贴图: 将贴图的数据赋值给物体的本身颜色 <img src=http://eux-blog-static.bj.bcebos.com/basic-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A40Z%2F-1%2Fhost%2Fbf711f75e879569daeed43eaa4ee8b1e5c1d67619a9c24dec09e2ee99c0af420 alt=image width=400 height=391></li><li>法线贴图: 将贴图数据复制给法线N <img src=http://eux-blog-static.bj.bcebos.com/normal-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A58Z%2F-1%2Fhost%2F7ae0742678271df02115bb1bed9cde4a0ec84a10992490ff62939096a3b00607 alt=image width=400 height=389></li><li>高光贴图 类似法线贴图, 将贴图数据赋值给高光系数</li><li>凹凸贴图 类似法线贴图, 不过存储的是物体表面的相对高度, 也是通过高度参数影响原始的法线方向达到凹凸效果; 效果不如法线贴图</li><li>光照贴图: 模拟阴影效果 <img src=http://eux-blog-static.bj.bcebos.com/light-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A15Z%2F-1%2Fhost%2F1b9a02ff6794da9dd29226cf09d82460406c92f4e44cfca532b22646e89df7a2 alt=image width=400 height=389></li><li>环境贴图: 模拟物体的反光效果 <img src=http://eux-blog-static.bj.bcebos.com/env-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A29Z%2F-1%2Fhost%2Fe5935a030290a63bf27bed062175a75736021b35e1eef600b09dc99ef8ccb5fb alt=image width=400 height=313></li><li>立方环境贴图: 用六张图组成一个立方体, 将物体置于立方体中, 模拟全景效果 <img src=http://eux-blog-static.bj.bcebos.com/cube-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A52Z%2F-1%2Fhost%2F874ffa6f6b2d34c6885669db7c4cac62332c801971ce4d81d5a1a3ba4a824c2e alt=image width=400 height=272></li><li>... ...</li></ul><h3 id=uv贴图><a href=#uv%E8%B4%B4%E5%9B%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>UV贴图</h3><p>uv指2d图形的坐标名称, 在贴图时可以指定一个矩形的坐标; 可以指定放大缩小模式; 重复(repeat)模式等高级操作</p><img src=http://eux-blog-static.bj.bcebos.com/uv-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A24%3A13Z%2F-1%2Fhost%2F3b13b17cc4204b26de85a9a12cd7f12b6c2c86dba02917220347802746117431 alt=image width=700 height=437><p>[The uv coordinates are often used. However, we are using st coordinates because GLSL ES uses the component names to access the texture image.]</p><h2 id=webgl初始化流程及代码><a href=#webgl%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%BB%A3%E7%A0%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>webGL初始化流程及代码</h2><ul><li><p>获取webgl上下文</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> canvas = <span class=hljs-built_in>document</span>.querySelector(<span class=hljs-string>'#canvas'</span>);\\ngl = canvas.getContext(<span class=hljs-string>'webgl'</span>);</code></pre></li><li><p>初始化视窗(viewport)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>gl.viewportWidth = canvas.width;\\ngl.viewportHeight = canvas.height;\\ngl.viewport(<span class=hljs-number>0</span>, <span class=hljs-number>0</span>, gl.viewportWidth, gl.viewportHeight);</code></pre></li><li><p>初始化顶点着色器(vertex shader)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> vertexShader = gl.createShader(gl.VERTEX_SHADER);\\n<span class=hljs-comment>// 这一步一般需要先load着色器源代码</span>\\ngl.shaderSource(vertexShader, <span class=hljs-string>'attribute vec4 a_Position ......  // 顶点着色器内容'</span>);\\ngl.compileShader(vertexShader);\\n<span class=hljs-comment>// 获取着色器编译状态, 如果出错则打印log信息并结束</span>\\n<span class=hljs-keyword>if</span> (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\\n        <span class=hljs-built_in>console</span>.log(gl.getShaderInfoLog(vertexShader));\\n        <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>初始化片段着色器(fragment shader)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\\ngl.shaderSource(fragmentShader, <span class=hljs-string>'varying vec4 v_Color ......  //片段着色器内容'</span>);\\ngl.compileShader(fragmentShader);\\n<span class=hljs-keyword>if</span> (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\\n        <span class=hljs-built_in>console</span>.log(gl.getShaderInfoLog(fragmentShader));\\n        <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>初始化程序(program)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>gl.program = gl.createProgram();\\n<span class=hljs-comment>// 绑定着色器, 不同的'程序'可以绑定不同的着色器</span>\\ngl.attachShader(gl.program, vertexShader);\\ngl.attachShader(gl.program, fragmentShader);\\n<span class=hljs-comment>// 链接程序</span>\\ngl.linkProgram(gl.program);\\n<span class=hljs-comment>// 检查程序链接状态</span>\\n<span class=hljs-keyword>if</span> (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {\\n         <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'program link problem'</span>);\\n         <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>使用程序(program)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 使用刚刚初始化好的程序, 可以创建多个program来使用</span>\\ngl.useProgram(gl.program);</code></pre></li><li><p>初始化顶点数组(vertex buffer)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * initVertexBuffers: vertices, indices => n\\n *     vertices: Float32Array    // 顶点数组,一般需要是有类型的特殊Array\\n *     indices: Uint8Array       // 序号数组, 序号指顶点数组中的序号index\\n *     n: number                 // 顶点数, indices.length\\n */</span>            \\ngl.n = initVertexBuffers(vertices, indices);\\n<span class=hljs-keyword>if</span> (gl.n &lt;= <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to initialize vertex buffers&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><ul><li><p>vertices &amp indices</p><p>表示顶点数组和序号数组, 如一个正方体的顶点数组</p><img src=http://eux-blog-static.bj.bcebos.com/cube-coordinate.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A25%3A04Z%2F-1%2Fhost%2F12b107edecdaa381bf201d0bfbefbaba4e9fe095b72d4f17077f4f792860a1af alt=image width=400 height=379> ```javascript /** * vertices数组, 前三个数字代表一个三维空间坐标点, 后三个数字代表颜色 * 下面例子里列出的内容表示一个正方体的正面(front)的坐标点 **/ var vertices = new Float32Array([ 1.0, 1.0, 1.0, 0.0, 0.0, -1.0, // v0 -1.0, 1.0, 1.0, 0.0, 0.0, -1.0, // v1 -1.0, -1.0, 1.0, 0.0, 0.0, -1.0, // v2 1.0, -1.0, 1.0, 0.0, 0.0, -1.0, // v3 front ... ... ]), ```<pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * indices数组, 0,1,2  0,2,3分别表示一个三角形, 两个三角形组成正方体的一个面\\n * 三角形点的顺序要逆时针列出(右手定则), 顺序不对的话会被当成背对屏幕而不被渲染\\n **/</span>     \\n<span class=hljs-keyword>var</span> indices = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Uint8Array</span>([\\n    <span class=hljs-number>0</span>, <span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>0</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>,           <span class=hljs-comment>// front</span>\\n    <span class=hljs-number>4</span>, <span class=hljs-number>5</span>, <span class=hljs-number>6</span>, <span class=hljs-number>4</span>, <span class=hljs-number>6</span>, <span class=hljs-number>7</span>,           <span class=hljs-comment>// right</span>\\n    <span class=hljs-number>8</span>, <span class=hljs-number>9</span>, <span class=hljs-number>10</span>, <span class=hljs-number>8</span>, <span class=hljs-number>10</span>, <span class=hljs-number>11</span>,        <span class=hljs-comment>// up</span>\\n    <span class=hljs-number>12</span>, <span class=hljs-number>13</span>, <span class=hljs-number>14</span>, <span class=hljs-number>12</span>, <span class=hljs-number>14</span>, <span class=hljs-number>15</span>,     <span class=hljs-comment>// left</span>\\n    <span class=hljs-number>16</span>, <span class=hljs-number>17</span>, <span class=hljs-number>18</span>, <span class=hljs-number>16</span>, <span class=hljs-number>18</span>, <span class=hljs-number>19</span>,     <span class=hljs-comment>// down</span>\\n    <span class=hljs-number>20</span>, <span class=hljs-number>21</span>, <span class=hljs-number>22</span>, <span class=hljs-number>20</span>, <span class=hljs-number>22</span>, <span class=hljs-number>23</span>      <span class=hljs-comment>// back              </span>\\n])</code></pre></li><li><p>initVertexBuffers</p><ul><li><p>初始化buffer</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> vertexBuffer = gl.createBuffer();\\n<span class=hljs-keyword>var</span> indexBuffer = gl.createBuffer();\\n<span class=hljs-keyword>if</span> (!vertexBuffer || !indexBuffer) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to create buffer&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre></li><li><p>绑定buffer</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 绑定vertexBuffer并填入值vertices</span>\\n<span class=hljs-comment>// 注意!! 顶点的原始数据必须用gl.ARRAY_BUFFER存储</span>\\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\\ngl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 绑定indexBuffer并填入值indices</span>\\n<span class=hljs-comment>// 注意!! 顶点的index必须用gl.ELEMENT_ARRAY_BUFFER存储</span>\\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);</code></pre></li><li><p>初始化Attributes</p><ul><li><p>定义attributes数组</p><pre><code data-query={} data-lang>attributes是vertices数组的结构定义, 必须跟vertices数组对应起来\\n\\n- vertices结构\\n\\n    &lt;img src=\\\"http://eux-blog-static.bj.bcebos.com/vertex-object-structure.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A25%3A28Z%2F-1%2Fhost%2F1359f6ce7d9adf4c7a93cd950c25d3126d6cc3d9a5a1959bd8e7c2cfbe708749\\\" alt=\\\"image\\\" width=\\\"550\\\" height=\\\"94\\\" />\\n    \\n    如图vertices数组中10个数字表示一个顶点, 分别表示坐标位置; 法向量方向; 贴图TEX0的坐标位置; 贴图TEX1的坐标位置\\n\\n    这种vertices结构叫*Array of structure*, 通常用3D软件生成的顶点数据都是这个结构;也可以为position, normal, color每种数据都建立一个buffer, 这种结构叫*Structure of Array*\\n\\n    ```javascript\\n    /**\\n     * 根据上面的结构定义的attributes\\n     * size表示当前attribute由几个元素组成, 范围大小是1~4\\n     * strip表示由几个元素代表一个顶点, 每个attribute都相同\\n     * offset表示从第几个元素开始查找, 这个要算之前的attribute占用了多少元素\\n     **/\\n    var attributes = [\\n        {name: &amp#039;a_position&amp#039;, size: 3, strip: 10, offset: 0},\\n        {name: &amp#039;a_normal&amp#039;, size: 3, strip: 10, offset: 3},\\n        {name: &amp#039;a_tex0&amp#039;, size: 2, strip: 10, offset: 6},\\n        {name: &amp#039;a_tex1&amp#039;, size: 2, strip: 10, offset: 8}\\n    ];\\n    ```\\n\\n```javascript\\n// 根据正方体vertices数组定义的attributes结构\\nvar attributes = [\\n    {name: &amp#039;a_position&amp#039;, size: 3, strip: 10, offset: 0},\\n    {name: &amp#039;a_color&amp#039;, size: 3, strip: 10, offset: 3}\\n];\\n```\\n</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 记录FSIZE, 即顶点数组每个元素的byte数, 后面需要使用</span>\\ngl.FSIZE = vertices.BYTES_PER_ELEMENT;\\n<span class=hljs-comment>// 遍历attributes并初始化</span>\\n<span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; attributes.length; i++) {\\n    initAttributes(attributes[i]);\\n}</code></pre></li><li><p>initAttributes</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 为attribute分配存储空间</span>\\n<span class=hljs-keyword>var</span> a_Loc = gl.getAttribLocation(gl.program, attribute.name);\\n<span class=hljs-comment>// a_Loc是分配的存储空间地址, 如果小于0表示分配失败</span>\\n<span class=hljs-keyword>if</span> (a_Loc &lt; <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to get location <span class=hljs-keyword>of</span>&amp#<span class=hljs-number>039</span>; + attr.name);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 定义attribute查找规则</span>\\ngl.vertexAttribPointer(\\n    a_Loc,\\n    attribute.size,    <span class=hljs-comment>// 3</span>\\n    gl.FLOAT,          <span class=hljs-comment>// 数据类型</span>\\n    <span class=hljs-literal>false</span>,             <span class=hljs-comment>// 实际类型跟FLOAT不符时的处理, 这里符合所以false</span>\\n    gl.FSIZE * attribute.strip,    <span class=hljs-comment>// 4 * 6</span>\\n    gl.FSIZE * attribute.offset   <span class=hljs-comment>// 4 * (0 | 3)</span>\\n);\\n<span class=hljs-comment>// enable分配的存储位置</span>\\ngl.enableVertexAttribArray(a_Loc);</code></pre></li><li><p>初始化Uniforms</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 定义uniforms数组: 变量名, 类型, 地址, 值</span>\\n<span class=hljs-keyword>var</span> uniforms = [\\n    {<span class=hljs-attr>name</span>: &amp#<span class=hljs-number>039</span>;u_b_direct_light&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>type</span>: &amp#<span class=hljs-number>039</span>;b&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>location</span>: <span class=hljs-literal>null</span>, <span class=hljs-attr>value</span>: <span class=hljs-literal>null</span>},\\n    {<span class=hljs-attr>name</span>: &amp#<span class=hljs-number>039</span>;u_MvpMatrix&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>type</span>: &amp#<span class=hljs-number>039</span>;mat4&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>location</span>: <span class=hljs-literal>null</span>, <span class=hljs-attr>value</span>: <span class=hljs-literal>null</span>},\\n    {<span class=hljs-attr>name</span>: &amp#<span class=hljs-number>039</span>;u_MvMatrix&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>type</span>: &amp#<span class=hljs-number>039</span>;mat4&amp#<span class=hljs-number>039</span>;, <span class=hljs-attr>location</span>: <span class=hljs-literal>null</span>, <span class=hljs-attr>value</span>: <span class=hljs-literal>null</span>},\\n    <span class=hljs-comment>// ... ...</span>\\n]</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 遍历uniforms并初始化</span>\\n<span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; uniforms.length; i++) {\\n    initUniforms(uniforms[i]);\\n}</code></pre><ul><li><p>initUniforms</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 分配uniform存储空间</span>\\n<span class=hljs-keyword>var</span> u_Loc = gl.getUniformLocation(gl.program, uniform.name);\\n<span class=hljs-keyword>if</span> (u_Loc &lt; <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to get location <span class=hljs-keyword>of</span> u_MvpMatrix&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}\\n<span class=hljs-keyword>else</span> {\\n    uniform.location = u_Loc;\\n}</code></pre></li><li><p>updateUniforms</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 给uniform赋值, 不同的类型对应不同的方法\\n * 其中f表示float, i表示integer, v表示vector; 一般matrix和vector都是数组\\n * gl.uniformxxxx的第一个参数是之前缓存的uniform地址\\n * 第二个参数表示是否需要转置矩阵(横竖反转), webGL里不具有这个功能, 必须传false\\n * 第三个参数是uniform值, 可以是数组或单个数字, 数字可以是float或inter类型\\n * 具体内容需要跟前面的api对应起来\\n **/</span>\\n<span class=hljs-keyword>if</span> (uniform.value) {\\n    <span class=hljs-keyword>try</span> {\\n        <span class=hljs-keyword>switch</span> (uniform.type) {\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;mat4&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformMatrix4fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;mat3&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformMatrix3fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;vec4&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformVec4fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;vec3&amp#<span class=hljs-number>039</span>;:\\n                gl.uniformVec3fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;f&amp#<span class=hljs-number>039</span>;:\\n                <span class=hljs-keyword>if</span> (uniform.value.length) {\\n                    gl.uniform1fv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>else</span> {\\n                    gl.uniform1f(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>break</span>;\\n            <span class=hljs-keyword>case</span> &amp#<span class=hljs-number>039</span>;i&amp#<span class=hljs-number>039</span>;:\\n                <span class=hljs-keyword>if</span> (uniform.value.length) {\\n                    gl.uniform1iv(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>else</span> {\\n                    gl.uniform1i(uniform.location, <span class=hljs-literal>false</span>, uniform.value);\\n                }\\n                <span class=hljs-keyword>break</span>;\\n        }\\n    }\\n}</code></pre></li></ul></li></ul></li></ul></li></ul></li><li><p>初始化纹理(texture)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 如果需要使用纹理</span>\\n<span class=hljs-keyword>if</span> (!initTextures(imageSrc)) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to initialize texture&amp#<span class=hljs-number>039</span>;);\\n}</code></pre><ul><li><p>initTextures</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 创建texture</span>\\n<span class=hljs-keyword>var</span> texture = gl.createTexture();\\n<span class=hljs-keyword>if</span> (!texture) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to create texture&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 为u_Sampler分配空间, texture会是u_Sampler的值</span>\\n<span class=hljs-keyword>var</span> u_Sampler = gl.getUniformLocation(gl.program, &amp#<span class=hljs-number>039</span>;u_Sampler&amp#<span class=hljs-number>039</span>;);\\n<span class=hljs-keyword>if</span> (u_Sampler &lt; <span class=hljs-number>0</span>) {\\n    <span class=hljs-built_in>console</span>.log(&amp#<span class=hljs-number>039</span>;fail to get location <span class=hljs-keyword>of</span> u_Sampler&amp#<span class=hljs-number>039</span>;);\\n    <span class=hljs-keyword>return</span>;\\n}</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 加载图片并loadTexture</span>\\n<span class=hljs-keyword>var</span> image = <span class=hljs-keyword>new</span> Image();\\nimage.src = <span class=hljs-built_in>require</span>(imageSrc);\\nimage.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    loadTexture(texture, u_Sampler, image);\\n};</code></pre><ul><li><p>loadTexture</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 翻转图片的Y坐标; 1表示enable前面的配置项\\n * 因为贴图的uv(或st)坐标系跟html的xy坐标系, y轴方向正好相反\\n * 所以之后要使用贴图的uv坐标通常需要这步操作\\n **/</span>\\ngl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, <span class=hljs-number>1</span>);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 一个program最多可以使用8个贴图, 从gl.TEXTURE0 到 gl.TEXTURE7\\n * 这里只用了一个所以只active TEXTURE0\\n **/</span>\\ngl.activeTexture(gl.TEXTURE0);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 绑定texture, 这一步是要告诉webGL texture的类型\\n * 除了立方体贴图要用gl.TEXTURE_CUBE_MAP, 其它的基本都用gl.TEXTURE_2D\\n **/</span>\\ngl.bindTexture(gl.TEXTURE_2D, texture);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 这一步设置应用贴图时的参数, 第一个参数指定贴图类型(2d或cude)\\n * 后面两个参数分别是贴图处理方法(funcName)和对应的值(funcValue)\\n * 后面详细介绍\\n **/</span>\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);</code></pre><ul><li><p>texPrameter - funcName</p><pre><code data-query={} data-lang>gl.TEXTURE_MAG_FILTER: 放大策略; 当贴图大小比目标区域小的时候的放大策略, 可以使用gl.NEAREST和gl.LINEAR两个值\\n\\ngl.TEXTURE_MIN_FILTER: 缩小策略: 当贴图大小比目标区域大时的缩小策略, 可以使用gl.NEAREST和gl.LINEAR及MIPMAP的所有值\\n\\ngl.TEXTURE_WRAP_S: s轴(横轴)填充策略: 可以使用REPEAT, MIRRORED_REPEAT, CLAMP_TO_EDGE三种策略, 默认REPEAT\\n\\ngl.TEXTURE_WRAP_T: t轴(纵轴)填充策略: 可以使用REPEAT, MIRRORED_REPEAT, CLAMP_TO_EDGE三种策略, 默认REPEAT\\n</code></pre></li><li><p>texPrameter - funcValue</p><pre><code data-query={} data-lang>```\\ngl.NEAREST: 取与目标像素几何距离最近的点\\n\\ngl.LINEAR: 取与目标像素距离最近的四个点做权重平均(or bilinear fetch); 一般比NEAREST更清晰, 但更花时间\\n\\nMIPMAP ———— 把贴图标准化为类似16x16, 32x32, 64x64等一系列图片, 然后根据目标区域大小选取相应的图片处理; 使用MIPMAP的话后面需要手工加载不同级别的图片\\n\\n    gl.NEAREST_MIPMAP_NEAREST: 取一个跟目标区域最相近的图片, 然后再用NEAREST选一个最近的点\\n\\n    gl.LINEAR_MIPMAP_NEAREST: 取一个跟目标区域最相近的图片, 然后再用LINEAR的方式算出点\\n\\n    gl.NEAREST_MIPMAP_LINEAR: 取跟目标区域大小最相近的较大较小两个图片, 然后做插值算出点\\n\\n    gl.LINEAR_MIPMAP_LINEAR: 先取最相近的两个图片分别做LINEAR(bilinear fetch)算出两个点, 然后再做插值算出目标点; 这种方式叫: trilinear filtering, 是所有方式中质量最高的\\n\\ngl.REPEAT: 复制\\n\\ngl.MIRRORED_REPEAT: 镜像复制\\n\\ngl.CLAMP_TO_EDGE: 用贴图的边缘颜色填充\\n```\\n</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**</span></code></pre></li></ul><ul><li><p>将图片绑定到texture对象上, 第一个参数指定贴图类型(2d或cube)</p></li><li><p>第二个参数指定MIPMAP级别, 不使用时默认传0, 如果使用MIPMAP则需要绑定0~n不同级别的图片</p></li><li><p>第三个参数指定图片像素的数据类型, 有RGB, RGBA, ALPHA, LUMINANCE, LUMINANCE_ALPHA几种</p></li><li><p>第四个参数指定贴图像素被使用时的数据类型, 需要跟第三个参数保持相同</p></li><li><p>第五个参数指定贴图像素的数据类型, 有</p></li><li><p>UNSIGNED_BYTE: 每个部分占1byte</p></li><li><p>UNSIGNED_SHORT_5_6_5: RGB类型且分别占5,6,5 bits</p></li><li><p>UNSIGNED_SHORT_4_4_4_4: RGBA类型且分别占4bits</p></li><li><p>UNSIGNED_SHORT_5_5_5_1: RGBA类型前三个占4bits, 最后alpha占1bits</p></li><li><p>最后一个参数是加载的image对象 **/ gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);</p><pre><code data-query={} data-lang>```javascript\\n/**\\n</code></pre></li><li><p>给之前分配空间的uniform: u_Sampler赋值</p></li><li><p>这一步跟普通的uniform赋值一样, 只是后面的0对应gl.TEXTURE0</p></li><li><p>如果之前绑定的是TEXTUREn这里需要传n</p></li><li><p>在片段着色器中的声明方式:</p></li><li><p>uniform sampler2D u_Sampler;</p></li><li><p>如果是立方体贴图需要把sampler2D改成samplerCube **/ gl.uniform1i(u_Sampler, 0);</p><pre><code data-query={} data-lang></code></pre></li></ul></li></ul></li></ul></li><li><p>开启深度检测(depth test)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 一般需要开启深度检测</span>\\ngl.enable(gl.DEPTH_TEST);</code></pre></li><li><p>开启其它可选的后处理</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>gl.enable(gl.BLEND);\\ngl.enable(gl.STENCIL_TEST);\\n<span class=hljs-comment>// ... ...</span>\\n<span class=hljs-comment>// 除了enable之外一般还需要设置其它相关参数和方法, 如</span>\\n<span class=hljs-comment>// gl.blendFunc(... ....);</span>\\n<span class=hljs-comment>// gl.stencilFunc(... ....);</span></code></pre></li><li><p>初始化颜色及buffer</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 清空颜色</span>\\ngl.clearColor(<span class=hljs-number>0.0</span>, <span class=hljs-number>0.0</span>, <span class=hljs-number>0.0</span>, <span class=hljs-number>1.0</span>);</code></pre><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 清空buffer, 如果使用了stencilTest, 需要清空 gl.STENCIL_BUFFER_BIT</span>\\ngl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</code></pre></li></ul><h2 id=webgl渲染流程及代码><a href=#webgl%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%BB%A3%E7%A0%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>webGL渲染流程及代码</h2><ul><li><p>跟进用户交互及时间等参数更新uniform值 (参考updateUniforms)</p></li><li><p>清空buffer (参考初始化颜色及buffer)</p></li><li><p>绘制图形</p><ul><li><p>drawElements: 使用的是之前初始化的indexBuffer (参考绑定vertexBuffer)</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>/**\\n * 第一个参数表示绘制的图元mode, 后面有详细介绍\\n * 第二个参数表示需要绘制的顶点序号数量, 这里绘制全部所以是gl.n\\n * 第三个参数表示存储的顶点序号的数据类型, 有gl.UNSIGNED_BYTE | gl.UNSIGNED_SHORT两种\\n * 对应js里Uint8Array | Uint16Array两种数据定义\\n * 第四个参数是offset, 从indexBuffer的第几个元素开始绘制\\n **/</span>\\ngl.drawElements(gl.TRIANGLES, gl.n, gl.UNSIGNED_BYTE, <span class=hljs-number>0</span>);        </code></pre></li><li><p>drawArrays: 使用的是之前初始化的vertexBuffer, 即顶点原始数据 (参考绑定indexBuffer)</p><pre><code data-query={} data-lang>```javascript\\n/**\\n * 第一个参数表示绘制的图元mode, 后面有详细介绍\\n * 第二个参数是offset, 从vertexBuffer的第几个元素开始绘制\\n * 第三个参数表示需要绘制的顶点序号数量\\n **/\\ngl.drawArrays(gl.TRIANGLE_STRIP, 0, gl.n);\\n```\\n</code></pre><p>drawArrays跟drawElement不同的是它只能顺序的使用vertexBuffer的顶点, 不能指定序号;</p><p>因为3D建模工具导出的数据一般都会有顶点的复用, 不能顺序使用, 所以一般复杂模型都会使用indexBuffer绘制</p></li><li><p>draw mode:</p><img src=http://eux-blog-static.bj.bcebos.com/draw-mode.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A26%3A27Z%2F-1%2Fhost%2Fbc9d30732869b61a5375c171fd63875c2bce7e65fa6ea3f522bb434408aeec56 alt=image width=700 height=424><pre><code data-query={} data-lang>gl.POINTS: 根据使用的是vertexBuffer还是indexBuffer, 顺序的画点\\n\\ngl.LINES: 以v0-v1, v2-v3, v4-v5,的顺序画线\\n\\ngl.LINE_STRIP: 以v0-v1-v2-v3-v4-v5的顺序画整条线\\n\\ngl.LINE_LOOP: 以v0-v1-v2-v3-v4-v5-v0的顺序连接起点和终点\\n\\ngl.TRIANGLES: 以v0-v1-v2, v3-v4-v5的顺序画三角形\\n\\ngl.TRIANGLES_STRIP: 以v0-v1-v2, v2-v1-v3, v2-v3-v4, v4-v3-v5的顺序画连续的三角形\\n\\ngl.TRIANGLES_FAN: 以v0-v1-v2, v0-v2-v3, v0-v3-v4, v0-v4-v5的顺序画扇形的三角形\\n</code></pre></li></ul></li></ul><h2 id=一些后续学习内容><a href=#%E4%B8%80%E4%BA%9B%E5%90%8E%E7%BB%AD%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>一些后续学习内容:</h2><ul><li>理解和灵活运用 (坐标变换 &amp图形变换) 部分的矩阵变换公式和api</li><li>(光照 &amp材质) 相关的高级光照效果</li><li>(纹理贴图) 相关的高级贴图效果及uv贴图应用</li><li>顶点着色器和片段着色器的使用, <a href=https://www.shadertoy.com/>shadertoy</a> 上有大量着色器可以参考</li><li>一些高级效果, 如阴影, 反射, 雾, 使用多个gl program, 用户键盘及鼠标交互, 动画及骨架原理等等... ...</li><li>如何转换并使用3d建模工具(如blender)导出的模型相关数据</li></ul><h2 id=参考资料><a href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>参考资料:</h2><ul><li>WebGL Programming Guide (webGL编程指南)</li><li>OpenGL ES 2.0 Programming Guide (OpenGL ES 2.0编程指南)</li><li><a href=https://threejs.org/>threejs</a> 例子, 教程, 源码学习</li></ul>\",\n  \"extra\": {\n    \"_image-loader_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./doc/fe/832.md\n// module id = 799\n// module chunks = 55"],"sourceRoot":""}