{"version":3,"sources":["webpack:///blog/fe/Chrome的First Paint.js","webpack:///./doc/fe/Chrome的First Paint.md"],"names":["webpackJsonp","800","module","exports","content","extra","_image-loader_"],"mappings":"AAAAA,cAAc,GAAG,KAEXC,IACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,0rgBACAC,OACAC","file":"blog/fe/Chrome的First Paint.js","sourcesContent":["webpackJsonp([54,56],{\n\n/***/ 800:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<h2 id=前言><a href=#%E5%89%8D%E8%A8%80 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>前言</h2><blockquote><p>First paint 直译过来的意思就是浏览器第一次渲染(paint)，在First paint之前是白屏，在这个时间点之后用户就能看到（部分）页面内容。</p></blockquote><p>所以研究这个First Paint的触发时机对于优化浏览器页面的首屏渲染时间有很重要的作用。</p><p>在正题开始之前，先说下浏览器的页面的加载流程（大体过程是这样，并不精确，只是为了帮助理解后面内容）：</p><ol><li>浏览器输入url，浏览器发送请求到服务器，服务器将请求的HTML返回给浏览器。</li><li>浏览器下载完成HTML(Finish Loading HTML)之后，便开始从上到下解析。</li><li><p>解析的过程中碰到css和js外链（其实HTML的下载也是这个流程）都会执行以下过程：</p><ol><li><strong><code>Send Request</code>:表示给这个外链对应的服务器发送请求</strong></li><li><strong><code>Receive Response</code>: 表示接收响应，这里是表示告诉浏览器可以开始从网络接收数据了</strong></li><li><strong><code>Receive Data</code>:表示开始接收数据</strong></li><li><strong><code>Finish Loading</code>: 表示已经完成下载数据。</strong></li><li><strong><code>Parse Stylesheet/Evaluate</code>（默认情况下js下载完成之后执行<code>Evaluate</code>，css下载完成后会进行<code>Parse Stylesheet</code>）</strong></li></ol></li><li>所有的css下载完成后<code>Parse Stylesheet</code>然后开始构建CSSOM</li><li>DOM（文档对象模型）和 CSSOM（CSS对象模型）会合并生成一个渲染树(<code>Render Tree</code>)</li><li>根据渲染树的内容计算处各个节点在网页中的大小和位置（<code>Layout</code>，可以理解为“刻章”）</li><li>根据Layout绘制内容在浏览器上（<code>Paint</code>，可以理解为“盖章”）。</li></ol><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-1.jpg></p><h2 id=正题开始><a href=#%E6%AD%A3%E9%A2%98%E5%BC%80%E5%A7%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>正题开始</h2><p>在最新版的Chrome的<code>perfomance</code>中是能直接看到First Paint这个时间点的，为了方便大家测试，我就直接拿谷歌这个示例页面来做演示:</p><p><a href=https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/measure_crp_timing.html>测试页面</a></p><p>用chrome打开上面链接，最好是隐身模式，防止插件乱入影响判断，按F12或者右键检查元素打开控制台先切换到<code>Network</code>选项,勾选禁用缓存(缓存也会影响到判断)：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F1.png alt=1></p><p>切换到<code>Perfomance</code>，勾选<code>Screenshots</code>并点击红框进行页面分析（会自动停止的，不用点stop）：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-2.jpg></p><p>分析完后可以看到如下结果：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2.png></p><p>上图中的绿色的线就是当前页面第一次出现内容的时间点，可以将鼠标放到<code>Main</code>上面的<code>Network</code>中绿色的线附近可以看到在他之前页面空白，在他之后就有内容。 除了绿色的线还有蓝色以及红色的线，这里也解释一下：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-4.jpg></p><p>简单讲一下<code>DOMContentLoaded</code>、<code>load</code>的区别：</p><ol><li><code>DOMContentLoaded</code>是HTML文档（包括CSS、JS）被加载以及解析完成之后触发（即 <code>HTML->DOM</code>的过程完成 ）</li><li><code>load</code>则是在页面的其他资源如图片、字体、音频、视频加载完成之后触发</li><li><code>load</code>事件一般在<code>DOMContentLoaded</code>之后才触发（也有可能在它之前哦）</li></ol><p>这个时候发现绿色虚线之前有一个浅绿色方块，相应的解释如下：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-5.jpg></p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-6.jpg></p><p>由图可以得出“浅绿色”代表的是<strong>根据CSSOM计算样式并进行布局绘制</strong>的过程，这段时间内浏览器做了一下事情：</p><ol><li><code>Recalculate Style</code>:重新计算样式，确定DOM元素的样式规则（定规则）</li><li><code>Layout</code>:根据计算结果进行布局，确定元素的大小和位置（刻章）</li><li><code>Update Layer Tree</code>: 更新渲染层树</li><li><code>Paint</code>: 绘制，根据前面的Layer Tree绘制页面（位置、大小、颜色、边框、阴影等）（盖章）</li><li><code>Composite Layers</code>： 形成层，浏览器按照合理的顺序合并成一个图层然后输出到屏幕（给别人看）</li></ol><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-8.jpg></p><p>那什么时候开始<code>First paint</code>呢?在浅绿色方块最前面的虚线往前看，发现在灰色虚线之前都会有一个步骤：就是<code>Parse Stylesheet</code>（调研了很多页面都是如此）</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-9.jpg></p><p>所以，First Paint的加载流程应该是这样：</p><ol><li><strong>所有的CSS加载完成</strong></li><li><strong><code>Parse Stylesheet</code>：构建出CSSOM</strong></li><li><strong><code>Recalculate Style</code>：重新计算样式，确定DOM元素的样式规则（定规则）</strong></li><li><strong><code>Layout</code>：根据计算结果进行布局，确定元素的大小和位置（刻章）</strong></li><li><strong><code>Update Layer Tree</code>：更新渲染层树</strong></li><li><strong><code>Paint</code>：绘制，根据前面的Layer Tree绘制页面（位置、大小、颜色、边框、阴影等）（盖章）</strong></li><li><strong><code>Composite Layers</code>：形成层，浏览器按照合理的顺序合并成一个图层然后输出到屏幕（给别人看）</strong></li></ol><p>但是现在还只是确定了<code>First Paint</code>的加载流程，也确定了他是在所有CSS执行完<code>Parse Stylesheet</code>之后才会触发，但是这还是不够准确啊，所以我找了一些CSS和JS的外链来测试，模板如下：</p><pre><code class=\\\"hljs language-html\\\"data-query={} data-lang=html><span class=hljs-meta>&lt;!DOCTYPE html></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>html</span> <span class=hljs-attr>lang</span>=<span class=hljs-string>\\\"en\\\"</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>head</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>meta</span> <span class=hljs-attr>charset</span>=<span class=hljs-string>\\\"UTF-8\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>meta</span> <span class=hljs-attr>name</span>=<span class=hljs-string>\\\"viewport\\\"</span> <span class=hljs-attr>content</span>=<span class=hljs-string>\\\"width=device-width, initial-scale=1.0\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>meta</span> <span class=hljs-attr>http-equiv</span>=<span class=hljs-string>\\\"X-UA-Compatible\\\"</span> <span class=hljs-attr>content</span>=<span class=hljs-string>\\\"ie=edge\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>title</span>></span>Document<span class=hljs-tag>&lt;/<span class=hljs-name>title</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>href</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.css\\\"</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>\\\"stylesheet\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>href</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.css\\\"</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>\\\"stylesheet\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/vue/2.5.13/vue.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/react/16.4.0-alpha.0911da3/cjs/react.development.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/angular.js/2.0.0-beta.17/angular2.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n<span class=hljs-tag>&lt;/<span class=hljs-name>head</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>body</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>'root1'</span>></span>\\n        1\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>'root2'</span>></span>\\n        2\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>'root3'</span>></span>\\n        3\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>\\n<span class=hljs-tag>&lt;/<span class=hljs-name>body</span>></span>\\n<span class=hljs-tag>&lt;/<span class=hljs-name>html</span>></span></code></pre><p>我们通过改变上面模板里的外链顺序来探究：</p><h3 id=第一种情况：><a href=#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第一种情况：</h3><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F1%2FSnipaste_2018-04-23_19-29-12.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F1%2FSnipaste_2018-04-23_19-31-12.png></p><p>发现FP发生在最后（实心的蓝色线是按<code>shift</code>出来的，不是<code>DOMContentLoaded</code>）,现在还发现不了什么。</p><h3 id=第二种情况：><a href=#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第二种情况：</h3><p>调换<code>head</code>中CSS和JS外链位置</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F2%2FSnipaste_2018-04-23_19-31-59.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F2%2FSnipaste_2018-04-23_19-33-03.png></p><p>仍然发现不了什么</p><h3 id=第三种情况><a href=#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第三种情况</h3><p>把CSS放<code>head</code>，JS放<code>&lt;/body></code>前</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F3%2FSnipaste_2018-04-23_19-31-59.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F3%2FSnipaste_2018-04-23_19-38-26.png></p><p>发现<code>FP</code>竟然在蓝色和红色虚线前面出现，通过这点可以确定，<code>FP</code>还跟JS外链的位置有关，继续:</p><h3 id=第四种情况：><a href=#%E7%AC%AC%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第四种情况：</h3><p>JS外链放<code>head</code>，CSS放<code>&lt;/body></code>前</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F4%2FSnipaste_2018-04-23_19-39-23.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F4%2FSnipaste_2018-04-23_19-39-52.png></p><p>发现又跟第一二种情况一样了，所以这种用法是不可取的。</p><h3 id=第五种情况：><a href=#%E7%AC%AC%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第五种情况：</h3><p>CSS和JS都放<code>&lt;/body></code>前，且CSS紧贴在<code>div</code>后面，JS在CSS后面：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F5%2FSnipaste_2018-04-23_19-40-18.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F5%2FSnipaste_2018-04-23_19-41-21.png></p><p>可以发现<code>FP</code>居然更快触发，<strong>但是我鼠标hover到绿色虚线后，仍然是白屏，只有等到CSS加载完成执行<code>Parse Stylesheet</code>之后才显示出内容</strong>（说明这种用法也不可取），难道body中的CSS也会影响？</p><h3 id=第六种情况：><a href=#%E7%AC%AC%E5%85%AD%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第六种情况：</h3><p>掉换一下上面CSS和JS的位置：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F6%2FSnipaste_2018-04-23_19-41-55.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F6%2FSnipaste_2018-04-23_19-42-29.png></p><p>发现这次<code>FP</code>触发而且立马有内容，而等到CSS加载完成之后还会再重新渲染一次，嗯，看来body中的第一个JS脚本有猫腻，接下来的情况对他特殊照顾。</p><h3 id=第七种情况：><a href=#%E7%AC%AC%E4%B8%83%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第七种情况：</h3><p>CSS放<code>head</code>中，JS放在<code>div</code>节点中间：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F7%2FSnipaste_2018-04-23_19-43-08.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F7%2FSnipaste_2018-04-23_19-43-49.png></p><p>哈哈，居然只渲染了12俩字，说明浏览器会渲染body中脚本之前的内容，那会是哪个脚本之前的内容呢？</p><h3 id=第八种情况：><a href=#%E7%AC%AC%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第八种情况：</h3><p>在div之间都插入脚本</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-07-03.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-06-52.jpg></p><p>看来浏览器会提前渲染<code>body</code>中第一个脚本前的内容（<code>我们就把body中的第一个外链脚本叫做【第一脚本】吧</code>），并且<strong>第一脚本</strong>还会在FP之后才执行。所以结合之前得出的结论，在CSSOM准备就绪之后，浏览器会提前渲染第一脚本前的内容，我们可以用第九种情况来验证：</p><h3 id=第九种情况：><a href=#%E7%AC%AC%E4%B9%9D%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第九种情况：</h3><p>这种情况和上种没什么区别，只是增加了一个CSS，这个CSS中还会发出一个请求去加载其他CSS（通过<code>@import url()</code>的方式），所以CSS的加载时间很长。</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-19-44.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-19-35.jpg></p><p>通过结果可以看出，123在CSS下载完成之后才渲染，而不是单独渲染一个1，所以<code>FP</code>必须得等到<code>CSSOM</code>准备就绪之后才会触发，否则即使有第一脚本在也没用。 所以到这里，我们总算可以下结论了：</p><blockquote><p><strong>FP发生在body中第一个script脚本之前的CSS解析和JS执行完成之后。换句话说就是第一脚本之前的<code>DOM</code>和<code>CSSOM</code>准备就绪之后，便会着手渲染第一脚本前的内容。</strong></p></blockquote><p>但是...你以为到这里就结束了？其实没有。</p><h3 id=第十种情况：><a href=#%E7%AC%AC%E5%8D%81%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第十种情况：</h3><p>这种情况中，<code>head</code>中既有JS也有CSS，<code>body</code>中也有第一脚本存在：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-34-55.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-35-11.jpg></p><p>注意上图中的<code>vue.js</code>是在<code>head</code>中的，而后面的JS文件都在<code>body</code>中，而且，<code>vue.js</code>加载完成之后，<code>body</code>中的JS还没下载完成，这个时候我们调换一下<code>vue.js</code>和<code>angular2.js</code>的位置：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-37-53.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-37-46.jpg></p><p>看，这个时候又没有提前渲染了，123等到所有JS文件都执行完之后才渲染，这种情况除了验证了第九点的结论，还能补充我们的结论：</p><blockquote><p><strong>如果第一脚本前的JS和CSS加载完了，<code>body</code>中的脚本还未下载完成，那么浏览器就会利用构建好的局部<code>CSSOM</code>和<code>DOM</code>提前渲染第一脚本前的内容（触发<code>FP</code>）；如果第一脚本前的JS和CSS都还没下载完成，<code>body</code>中的脚本就已经下载完了，那么浏览器就会在所有JS脚本都执行完之后才触发FP。</strong></p></blockquote><p>到这里本次探究就结束了，其实还有很多种情况，感兴趣的可以自己去试试。</p><h2 id=建议：><a href=#%E5%BB%BA%E8%AE%AE%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>建议：</h2><ul><li>CSS放在head中，JS放在<code>&lt;/body></code>前（如果在head必须放JS，也尽量减少他的大小，把大JS文件放<code>&lt;/body></code>前）。</li><li>减小head中CSS和JS大小（<code>gzip</code><a href=https://segmentfault.com/a/1190000012800222>了解一下？</a>)，</li><li>优化head中的JS和CSS外链的网络情况，减少<code>Stalled</code>、<code>TTFB</code>和<code>Content Download</code>的时间。</li><li>在第一脚本前使用骨架图，可以减少用户的白屏感知时间（对于使用JS插入模板来渲染的框架，建议将骨架图的路由生成逻辑单独提出来）</li></ul><h2 id=科普一下><a href=#%E7%A7%91%E6%99%AE%E4%B8%80%E4%B8%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>科普一下</h2><ul><li><code>Chrome</code>会渲染局部<code>CSSOM</code>和<code>DOM</code></li><li><code>First Paint</code>和<code>DOMContentLoaded</code>、<code>load</code>事件的触发没有绝对的关系，<code>FP</code>可能在他们之前，也可能在他们之后，这取决于影响他们触发的因素的各自时间（<code>FP</code>：<code>第一脚本</code>前<code>CSSOM</code>和<code>DOM</code>的构建速度；<code>DOMContentLoaded</code>：<code>HTML</code>文档自身以及<code>HTML</code>文档中所有<code>JS</code>、<code>CSS</code>的加载速度；<code>load</code>：图片、音频、视频、字体的加载速度）。</li><li><code>DOMContentLoaded</code>和<code>load</code>事件也没有强制的先后顺序，<code>DOMContentLoaded</code>一般在<code>load</code>事件之前触发，但也可能在<code>load</code>事件之后触发。</li><li><code>第一脚本</code>前的CSS如果还会去加载字体文件，那么即使<code>CSSOM</code>和<code>DOM</code>构建完成触发<code>FP</code>，页面内容也会是空白，只有等到字体文件下载完成才会出现内容（这也是我们在打开一个加载了谷歌字体的网站会白屏很长时间的原因）。</li><li>默认情况下，<code>CSS</code>外链之间是谁先加载完成谁先解析，但是<code>JS</code>外链之间即使先加载完成，也得按顺序执行。</li><li><code>link</code>外链后面紧跟<code>script</code>外链，须先等<code>link parse</code>完成之后，<code>script</code>才会执行，即使<code>script</code>先下载完成。<code>script</code>后面紧跟<code>link</code>，也是一样，会等<code>script</code>执行完之后，<code>link</code>才会<code>parse</code>。</li><li>如果<code>script</code>之后紧跟几个<code>link</code>且<code>script</code>比这几个<code>link</code>的下载时间都长，那<code>script</code>执行完成之后<code>link</code>是按顺序执行。</li><li><p><code>RRDL</code>：</p><ul><li>R：send <strong>R</strong>equest，发送资源请求</li><li>R：receive <strong>R</strong>esponse，接收到服务端响应</li><li>D：receive <strong>D</strong>ata，开始接受服务端数据(一个资源可能执行多次)</li><li>L：finish <strong>L</strong>oading，完成资源下载</li></ul></li><li>浏览器在<code>RRDL</code>的时候，在<code>D（Receive data）</code>这个步骤可能执行多次。</li><li><code>TTFB</code>:<code>Time To First Byte</code>，第一个字节返回的时间，这个是对应<code>send Request</code>到<code>receive Response</code>这段时间。</li><li>浏览器会给HTML中的资源文件进行等级分类（<code>Hightest/High/Meduim/Low/Lowest</code>）,一般<code>HTML</code>文档自身、<code>head</code>中的CSS都是<code>Hightest</code>，<code>head</code>中JS一般是<code>High</code>，而图片一般是<code>Low</code>，而设置了<code>async/defer</code>的脚本一般是<code>Low</code>，<code>gif</code>图片一般是<code>Lowest</code>。</li><li>下图中的资源文件浅色和深色和第二个图画红框的位置是对应的（不信自己计算一下对应的时间）</li></ul><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-16-04-40.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-16-05-44.jpg></p><p>参考链接：</p><ol><li><a href=https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/analyzing-crp?hl=zh-cn>分析关键渲染路径性能</a></li><li><a href=http://harttle.land/2016/11/26/static-dom-render-blocking.html>CSS/JS对DOM渲染的影响</a></li><li><a href=https://github.com/amfe/article/issues/47>CSS Animation性能优化</a></li></ol>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// blog/fe/Chrome的First Paint.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<h2 id=前言><a href=#%E5%89%8D%E8%A8%80 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>前言</h2><blockquote><p>First paint 直译过来的意思就是浏览器第一次渲染(paint)，在First paint之前是白屏，在这个时间点之后用户就能看到（部分）页面内容。</p></blockquote><p>所以研究这个First Paint的触发时机对于优化浏览器页面的首屏渲染时间有很重要的作用。</p><p>在正题开始之前，先说下浏览器的页面的加载流程（大体过程是这样，并不精确，只是为了帮助理解后面内容）：</p><ol><li>浏览器输入url，浏览器发送请求到服务器，服务器将请求的HTML返回给浏览器。</li><li>浏览器下载完成HTML(Finish Loading HTML)之后，便开始从上到下解析。</li><li><p>解析的过程中碰到css和js外链（其实HTML的下载也是这个流程）都会执行以下过程：</p><ol><li><strong><code>Send Request</code>:表示给这个外链对应的服务器发送请求</strong></li><li><strong><code>Receive Response</code>: 表示接收响应，这里是表示告诉浏览器可以开始从网络接收数据了</strong></li><li><strong><code>Receive Data</code>:表示开始接收数据</strong></li><li><strong><code>Finish Loading</code>: 表示已经完成下载数据。</strong></li><li><strong><code>Parse Stylesheet/Evaluate</code>（默认情况下js下载完成之后执行<code>Evaluate</code>，css下载完成后会进行<code>Parse Stylesheet</code>）</strong></li></ol></li><li>所有的css下载完成后<code>Parse Stylesheet</code>然后开始构建CSSOM</li><li>DOM（文档对象模型）和 CSSOM（CSS对象模型）会合并生成一个渲染树(<code>Render Tree</code>)</li><li>根据渲染树的内容计算处各个节点在网页中的大小和位置（<code>Layout</code>，可以理解为“刻章”）</li><li>根据Layout绘制内容在浏览器上（<code>Paint</code>，可以理解为“盖章”）。</li></ol><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-1.jpg></p><h2 id=正题开始><a href=#%E6%AD%A3%E9%A2%98%E5%BC%80%E5%A7%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>正题开始</h2><p>在最新版的Chrome的<code>perfomance</code>中是能直接看到First Paint这个时间点的，为了方便大家测试，我就直接拿谷歌这个示例页面来做演示:</p><p><a href=https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/measure_crp_timing.html>测试页面</a></p><p>用chrome打开上面链接，最好是隐身模式，防止插件乱入影响判断，按F12或者右键检查元素打开控制台先切换到<code>Network</code>选项,勾选禁用缓存(缓存也会影响到判断)：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F1.png alt=1></p><p>切换到<code>Perfomance</code>，勾选<code>Screenshots</code>并点击红框进行页面分析（会自动停止的，不用点stop）：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-2.jpg></p><p>分析完后可以看到如下结果：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2.png></p><p>上图中的绿色的线就是当前页面第一次出现内容的时间点，可以将鼠标放到<code>Main</code>上面的<code>Network</code>中绿色的线附近可以看到在他之前页面空白，在他之后就有内容。 除了绿色的线还有蓝色以及红色的线，这里也解释一下：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-4.jpg></p><p>简单讲一下<code>DOMContentLoaded</code>、<code>load</code>的区别：</p><ol><li><code>DOMContentLoaded</code>是HTML文档（包括CSS、JS）被加载以及解析完成之后触发（即 <code>HTML->DOM</code>的过程完成 ）</li><li><code>load</code>则是在页面的其他资源如图片、字体、音频、视频加载完成之后触发</li><li><code>load</code>事件一般在<code>DOMContentLoaded</code>之后才触发（也有可能在它之前哦）</li></ol><p>这个时候发现绿色虚线之前有一个浅绿色方块，相应的解释如下：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-5.jpg></p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-6.jpg></p><p>由图可以得出“浅绿色”代表的是<strong>根据CSSOM计算样式并进行布局绘制</strong>的过程，这段时间内浏览器做了一下事情：</p><ol><li><code>Recalculate Style</code>:重新计算样式，确定DOM元素的样式规则（定规则）</li><li><code>Layout</code>:根据计算结果进行布局，确定元素的大小和位置（刻章）</li><li><code>Update Layer Tree</code>: 更新渲染层树</li><li><code>Paint</code>: 绘制，根据前面的Layer Tree绘制页面（位置、大小、颜色、边框、阴影等）（盖章）</li><li><code>Composite Layers</code>： 形成层，浏览器按照合理的顺序合并成一个图层然后输出到屏幕（给别人看）</li></ol><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-8.jpg></p><p>那什么时候开始<code>First paint</code>呢?在浅绿色方块最前面的虚线往前看，发现在灰色虚线之前都会有一个步骤：就是<code>Parse Stylesheet</code>（调研了很多页面都是如此）</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2FfirstPaint-9.jpg></p><p>所以，First Paint的加载流程应该是这样：</p><ol><li><strong>所有的CSS加载完成</strong></li><li><strong><code>Parse Stylesheet</code>：构建出CSSOM</strong></li><li><strong><code>Recalculate Style</code>：重新计算样式，确定DOM元素的样式规则（定规则）</strong></li><li><strong><code>Layout</code>：根据计算结果进行布局，确定元素的大小和位置（刻章）</strong></li><li><strong><code>Update Layer Tree</code>：更新渲染层树</strong></li><li><strong><code>Paint</code>：绘制，根据前面的Layer Tree绘制页面（位置、大小、颜色、边框、阴影等）（盖章）</strong></li><li><strong><code>Composite Layers</code>：形成层，浏览器按照合理的顺序合并成一个图层然后输出到屏幕（给别人看）</strong></li></ol><p>但是现在还只是确定了<code>First Paint</code>的加载流程，也确定了他是在所有CSS执行完<code>Parse Stylesheet</code>之后才会触发，但是这还是不够准确啊，所以我找了一些CSS和JS的外链来测试，模板如下：</p><pre><code class=\\\"hljs language-html\\\"data-query={} data-lang=html><span class=hljs-meta>&lt;!DOCTYPE html></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>html</span> <span class=hljs-attr>lang</span>=<span class=hljs-string>\\\"en\\\"</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>head</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>meta</span> <span class=hljs-attr>charset</span>=<span class=hljs-string>\\\"UTF-8\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>meta</span> <span class=hljs-attr>name</span>=<span class=hljs-string>\\\"viewport\\\"</span> <span class=hljs-attr>content</span>=<span class=hljs-string>\\\"width=device-width, initial-scale=1.0\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>meta</span> <span class=hljs-attr>http-equiv</span>=<span class=hljs-string>\\\"X-UA-Compatible\\\"</span> <span class=hljs-attr>content</span>=<span class=hljs-string>\\\"ie=edge\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>title</span>></span>Document<span class=hljs-tag>&lt;/<span class=hljs-name>title</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>href</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.css\\\"</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>\\\"stylesheet\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>href</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.css\\\"</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>\\\"stylesheet\\\"</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/vue/2.5.13/vue.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/react/16.4.0-alpha.0911da3/cjs/react.development.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"https://cdn.bootcss.com/angular.js/2.0.0-beta.17/angular2.js\\\"</span>></span><span class=null></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\\n<span class=hljs-tag>&lt;/<span class=hljs-name>head</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>body</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>'root1'</span>></span>\\n        1\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>'root2'</span>></span>\\n        2\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>'root3'</span>></span>\\n        3\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>\\n<span class=hljs-tag>&lt;/<span class=hljs-name>body</span>></span>\\n<span class=hljs-tag>&lt;/<span class=hljs-name>html</span>></span></code></pre><p>我们通过改变上面模板里的外链顺序来探究：</p><h3 id=第一种情况：><a href=#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第一种情况：</h3><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F1%2FSnipaste_2018-04-23_19-29-12.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F1%2FSnipaste_2018-04-23_19-31-12.png></p><p>发现FP发生在最后（实心的蓝色线是按<code>shift</code>出来的，不是<code>DOMContentLoaded</code>）,现在还发现不了什么。</p><h3 id=第二种情况：><a href=#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第二种情况：</h3><p>调换<code>head</code>中CSS和JS外链位置</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F2%2FSnipaste_2018-04-23_19-31-59.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F2%2FSnipaste_2018-04-23_19-33-03.png></p><p>仍然发现不了什么</p><h3 id=第三种情况><a href=#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第三种情况</h3><p>把CSS放<code>head</code>，JS放<code>&lt;/body></code>前</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F3%2FSnipaste_2018-04-23_19-31-59.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F3%2FSnipaste_2018-04-23_19-38-26.png></p><p>发现<code>FP</code>竟然在蓝色和红色虚线前面出现，通过这点可以确定，<code>FP</code>还跟JS外链的位置有关，继续:</p><h3 id=第四种情况：><a href=#%E7%AC%AC%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第四种情况：</h3><p>JS外链放<code>head</code>，CSS放<code>&lt;/body></code>前</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F4%2FSnipaste_2018-04-23_19-39-23.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F4%2FSnipaste_2018-04-23_19-39-52.png></p><p>发现又跟第一二种情况一样了，所以这种用法是不可取的。</p><h3 id=第五种情况：><a href=#%E7%AC%AC%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第五种情况：</h3><p>CSS和JS都放<code>&lt;/body></code>前，且CSS紧贴在<code>div</code>后面，JS在CSS后面：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F5%2FSnipaste_2018-04-23_19-40-18.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F5%2FSnipaste_2018-04-23_19-41-21.png></p><p>可以发现<code>FP</code>居然更快触发，<strong>但是我鼠标hover到绿色虚线后，仍然是白屏，只有等到CSS加载完成执行<code>Parse Stylesheet</code>之后才显示出内容</strong>（说明这种用法也不可取），难道body中的CSS也会影响？</p><h3 id=第六种情况：><a href=#%E7%AC%AC%E5%85%AD%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第六种情况：</h3><p>掉换一下上面CSS和JS的位置：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F6%2FSnipaste_2018-04-23_19-41-55.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F6%2FSnipaste_2018-04-23_19-42-29.png></p><p>发现这次<code>FP</code>触发而且立马有内容，而等到CSS加载完成之后还会再重新渲染一次，嗯，看来body中的第一个JS脚本有猫腻，接下来的情况对他特殊照顾。</p><h3 id=第七种情况：><a href=#%E7%AC%AC%E4%B8%83%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第七种情况：</h3><p>CSS放<code>head</code>中，JS放在<code>div</code>节点中间：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2F7%2FSnipaste_2018-04-23_19-43-08.png> <img src=http://eux-blog-static.bj.bcebos.com/fp%2F7%2FSnipaste_2018-04-23_19-43-49.png></p><p>哈哈，居然只渲染了12俩字，说明浏览器会渲染body中脚本之前的内容，那会是哪个脚本之前的内容呢？</p><h3 id=第八种情况：><a href=#%E7%AC%AC%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第八种情况：</h3><p>在div之间都插入脚本</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-07-03.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-06-52.jpg></p><p>看来浏览器会提前渲染<code>body</code>中第一个脚本前的内容（<code>我们就把body中的第一个外链脚本叫做【第一脚本】吧</code>），并且<strong>第一脚本</strong>还会在FP之后才执行。所以结合之前得出的结论，在CSSOM准备就绪之后，浏览器会提前渲染第一脚本前的内容，我们可以用第九种情况来验证：</p><h3 id=第九种情况：><a href=#%E7%AC%AC%E4%B9%9D%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第九种情况：</h3><p>这种情况和上种没什么区别，只是增加了一个CSS，这个CSS中还会发出一个请求去加载其他CSS（通过<code>@import url()</code>的方式），所以CSS的加载时间很长。</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-19-44.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-19-35.jpg></p><p>通过结果可以看出，123在CSS下载完成之后才渲染，而不是单独渲染一个1，所以<code>FP</code>必须得等到<code>CSSOM</code>准备就绪之后才会触发，否则即使有第一脚本在也没用。 所以到这里，我们总算可以下结论了：</p><blockquote><p><strong>FP发生在body中第一个script脚本之前的CSS解析和JS执行完成之后。换句话说就是第一脚本之前的<code>DOM</code>和<code>CSSOM</code>准备就绪之后，便会着手渲染第一脚本前的内容。</strong></p></blockquote><p>但是...你以为到这里就结束了？其实没有。</p><h3 id=第十种情况：><a href=#%E7%AC%AC%E5%8D%81%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>第十种情况：</h3><p>这种情况中，<code>head</code>中既有JS也有CSS，<code>body</code>中也有第一脚本存在：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-34-55.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-35-11.jpg></p><p>注意上图中的<code>vue.js</code>是在<code>head</code>中的，而后面的JS文件都在<code>body</code>中，而且，<code>vue.js</code>加载完成之后，<code>body</code>中的JS还没下载完成，这个时候我们调换一下<code>vue.js</code>和<code>angular2.js</code>的位置：</p><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-37-53.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-15-37-46.jpg></p><p>看，这个时候又没有提前渲染了，123等到所有JS文件都执行完之后才渲染，这种情况除了验证了第九点的结论，还能补充我们的结论：</p><blockquote><p><strong>如果第一脚本前的JS和CSS加载完了，<code>body</code>中的脚本还未下载完成，那么浏览器就会利用构建好的局部<code>CSSOM</code>和<code>DOM</code>提前渲染第一脚本前的内容（触发<code>FP</code>）；如果第一脚本前的JS和CSS都还没下载完成，<code>body</code>中的脚本就已经下载完了，那么浏览器就会在所有JS脚本都执行完之后才触发FP。</strong></p></blockquote><p>到这里本次探究就结束了，其实还有很多种情况，感兴趣的可以自己去试试。</p><h2 id=建议：><a href=#%E5%BB%BA%E8%AE%AE%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>建议：</h2><ul><li>CSS放在head中，JS放在<code>&lt;/body></code>前（如果在head必须放JS，也尽量减少他的大小，把大JS文件放<code>&lt;/body></code>前）。</li><li>减小head中CSS和JS大小（<code>gzip</code><a href=https://segmentfault.com/a/1190000012800222>了解一下？</a>)，</li><li>优化head中的JS和CSS外链的网络情况，减少<code>Stalled</code>、<code>TTFB</code>和<code>Content Download</code>的时间。</li><li>在第一脚本前使用骨架图，可以减少用户的白屏感知时间（对于使用JS插入模板来渲染的框架，建议将骨架图的路由生成逻辑单独提出来）</li></ul><h2 id=科普一下><a href=#%E7%A7%91%E6%99%AE%E4%B8%80%E4%B8%8B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>科普一下</h2><ul><li><code>Chrome</code>会渲染局部<code>CSSOM</code>和<code>DOM</code></li><li><code>First Paint</code>和<code>DOMContentLoaded</code>、<code>load</code>事件的触发没有绝对的关系，<code>FP</code>可能在他们之前，也可能在他们之后，这取决于影响他们触发的因素的各自时间（<code>FP</code>：<code>第一脚本</code>前<code>CSSOM</code>和<code>DOM</code>的构建速度；<code>DOMContentLoaded</code>：<code>HTML</code>文档自身以及<code>HTML</code>文档中所有<code>JS</code>、<code>CSS</code>的加载速度；<code>load</code>：图片、音频、视频、字体的加载速度）。</li><li><code>DOMContentLoaded</code>和<code>load</code>事件也没有强制的先后顺序，<code>DOMContentLoaded</code>一般在<code>load</code>事件之前触发，但也可能在<code>load</code>事件之后触发。</li><li><code>第一脚本</code>前的CSS如果还会去加载字体文件，那么即使<code>CSSOM</code>和<code>DOM</code>构建完成触发<code>FP</code>，页面内容也会是空白，只有等到字体文件下载完成才会出现内容（这也是我们在打开一个加载了谷歌字体的网站会白屏很长时间的原因）。</li><li>默认情况下，<code>CSS</code>外链之间是谁先加载完成谁先解析，但是<code>JS</code>外链之间即使先加载完成，也得按顺序执行。</li><li><code>link</code>外链后面紧跟<code>script</code>外链，须先等<code>link parse</code>完成之后，<code>script</code>才会执行，即使<code>script</code>先下载完成。<code>script</code>后面紧跟<code>link</code>，也是一样，会等<code>script</code>执行完之后，<code>link</code>才会<code>parse</code>。</li><li>如果<code>script</code>之后紧跟几个<code>link</code>且<code>script</code>比这几个<code>link</code>的下载时间都长，那<code>script</code>执行完成之后<code>link</code>是按顺序执行。</li><li><p><code>RRDL</code>：</p><ul><li>R：send <strong>R</strong>equest，发送资源请求</li><li>R：receive <strong>R</strong>esponse，接收到服务端响应</li><li>D：receive <strong>D</strong>ata，开始接受服务端数据(一个资源可能执行多次)</li><li>L：finish <strong>L</strong>oading，完成资源下载</li></ul></li><li>浏览器在<code>RRDL</code>的时候，在<code>D（Receive data）</code>这个步骤可能执行多次。</li><li><code>TTFB</code>:<code>Time To First Byte</code>，第一个字节返回的时间，这个是对应<code>send Request</code>到<code>receive Response</code>这段时间。</li><li>浏览器会给HTML中的资源文件进行等级分类（<code>Hightest/High/Meduim/Low/Lowest</code>）,一般<code>HTML</code>文档自身、<code>head</code>中的CSS都是<code>Hightest</code>，<code>head</code>中JS一般是<code>High</code>，而图片一般是<code>Low</code>，而设置了<code>async/defer</code>的脚本一般是<code>Low</code>，<code>gif</code>图片一般是<code>Lowest</code>。</li><li>下图中的资源文件浅色和深色和第二个图画红框的位置是对应的（不信自己计算一下对应的时间）</li></ul><p><img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-16-04-40.jpg> <img src=http://eux-blog-static.bj.bcebos.com/fp%2Fnew%2F2018-04-13-16-05-44.jpg></p><p>参考链接：</p><ol><li><a href=https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/analyzing-crp?hl=zh-cn>分析关键渲染路径性能</a></li><li><a href=http://harttle.land/2016/11/26/static-dom-render-blocking.html>CSS/JS对DOM渲染的影响</a></li><li><a href=https://github.com/amfe/article/issues/47>CSS Animation性能优化</a></li></ol>\",\n  \"extra\": {\n    \"_image-loader_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./doc/fe/Chrome的First Paint.md\n// module id = 800\n// module chunks = 54"],"sourceRoot":""}