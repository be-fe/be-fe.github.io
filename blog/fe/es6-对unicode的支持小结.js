webpackJsonp([48,56],{806:function(a,e){a.exports={content:'<ul><li>Chrome 内置抓包工具</li><li>Block requests</li><li>截取长图</li><li>代码的覆盖率分析</li><li>Make site better</li></ul><h4 id=es5只支持uffff65535以内的unicode><a href=#es5%E5%8F%AA%E6%94%AF%E6%8C%81uffff65535%E4%BB%A5%E5%86%85%E7%9A%84unicode aria-hidden=true><span class="icon icon-link"></span></a>ES5只支持\\uffff(65535)以内的unicode</h4><p>比如你写</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-string>"\\u22000"</span> <span class=hljs-comment>//在unicode中对应为生僻字：𢀀</span></code></pre><p>但是最后展示为："∀0"。</p><p>结论：JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p><p>那么参考下<a href=https://github.com/xfgryujk/TiebaManager/wiki/%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%9A%84unicode%E5%8C%BA%E9%97%B4>各种字符的unicode区间</a>，其实还是有很多会用到的字符，它们的区间大于0xFFFF的。比如我们常见的emoji表情。这些在ES5中就没办法进行处理了。</p><h4 id=es6的写法><a href=#es6%E7%9A%84%E5%86%99%E6%B3%95 aria-hidden=true><span class="icon icon-link"></span></a>ES6的写法</h4><h5 id=万能写法：><a href=#%E4%B8%87%E8%83%BD%E5%86%99%E6%B3%95%EF%BC%9A aria-hidden=true><span class="icon icon-link"></span></a>万能写法：{}</h5><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-string>"\\u{22000}"</span></code></pre><p>这种写法比较简便，在正则中也可以使用，前提是要有u标示符, 否则会被识别为正则语法中的花括号</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-string>"𢀀的蛋"</span>.match(<span class=hljs-regexp>/\\u{22000}/u</span>) <span class=hljs-comment>//return ["𢀀"]</span>\n<span class=hljs-string>"𢀀的蛋"</span>.match(<span class=hljs-regexp>/\\u{22000}/</span>)  <span class=hljs-comment>//return null</span></code></pre><h5 id=stringprototypecharcodeat-vs-stringprototypecodepointat><a href=#stringprototypecharcodeat-vs-stringprototypecodepointat aria-hidden=true><span class="icon icon-link"></span></a><code>String.prototype.charCodeAt</code> vs <code>String.prototype.codePointAt</code></h5><p>前者是ES5的写法，后者是ES6的写法，均由字符返回十进制的unicode编码，区别在于是否支持0xffff以上。</p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-string>"𢀀"</span>.charCodeAt()   <span class=hljs-comment>//55368 这个值是错的</span>\n<span class=hljs-string>"𢀀"</span>.codePointAt()  <span class=hljs-comment>//139264 十进制</span>\n<span class=hljs-string>"𢀀"</span>.codePointAt().toString(<span class=hljs-number>16</span>) <span class=hljs-comment>//"22000" 转为16进制的快捷方法</span></code></pre><h5 id=stringfromcharcode-vs-stringfromcodepoint><a href=#stringfromcharcode-vs-stringfromcodepoint aria-hidden=true><span class="icon icon-link"></span></a><code>String.fromCharCode</code> vs <code>String.fromCodePoint</code></h5><p>前者是ES5的写法，后者是ES6的写法，由unicode编码返回相应的字符串。</p><p>需要注意参数默认为十进制</p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-built_in>String</span>.fromCodePoint(<span class=hljs-number>0x22000</span>)  <span class=hljs-comment>//"𢀀"</span>\n<span class=hljs-built_in>String</span>.fromCodePoint(<span class=hljs-number>22000</span>)    <span class=hljs-comment>//"嗰"</span></code></pre><h4 id=正则表达式的unicode-property支持><a href=#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84unicode-property%E6%94%AF%E6%8C%81 aria-hidden=true><span class="icon icon-link"></span></a>正则表达式的Unicode Property支持</h4><p><a href=http://www.infoq.com/cn/news/2011/03/regular-expressions-unicode-2>Unicode Property的解释</a></p><p>ES5中的正则是不支持Unicode Property的，而ES6可以支持，这样我们可以更方便的用正则包含或排除某些字符（<a href=http://php.net/manual/zh/regexp.reference.unicode.php>常用的unicode字符属性</a>），比较好用的一个是C属性，表示不对应任何字符的unicode码，可以有效的过滤掉没用的unicode码。</p><p>比如这个例子：\\uffff是一个不对应任何字符的码点，我们就可以很容易的过滤掉这个非法字符。</p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-string>"\\u6211\\uffff"</span>.replace(<span class=hljs-regexp>/\\p{C}/u</span>, <span class=hljs-string>\'\'</span>);  <span class=hljs-comment>//我</span></code></pre><h4 id=babel能不能兼容？><a href=#babel%E8%83%BD%E4%B8%8D%E8%83%BD%E5%85%BC%E5%AE%B9%EF%BC%9F aria-hidden=true><span class="icon icon-link"></span></a>Babel能不能兼容？</h4><p>能。Babel编译器可以转换uncode regex, babel-polyfill可以兼容String.fromCodePoint和String.prototype.codePointAt。</p><p>注：String.fromCodePoint和String.prototype.codePointAt属于新的API，所有ES6+中新的API，都需要使用babel-polyfill，可以在项目中引用babel-polyfill，或在编译器中配置babel-plugin-transform-runtime.</p><img width=1096 height=746 src=http://text-learn.qiniudn.com/65395a8351886b09951f5f917f676f03.png style=width:400px> <img src=http://text-learn.qiniudn.com/f9dc4bf38b9c437f4e159b091789beb4.png width=1008 height=836><h3 id=参考文章><a href=#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0 aria-hidden=true><span class="icon icon-link"></span></a>参考文章</h3><ul><li><a href=https://github.com/xfgryujk/TiebaManager/wiki/%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%9A%84unicode%E5%8C%BA%E9%97%B4>各种字符的unicode区间</a></li><li><a href=http://www.infoq.com/cn/news/2011/03/regular-expressions-unicode-2>Unicode Property的解释</a></li><li><a href=http://php.net/manual/zh/regexp.reference.unicode.php>常用的unicode字符属性</a></li><li><a href=http://es6.ruanyifeng.com>阮一峰 ECMAScript6入门</a></li></ul><h4 id=彩蛋：一些有意思的小bug><a href=#%E5%BD%A9%E8%9B%8B%EF%BC%9A%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%B0%8Fbug aria-hidden=true><span class="icon icon-link"></span></a>彩蛋：一些有意思的小bug</h4><pre><code data-query={} data-lang>var reg = /[\\u{ffff}-\\u{fffff}]/u\nreg.test("😁") //true\n\nvar reg = /[\\u0030-\\uffff]/\nreg.test("😁") //true\n\nvar reg = /[\\u{0030}-\\u{ffff}]/u\nreg.test("😁") //false\n\nvar reg = /[\\u4e00-\\u9fa5]/    \nreg.test("😁") //false\n\n不用u，进入特殊字符区间，就会出错，期望是false, 实际是true\nvar reg = /[\\u4e00-\\uffff]/\nreg.test("\\u{fffff}")\n\nvar reg= /😁/\nreg.test("😁") //true\n\nvar reg= /😁{2}/\nreg.test("😁😁") //false\n\nvar reg= /😁{2}/u\nreg.test("😁😁") //true\n</code></pre>',extra:{"_image-loader_":[]}}}});
//# sourceMappingURL=es6-对unicode的支持小结.js.map