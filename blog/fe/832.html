<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> WebGL 基础知识 | 百度EUX </title>
    <link rel="stylesheet" href="/style.css">
    <script>
      (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?d232748d06c1fe09a6db3db0077669b7";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();

      var _vds = _vds || [];
      window._vds = _vds;
      (function () {
        _vds.push(['setAccountId', '66707fb8b27442d5b3ccca57a56800fa']);
        _vds.push(['trackBot', false]);

        (function () {
          var vds = document.createElement('script');
          vds.type = 'text/javascript';
          vds.async = true;
          vds.src = '//dn-growing.qbox.me/vds.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(vds, s);
        })();
      })();
    </script>
</head>
<body>
<div id="root">
    <div class="main" data-reactroot="" data-reactid="1" data-react-checksum="-682634746"><!-- react-empty: 2 --><header class="eux-header clearfix" data-reactid="3"><div class="eux-header-top" data-reactid="4"><a href="javascript:void(0);" class="eux-portable-menu" data-reactid="5"><span data-reactid="6"></span><span data-reactid="7"></span><span data-reactid="8"></span></a><!-- react-empty: 9 --><nav class="menu-primary-container" data-reactid="10"><ul id="menu-primary" class="menu" data-reactid="11"><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-25" data-reactid="12"><a href="/" data-reactid="13">HOME</a></li><li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-ancestor current-menu-parent menu-item-has-children menu-item-45" data-reactid="14"><a href="/" data-reactid="15">BLOG</a><ul class="sub-menu" data-reactid="16"><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="17"><a href="/ue" data-reactid="18">交互</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="19"><a href="/ui" data-reactid="20">视觉</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="21"><a href="/fe" data-reactid="22">前端</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="23"><a href="/team" data-reactid="24">团队</a></li></ul></li><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-46" data-reactid="25"><a href="/tools" data-reactid="26">TOOLS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-112" data-reactid="27"><a href="/works" data-reactid="28">WORKS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-138" data-reactid="29"><a href="/jobs" data-reactid="30">JOBS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-50" data-reactid="31"><a href="/about-us" data-reactid="32">ABOUT US</a></li></ul></nav></div></header><div class="eux-singular clearfix" data-reactid="33"><div class="container-singular clearfix" data-reactid="34"><nav class="menu-categories-container" data-reactid="35"><ul id="menu-categories" class="menu" data-reactid="36"><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="37"><span data-reactid="38"><a href="/" data-reactid="39">全部</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="40"><span data-reactid="41"><a href="/ue" data-reactid="42">交互</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="43"><span data-reactid="44"><a href="/ui" data-reactid="45">视觉</a></span></li><li class="current-menu-item menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="46"><span data-reactid="47"><a href="/fe" data-reactid="48">前端</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="49"><span data-reactid="50"><a href="/team" data-reactid="51">团队</a></span></li></ul></nav><div class="inner clearfix" data-reactid="52"><div class="article-meta" data-reactid="53"><h1 class="title" data-reactid="54">WebGL 基础知识</h1><div class="eux-page-detail" data-reactid="55"><span data-reactid="56"><em data-reactid="57">by.</em><!-- react-text: 58 -->赵琳琳<!-- /react-text --></span><span data-reactid="59">2017-11-27</span></div></div><article data-reactid="60"><h2 id="背景介绍" data-reactid="61"><a href="#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D" aria-hidden="true" data-reactid="62"><span class="icon icon-link" data-reactid="63"></span></a><!-- react-text: 64 -->背景介绍<!-- /react-text --></h2><p data-reactid="65">OpenGL -&gt; OpenGL ES -&gt; OpenGL ES 2.0 -&gt; WebGL</p><img src="http://eux-blog-static.bj.bcebos.com/relations.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A10%3A58Z%2F-1%2Fhost%2F4a71a255776a0d2ccad6e3770850dd41f3084c637ee63baa27380577e955bea4" alt="image" width="748" height="273" data-reactid="66"/><p data-reactid="67">OpenGL Embeded Subset是OpenGL的一个子集, 针对嵌入式和移动端做了功能精简和性能优化</p><p data-reactid="68">WebGL基于OpenGL ES 2.0标准, 基本就是将原来C语言的API和配置项迁移到Javascript, 去掉了一些实在不兼容的部分</p><p data-reactid="69">WebGL 2.0基于OpenGL ES 3.0</p><h2 id="渲染管道pipeline" data-reactid="70"><a href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E9%81%93pipeline" aria-hidden="true" data-reactid="71"><span class="icon icon-link" data-reactid="72"></span></a><!-- react-text: 73 -->渲染管道(PipeLine)<!-- /react-text --></h2><img src="http://eux-blog-static.bj.bcebos.com/pipeLine.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A11%3A28Z%2F-1%2Fhost%2F05b7a0082971623bc87bfde081711104b5c83f3d206e1cce2bae0f5f4927de3d" alt="image" width="748" height="537" data-reactid="74"/><h3 id="vertex-array-顶点数组" data-reactid="75"><a href="#vertex-array-%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84" aria-hidden="true" data-reactid="76"><span class="icon icon-link" data-reactid="77"></span></a><!-- react-text: 78 -->Vertex Array: 顶点数组<!-- /react-text --></h3><p data-reactid="79">初始化数据(利用3D建模工具等生成的模型顶点)</p><h3 id="vertex-shader-顶点着色器" data-reactid="80"><a href="#vertex-shader-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8" aria-hidden="true" data-reactid="81"><span class="icon icon-link" data-reactid="82"></span></a><!-- react-text: 83 -->Vertex Shader: 顶点着色器<!-- /react-text --></h3><p data-reactid="84">计算坐标, 颜色等顶点相关数据, 相关概念:</p><ul data-reactid="85"><li data-reactid="86">Attributes: 从顶点数组获取的每个顶点的初始数据</li><li data-reactid="87">Uniforms: 计算需要的常量数据</li><li data-reactid="88">Samplers: 代表材质(Texture)的一类特殊常量, 在顶点着色器中是可选的</li><li data-reactid="89">Shader Program: 着色器程序, 使用着色器语言(Shading Language, 类似C语言)编写的可执行程序代码, 指定需要在顶点上作什么样的计算和处理</li><li data-reactid="90">Varying Variables: 顶点着色器的输出, 计算出的每个顶点相关数据</li></ul><pre data-reactid="91"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="92"><!-- react-text: 93 -->attribute vec4 a_Position;
attribute vec4 a_Color;
uniform mat4 u_MvpMatrix;
varying vec4 v_Color;
<!-- /react-text --><span class="hljs-keyword" data-reactid="94">void</span><!-- react-text: 95 --> main() {
    gl_Position = u_MvpMatrix * a_Position;
    v_Color = a_Color;
}<!-- /react-text --></code></pre><h3 id="primitive-assemply-图元组装" data-reactid="96"><a href="#primitive-assemply-%E5%9B%BE%E5%85%83%E7%BB%84%E8%A3%85" aria-hidden="true" data-reactid="97"><span class="icon icon-link" data-reactid="98"></span></a><!-- react-text: 99 -->Primitive Assemply: 图元组装<!-- /react-text --></h3><p data-reactid="100">根据计算出的顶点信息和绘图命令绘制基本图形, 包括: 三角形(Triangle), 直线(Line), 点(Point-Sprite); 一般3d图形都是由三角形组成的</p><h3 id="rasterization-栅格化" data-reactid="101"><a href="#rasterization-%E6%A0%85%E6%A0%BC%E5%8C%96" aria-hidden="true" data-reactid="102"><span class="icon icon-link" data-reactid="103"></span></a><!-- react-text: 104 -->Rasterization: 栅格化<!-- /react-text --></h3><p data-reactid="105">利用插值(interpolation)的方法计算顶点之间的边及边之间的内部点的数据, 计算出的数据就是所有需要绘制的像素点, 作为输入传给Fragment Shader</p><img src="http://eux-blog-static.bj.bcebos.com/rasterization.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A11%3A57Z%2F-1%2Fhost%2Fce034b581502a98d42b48880299e4ac87674a2c8d81706d1e898cb67f79225bc" alt="image" width="748" height="155" data-reactid="106"/><p data-reactid="107">一般栅格化之前还要经过裁剪(clipping, 把不在可见区域范围内的点去掉); 剔除(culling, 把背对可见方向, 完全不会被看见的面去掉), 来减少计算量</p><h3 id="fragment-shader-片段着色器-像素着色器" data-reactid="108"><a href="#fragment-shader-%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8-%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8" aria-hidden="true" data-reactid="109"><span class="icon icon-link" data-reactid="110"></span></a><!-- react-text: 111 -->Fragment Shader: 片段着色器, 像素着色器<!-- /react-text --></h3><p data-reactid="112">在这个阶段可以应用材质(Texture), 进行逐像素的颜色处理, 相关概念:</p><ul data-reactid="113"><li data-reactid="114">Varying Variables: 栅格化的结果, 计算出的每个像素点相关数据</li><li data-reactid="115">Uniforms: 计算需要的常量数据</li><li data-reactid="116">Samplers: 代表材质(Texture)的一类特殊常量</li><li data-reactid="117">Shader Program: 着色器程序, 使用着色器语言(Shading Language, 类似C语言)编写的可执行程序代码, 指定需要在像素点上作什么样的计算和处理</li></ul><pre data-reactid="118"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="119"><!-- react-text: 120 -->varying vec4 v_Color;
<!-- /react-text --><span class="hljs-keyword" data-reactid="121">void</span><!-- react-text: 122 --> main() {
    gl_FragColor = v_Color;
}<!-- /react-text --></code></pre><h3 id="per-fragment-operations-逐像素处理" data-reactid="123"><a href="#per-fragment-operations-%E9%80%90%E5%83%8F%E7%B4%A0%E5%A4%84%E7%90%86" aria-hidden="true" data-reactid="124"><span class="icon icon-link" data-reactid="125"></span></a><!-- react-text: 126 -->Per-Fragment Operations: 逐像素处理<!-- /react-text --></h3><p data-reactid="127">对像素执行一些可选的后处理</p><img src="http://eux-blog-static.bj.bcebos.com/per-fragment-operation.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A12%3A39Z%2F-1%2Fhost%2Fead684c7662d16a8407267409586cd8d156115a856838c73a77ca48c729fc286" alt="image" width="748" height="230" data-reactid="128"/><ul data-reactid="129"><li data-reactid="130">scissor test: 限制只在一个矩形区域更新像素</li><li data-reactid="131">stencil test: 像素级的蒙板(stecil buffer), 可以定义哪些蒙板区域更新, 哪些不更新</li><li data-reactid="132">depth test: 默认需要开启, 测试像素的深度, 决定哪些像素</li></ul><h3 id="framebuffer-帧缓存" data-reactid="133"><a href="#framebuffer-%E5%B8%A7%E7%BC%93%E5%AD%98" aria-hidden="true" data-reactid="134"><span class="icon icon-link" data-reactid="135"></span></a><!-- react-text: 136 -->Framebuffer: 帧缓存<!-- /react-text --></h3><p data-reactid="137">一个GL Context可以有多个帧缓存, 存储可渲染区域的像素相关数据</p><h2 id="坐标变换-图形变换" data-reactid="138"><a href="#%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2-%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2" aria-hidden="true" data-reactid="139"><span class="icon icon-link" data-reactid="140"></span></a><!-- react-text: 141 -->坐标变换 &amp;图形变换<!-- /react-text --></h2><p data-reactid="142">通常在顶点着色器中应用坐标变换, 计算每个顶点的最终坐标位置</p><img src="http://eux-blog-static.bj.bcebos.com/coordinate-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A18Z%2F-1%2Fhost%2F37db9570c8314c6b16fc0bd81b51cdb343731cf358d4b5e48744c55e6ddf3c5a" alt="image" width="748" height="214" data-reactid="143"/><h3 id="本地坐标系local-coordinate-system" data-reactid="144"><a href="#%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%B3%BBlocal-coordinate-system" aria-hidden="true" data-reactid="145"><span class="icon icon-link" data-reactid="146"></span></a><!-- react-text: 147 -->本地坐标系(local coordinate system)<!-- /react-text --></h3><p data-reactid="148">指通过算法或建模软件生成模型时的坐标系, 通常以模型自己的中心点为坐标原点</p><img src="http://eux-blog-static.bj.bcebos.com/local-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A39Z%2F-1%2Fhost%2F0ac6e90894094f42c2abbeb49f2aefbfe0d614c4930c3d30a88dc3a338976a20" alt="image" width="400" height="379" data-reactid="149"/><h3 id="世界坐标系world-coordinate-system" data-reactid="150"><a href="#%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E7%B3%BBworld-coordinate-system" aria-hidden="true" data-reactid="151"><span class="icon icon-link" data-reactid="152"></span></a><!-- react-text: 153 -->世界坐标系(world coordinate system)<!-- /react-text --></h3><p data-reactid="154">通过平移, 旋转, 放缩等图形变换方法, 把模型放置到一个更大的坐标系中</p><img src="http://eux-blog-static.bj.bcebos.com/world-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A15%3A59Z%2F-1%2Fhost%2F1e7c30d42c77b4f3fc96dc90fa37bfabc05f3e9aa287d381d4e4899f5bfafa41" alt="image" width="748" height="344" data-reactid="155"/><h4 id="图形变换" data-reactid="156"><a href="#%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2" aria-hidden="true" data-reactid="157"><span class="icon icon-link" data-reactid="158"></span></a><!-- react-text: 159 -->图形变换<!-- /react-text --></h4><p data-reactid="160"><!-- react-text: 161 -->任何图形变换都可以用矩阵的方式表达; 不同变换的叠加可以用矩阵相乘的形式来计算. 可以参考 <!-- /react-text --><a href="http://glmatrix.net/docs/module-quat.html" data-reactid="162">glMatrix</a><!-- react-text: 163 --> 库的 rotate, translate, scale等方法<!-- /react-text --></p><h3 id="观察坐标系view-coordinate-system" data-reactid="164"><a href="#%E8%A7%82%E5%AF%9F%E5%9D%90%E6%A0%87%E7%B3%BBview-coordinate-system" aria-hidden="true" data-reactid="165"><span class="icon icon-link" data-reactid="166"></span></a><!-- react-text: 167 -->观察坐标系(view coordinate system)<!-- /react-text --></h3><p data-reactid="168">通过指定观察点坐标(eye point), 目标点(lookAt point), 竖直方向(up vector)来确定一个观察坐标系</p><img src="http://eux-blog-static.bj.bcebos.com/view-system.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A01Z%2F-1%2Fhost%2F98df745d508e5fc824b8748a15628ae0d00b98b1b6f00d0f8969cde13698da40" alt="image" width="748" height="239" data-reactid="169"/><p data-reactid="170"><!-- react-text: 171 -->观察矩阵的生成可以参考<!-- /react-text --><a href="http://glmatrix.net/docs/module-quat.html" data-reactid="172">glMatrix</a><!-- react-text: 173 --> 库的lookAt方法<!-- /react-text --></p><img src="http://eux-blog-static.bj.bcebos.com/lookAt-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A29Z%2F-1%2Fhost%2Ff087aec8d1cc64e42116443a78373d568ef015d2966be2c0caedd9bc8a6b794a" alt="image" width="748" height="144" data-reactid="174"/><p data-reactid="175">观察矩阵和图形变换矩阵有时是可以互换的, 把物体位置向观察点靠近和把观察点向物体靠近, 两种变化效果是一样的</p><p data-reactid="176">只是一个应用了图形变换, 一个应用了观察坐标系变换. 通常这两种变换是结合使用, 各有各的目的</p><h3 id="剪裁坐标系clipping-coordinate-system" data-reactid="177"><a href="#%E5%89%AA%E8%A3%81%E5%9D%90%E6%A0%87%E7%B3%BBclipping-coordinate-system" aria-hidden="true" data-reactid="178"><span class="icon icon-link" data-reactid="179"></span></a><!-- react-text: 180 -->剪裁坐标系(clipping coordinate system)<!-- /react-text --></h3><p data-reactid="181">在这一步会利用投影的方法, 把一个3D的物体投影的2D的屏幕中去</p><p data-reactid="182">这一步可以确认物体是否在可见范围内, 哪一部分在可见范围内, 所以叫剪裁坐标系</p><h4 id="正交投影orthographic-projection" data-reactid="183"><a href="#%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1orthographic-projection" aria-hidden="true" data-reactid="184"><span class="icon icon-link" data-reactid="185"></span></a><!-- react-text: 186 -->正交投影(orthographic projection)<!-- /react-text --></h4><p data-reactid="187">用一个盒子状的可见范围平行投影物体, 没有近大远小的概念, left, right, bottom, top, near, far分别表示盒子的六个面的坐标</p><img src="http://eux-blog-static.bj.bcebos.com/orthographic-projection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A17%3A57Z%2F-1%2Fhost%2F90ad01daebdb5c7b7565cee6906d1ec2d30faf3dd9e494d2ea2c4684536b7277" alt="image" width="748" height="437" data-reactid="188"/><p data-reactid="189">glMatrix中的对应方法</p><img src="http://eux-blog-static.bj.bcebos.com/ortho-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A18%3A23Z%2F-1%2Fhost%2Fd50d52f7366f517051a94bbe4f57faacb1153857f4c8af042fe28c0661371ff4" alt="image" width="748" height="104" data-reactid="190"/><p data-reactid="191">矩阵公式</p><img src="http://eux-blog-static.bj.bcebos.com/ortho-matrix.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A18%3A48Z%2F-1%2Fhost%2F8794b1092eb2d52dd4bdca29f2469ca05560ab4221ad3e9bfc2d9cdc1e1855b9" alt="image" width="500" height="227" data-reactid="192"/><h4 id="透视投影perspective-projection" data-reactid="193"><a href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1perspective-projection" aria-hidden="true" data-reactid="194"><span class="icon icon-link" data-reactid="195"></span></a><!-- react-text: 196 -->透视投影(perspective projection)<!-- /react-text --></h4><p data-reactid="197">类似素描里近大远小的透视方法, 用一个四面梯形定义可见范围, fov表示视角(上下平面之间角度), aspect表示剪裁矩形的宽高比, near和far表示剪裁近平面和远平面</p><img src="http://eux-blog-static.bj.bcebos.com/perspective-projection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A11Z%2F-1%2Fhost%2F8bdae66dd39c5c9450ec65b5a58174218535381a1a5cc52dfad550c4c9a03f66" alt="image" width="748" height="347" data-reactid="198"/><p data-reactid="199">glMatrix的方法</p><img src="http://eux-blog-static.bj.bcebos.com/perspective-api.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A33Z%2F-1%2Fhost%2F199a2df06bf15c70d14438e2945200ef6db70f61973b93c40e816997c68ccb19" alt="image" width="748" height="109" data-reactid="200"/><p data-reactid="201">矩阵公式</p><img src="http://eux-blog-static.bj.bcebos.com/perspective-matrix.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A19%3A49Z%2F-1%2Fhost%2F1f36856449c354990b71b02b62dcb2fb27cd35f4619a588e6bc44a3540e247b8" alt="image" width="500" height="256" data-reactid="202"/><p data-reactid="203">最终的剪裁坐标系x, y, z轴都会标准化为[-1, 1]的范围, z轴表示物体的前后覆盖关系; 在剪裁阶段所有坐标不在[-1, 1]范围内的点都会认为不可见(z轴是0到-1, 因为观察点在0点且向负方向看)</p><img src="http://eux-blog-static.bj.bcebos.com/cliping-system-1.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A09Z%2F-1%2Fhost%2Fe40dc957de2cfbf9e1399eaafbfe6dba0953f1995aa0c8fbfbe55ba056663cb9" alt="image" width="748" height="272" data-reactid="204"/><!-- react-text: 205 --> <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/cliping-system-2.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A21Z%2F-1%2Fhost%2F13361f77c179c166e2fcc46fbc0f785bf1b31585b2e978ecd69593a925020a18" alt="image" width="500" height="403" data-reactid="206"/><h2 id="光照-材质" data-reactid="207"><a href="#%E5%85%89%E7%85%A7-%E6%9D%90%E8%B4%A8" aria-hidden="true" data-reactid="208"><span class="icon icon-link" data-reactid="209"></span></a><!-- react-text: 210 -->光照 &amp;材质<!-- /react-text --></h2><h3 id="光照类型" data-reactid="211"><a href="#%E5%85%89%E7%85%A7%E7%B1%BB%E5%9E%8B" aria-hidden="true" data-reactid="212"><span class="icon icon-link" data-reactid="213"></span></a><!-- react-text: 214 -->光照类型<!-- /react-text --></h3><ul data-reactid="215"><li data-reactid="216"><!-- react-text: 217 -->平行光源: 类似太阳光, 可以认为发光光源距离无限远, 因此所有光线方向相同, 光照强度相同; 计算时只用考虑方向和颜色 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/directional-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A20%3A49Z%2F-1%2Fhost%2Faaa86929c4a748214bc37ef1d48cd31e8f6b815f34093338c9acf84ebc288a35" alt="image" width="400" height="409" data-reactid="218"/></li><li data-reactid="219"><!-- react-text: 220 -->点光源: 类似聚光灯效果, 照射到物体上的光线方向不同, 强度也不同 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/point-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A06Z%2F-1%2Fhost%2F65f09f44063bd50c9ec10aa120044602989613a673be148f57e5f652fe422f2a" alt="image" width="400" height="501" data-reactid="221"/></li><li data-reactid="222"><!-- react-text: 223 -->环境光: 从各个方向以相同强度照射到物体上的光线, 计算时只考虑颜色 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/ambient-light.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A24Z%2F-1%2Fhost%2Fca1a609564e8e654e69fdbbdbea4700c46d1113d23ef2ccd7f36729131268c6a" alt="image" width="400" height="312" data-reactid="224"/></li></ul><h3 id="反射类型" data-reactid="225"><a href="#%E5%8F%8D%E5%B0%84%E7%B1%BB%E5%9E%8B" aria-hidden="true" data-reactid="226"><span class="icon icon-link" data-reactid="227"></span></a><!-- react-text: 228 -->反射类型<!-- /react-text --></h3><ul data-reactid="229"><li data-reactid="230"><p data-reactid="231">漫反射(diffuse reflection) 光线照射在纸张, 木头等表面粗糙的物体上会发生漫反射, 光线会向各个方向均匀的反射, 强度与入射方向和表面方向夹角theta有关; 与观察方向无关</p><img src="http://eux-blog-static.bj.bcebos.com/diffuse-reflection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A21%3A48Z%2F-1%2Fhost%2Ff80a74eb2efcb4eb95e07ca196bc2930689d4c5d542f130b2e97640579ff7904" alt="image" width="400" height="355" data-reactid="232"/></li></ul><pre data-reactid="233"><code data-query="{}" data-lang="data-lang" data-reactid="234">计算公式: Diffuse = kDiffuse × N • L × CBase
    Diffuse表示漫反射颜色
    KDiffuse表示入射光颜色
    N表示物体表面法线方向
    L表示入射光方向
    CBase表示物体本身颜色
</code></pre><ul data-reactid="235"><li data-reactid="236"><!-- react-text: 237 -->环境反射(Ambient reflection) 环境光照射的效果, 由各个方向入射再反射到各个方向 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/ambient-reflection.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A07Z%2F-1%2Fhost%2F1a52158474134fd9130f6d2da5ce8a6374e1d5c47538e6bb929bde9355457154" alt="image" width="400" height="299" data-reactid="238"/></li></ul><pre data-reactid="239"><code data-query="{}" data-lang="data-lang" data-reactid="240">计算公式: Ambient = kAmbient × CBase
    Ambient表示环境反射颜色
    kAmbient表示入射光颜色
    CBase表示物体本身颜色
</code></pre><ul data-reactid="241"><li data-reactid="242">镜面反射(specular reflection) 在镜面, 金属等表面光滑物体表面, 入射光大部分会从单一方向反射出去, 因此反射强度跟入射方向, 物体表面方向和观察方向都有关系</li></ul><pre data-reactid="243"><code data-query="{}" data-lang="data-lang" data-reactid="244">计算公式: Specular = kSpecular × pow(max(R • V, 0), kSpecularPower)
    Specular表示镜面反射颜色
    kSpecular表示入射光颜色
    R = 2 × N × (N • L) – L
    N, L分别表示法线方向和入射光方向
    V表示观察方向
    kSpecularPower表示高光系数, 代表物体表面反射光的能力
</code></pre><p data-reactid="245">环境反射和平行光的漫反射可以在顶点着色器阶段计算, 因为不考虑光的方向或入射光方向一致;</p><p data-reactid="246">聚光灯的漫反射和镜面反射效果需要在片段着色器阶段计算, 因为照射到物体表面的每个点光线方向不同(聚光灯漫反射)或对于每个点观察方向都不同(镜面反射)</p><p data-reactid="247">物体表面某点的颜色 = 漫反射颜色 + 环境反射颜色 + 镜面反射颜色 (也可以没有镜面反射)</p><pre data-reactid="248"><code data-query="{}" data-lang="data-lang" data-reactid="249">影响物体材质的因素:
    物体本身颜色(CBase)
    入射光颜色(kDiffuse, kAmbient, kSpecular)
    法线方向(N)
    入射方向(L)
    观察方向(V)
    高光系数(kSpecularPower)
</code></pre><h2 id="纹理贴图" data-reactid="250"><a href="#%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE" aria-hidden="true" data-reactid="251"><span class="icon icon-link" data-reactid="252"></span></a><!-- react-text: 253 -->纹理贴图<!-- /react-text --></h2><h3 id="贴图类型" data-reactid="254"><a href="#%E8%B4%B4%E5%9B%BE%E7%B1%BB%E5%9E%8B" aria-hidden="true" data-reactid="255"><span class="icon icon-link" data-reactid="256"></span></a><!-- react-text: 257 -->贴图类型<!-- /react-text --></h3><ul data-reactid="258"><li data-reactid="259"><!-- react-text: 260 -->色彩贴图: 将贴图的数据赋值给物体的本身颜色 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/basic-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A40Z%2F-1%2Fhost%2Fbf711f75e879569daeed43eaa4ee8b1e5c1d67619a9c24dec09e2ee99c0af420" alt="image" width="400" height="391" data-reactid="261"/></li><li data-reactid="262"><!-- react-text: 263 -->法线贴图: 将贴图数据复制给法线N <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/normal-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A22%3A58Z%2F-1%2Fhost%2F7ae0742678271df02115bb1bed9cde4a0ec84a10992490ff62939096a3b00607" alt="image" width="400" height="389" data-reactid="264"/></li><li data-reactid="265">高光贴图 类似法线贴图, 将贴图数据赋值给高光系数</li><li data-reactid="266">凹凸贴图 类似法线贴图, 不过存储的是物体表面的相对高度, 也是通过高度参数影响原始的法线方向达到凹凸效果; 效果不如法线贴图</li><li data-reactid="267"><!-- react-text: 268 -->光照贴图: 模拟阴影效果 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/light-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A15Z%2F-1%2Fhost%2F1b9a02ff6794da9dd29226cf09d82460406c92f4e44cfca532b22646e89df7a2" alt="image" width="400" height="389" data-reactid="269"/></li><li data-reactid="270"><!-- react-text: 271 -->环境贴图: 模拟物体的反光效果 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/env-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A29Z%2F-1%2Fhost%2Fe5935a030290a63bf27bed062175a75736021b35e1eef600b09dc99ef8ccb5fb" alt="image" width="400" height="313" data-reactid="272"/></li><li data-reactid="273"><!-- react-text: 274 -->立方环境贴图: 用六张图组成一个立方体, 将物体置于立方体中, 模拟全景效果 <!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/cube-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A23%3A52Z%2F-1%2Fhost%2F874ffa6f6b2d34c6885669db7c4cac62332c801971ce4d81d5a1a3ba4a824c2e" alt="image" width="400" height="272" data-reactid="275"/></li><li data-reactid="276">... ...</li></ul><h3 id="uv贴图" data-reactid="277"><a href="#uv%E8%B4%B4%E5%9B%BE" aria-hidden="true" data-reactid="278"><span class="icon icon-link" data-reactid="279"></span></a><!-- react-text: 280 -->UV贴图<!-- /react-text --></h3><p data-reactid="281">uv指2d图形的坐标名称, 在贴图时可以指定一个矩形的坐标; 可以指定放大缩小模式; 重复(repeat)模式等高级操作</p><img src="http://eux-blog-static.bj.bcebos.com/uv-map.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A24%3A13Z%2F-1%2Fhost%2F3b13b17cc4204b26de85a9a12cd7f12b6c2c86dba02917220347802746117431" alt="image" width="700" height="437" data-reactid="282"/><p data-reactid="283">[The uv coordinates are often used. However, we are using st coordinates because GLSL ES uses the component names to access the texture image.]</p><h2 id="webgl初始化流程及代码" data-reactid="284"><a href="#webgl%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%BB%A3%E7%A0%81" aria-hidden="true" data-reactid="285"><span class="icon icon-link" data-reactid="286"></span></a><!-- react-text: 287 -->webGL初始化流程及代码<!-- /react-text --></h2><ul data-reactid="288"><li data-reactid="289"><p data-reactid="290">获取webgl上下文</p><pre data-reactid="291"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="292"><span class="hljs-keyword" data-reactid="293">var</span><!-- react-text: 294 --> canvas = <!-- /react-text --><span class="hljs-built_in" data-reactid="295">document</span><!-- react-text: 296 -->.querySelector(<!-- /react-text --><span class="hljs-string" data-reactid="297">&#x27;#canvas&#x27;</span><!-- react-text: 298 -->);
gl = canvas.getContext(<!-- /react-text --><span class="hljs-string" data-reactid="299">&#x27;webgl&#x27;</span><!-- react-text: 300 -->);<!-- /react-text --></code></pre></li><li data-reactid="301"><p data-reactid="302">初始化视窗(viewport)</p><pre data-reactid="303"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="304"><!-- react-text: 305 -->gl.viewportWidth = canvas.width;
gl.viewportHeight = canvas.height;
gl.viewport(<!-- /react-text --><span class="hljs-number" data-reactid="306">0</span><!-- react-text: 307 -->, <!-- /react-text --><span class="hljs-number" data-reactid="308">0</span><!-- react-text: 309 -->, gl.viewportWidth, gl.viewportHeight);<!-- /react-text --></code></pre></li><li data-reactid="310"><p data-reactid="311">初始化顶点着色器(vertex shader)</p><pre data-reactid="312"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="313"><span class="hljs-keyword" data-reactid="314">var</span><!-- react-text: 315 --> vertexShader = gl.createShader(gl.VERTEX_SHADER);
<!-- /react-text --><span class="hljs-comment" data-reactid="316">// 这一步一般需要先load着色器源代码</span><!-- react-text: 317 -->
gl.shaderSource(vertexShader, <!-- /react-text --><span class="hljs-string" data-reactid="318">&#x27;attribute vec4 a_Position ......  // 顶点着色器内容&#x27;</span><!-- react-text: 319 -->);
gl.compileShader(vertexShader);
<!-- /react-text --><span class="hljs-comment" data-reactid="320">// 获取着色器编译状态, 如果出错则打印log信息并结束</span><!-- react-text: 321 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="322">if</span><!-- react-text: 323 --> (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        <!-- /react-text --><span class="hljs-built_in" data-reactid="324">console</span><!-- react-text: 325 -->.log(gl.getShaderInfoLog(vertexShader));
        <!-- /react-text --><span class="hljs-keyword" data-reactid="326">return</span><!-- react-text: 327 -->;
}<!-- /react-text --></code></pre></li><li data-reactid="328"><p data-reactid="329">初始化片段着色器(fragment shader)</p><pre data-reactid="330"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="331"><span class="hljs-keyword" data-reactid="332">var</span><!-- react-text: 333 --> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, <!-- /react-text --><span class="hljs-string" data-reactid="334">&#x27;varying vec4 v_Color ......  //片段着色器内容&#x27;</span><!-- react-text: 335 -->);
gl.compileShader(fragmentShader);
<!-- /react-text --><span class="hljs-keyword" data-reactid="336">if</span><!-- react-text: 337 --> (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        <!-- /react-text --><span class="hljs-built_in" data-reactid="338">console</span><!-- react-text: 339 -->.log(gl.getShaderInfoLog(fragmentShader));
        <!-- /react-text --><span class="hljs-keyword" data-reactid="340">return</span><!-- react-text: 341 -->;
}<!-- /react-text --></code></pre></li><li data-reactid="342"><p data-reactid="343">初始化程序(program)</p><pre data-reactid="344"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="345"><!-- react-text: 346 -->gl.program = gl.createProgram();
<!-- /react-text --><span class="hljs-comment" data-reactid="347">// 绑定着色器, 不同的&#x27;程序&#x27;可以绑定不同的着色器</span><!-- react-text: 348 -->
gl.attachShader(gl.program, vertexShader);
gl.attachShader(gl.program, fragmentShader);
<!-- /react-text --><span class="hljs-comment" data-reactid="349">// 链接程序</span><!-- react-text: 350 -->
gl.linkProgram(gl.program);
<!-- /react-text --><span class="hljs-comment" data-reactid="351">// 检查程序链接状态</span><!-- react-text: 352 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="353">if</span><!-- react-text: 354 --> (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {
         <!-- /react-text --><span class="hljs-built_in" data-reactid="355">console</span><!-- react-text: 356 -->.log(<!-- /react-text --><span class="hljs-string" data-reactid="357">&#x27;program link problem&#x27;</span><!-- react-text: 358 -->);
         <!-- /react-text --><span class="hljs-keyword" data-reactid="359">return</span><!-- react-text: 360 -->;
}<!-- /react-text --></code></pre></li><li data-reactid="361"><p data-reactid="362">使用程序(program)</p><pre data-reactid="363"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="364"><span class="hljs-comment" data-reactid="365">// 使用刚刚初始化好的程序, 可以创建多个program来使用</span><!-- react-text: 366 -->
gl.useProgram(gl.program);<!-- /react-text --></code></pre></li><li data-reactid="367"><p data-reactid="368">初始化顶点数组(vertex buffer)</p><pre data-reactid="369"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="370"><span class="hljs-comment" data-reactid="371">/**
 * initVertexBuffers: vertices, indices =&gt; n
 *     vertices: Float32Array    // 顶点数组,一般需要是有类型的特殊Array
 *     indices: Uint8Array       // 序号数组, 序号指顶点数组中的序号index
 *     n: number                 // 顶点数, indices.length
 */</span><!-- react-text: 372 -->            
gl.n = initVertexBuffers(vertices, indices);
<!-- /react-text --><span class="hljs-keyword" data-reactid="373">if</span><!-- react-text: 374 --> (gl.n &lt;= <!-- /react-text --><span class="hljs-number" data-reactid="375">0</span><!-- react-text: 376 -->) {
    <!-- /react-text --><span class="hljs-built_in" data-reactid="377">console</span><!-- react-text: 378 -->.log(&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="379">039</span><!-- react-text: 380 -->;fail to initialize vertex buffers&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="381">039</span><!-- react-text: 382 -->;);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="383">return</span><!-- react-text: 384 -->;
}<!-- /react-text --></code></pre><ul data-reactid="385"><li data-reactid="386"><p data-reactid="387">vertices &amp; indices</p><p data-reactid="388">表示顶点数组和序号数组, 如一个正方体的顶点数组</p><img src="http://eux-blog-static.bj.bcebos.com/cube-coordinate.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A25%3A04Z%2F-1%2Fhost%2F12b107edecdaa381bf201d0bfbefbaba4e9fe095b72d4f17077f4f792860a1af" alt="image" width="400" height="379" data-reactid="389"/><!-- react-text: 390 --> ```javascript /** * vertices数组, 前三个数字代表一个三维空间坐标点, 后三个数字代表颜色 * 下面例子里列出的内容表示一个正方体的正面(front)的坐标点 **/ var vertices = new Float32Array([ 1.0, 1.0, 1.0, 0.0, 0.0, -1.0, // v0 -1.0, 1.0, 1.0, 0.0, 0.0, -1.0, // v1 -1.0, -1.0, 1.0, 0.0, 0.0, -1.0, // v2 1.0, -1.0, 1.0, 0.0, 0.0, -1.0, // v3 front ... ... ]), ```<!-- /react-text --><pre data-reactid="391"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="392"><span class="hljs-comment" data-reactid="393">/**
 * indices数组, 0,1,2  0,2,3分别表示一个三角形, 两个三角形组成正方体的一个面
 * 三角形点的顺序要逆时针列出(右手定则), 顺序不对的话会被当成背对屏幕而不被渲染
 **/</span><!-- react-text: 394 -->     
<!-- /react-text --><span class="hljs-keyword" data-reactid="395">var</span><!-- react-text: 396 --> indices = <!-- /react-text --><span class="hljs-keyword" data-reactid="397">new</span><!-- react-text: 398 --> <!-- /react-text --><span class="hljs-built_in" data-reactid="399">Uint8Array</span><!-- react-text: 400 -->([
    <!-- /react-text --><span class="hljs-number" data-reactid="401">0</span><!-- react-text: 402 -->, <!-- /react-text --><span class="hljs-number" data-reactid="403">1</span><!-- react-text: 404 -->, <!-- /react-text --><span class="hljs-number" data-reactid="405">2</span><!-- react-text: 406 -->, <!-- /react-text --><span class="hljs-number" data-reactid="407">0</span><!-- react-text: 408 -->, <!-- /react-text --><span class="hljs-number" data-reactid="409">2</span><!-- react-text: 410 -->, <!-- /react-text --><span class="hljs-number" data-reactid="411">3</span><!-- react-text: 412 -->,           <!-- /react-text --><span class="hljs-comment" data-reactid="413">// front</span><!-- react-text: 414 -->
    <!-- /react-text --><span class="hljs-number" data-reactid="415">4</span><!-- react-text: 416 -->, <!-- /react-text --><span class="hljs-number" data-reactid="417">5</span><!-- react-text: 418 -->, <!-- /react-text --><span class="hljs-number" data-reactid="419">6</span><!-- react-text: 420 -->, <!-- /react-text --><span class="hljs-number" data-reactid="421">4</span><!-- react-text: 422 -->, <!-- /react-text --><span class="hljs-number" data-reactid="423">6</span><!-- react-text: 424 -->, <!-- /react-text --><span class="hljs-number" data-reactid="425">7</span><!-- react-text: 426 -->,           <!-- /react-text --><span class="hljs-comment" data-reactid="427">// right</span><!-- react-text: 428 -->
    <!-- /react-text --><span class="hljs-number" data-reactid="429">8</span><!-- react-text: 430 -->, <!-- /react-text --><span class="hljs-number" data-reactid="431">9</span><!-- react-text: 432 -->, <!-- /react-text --><span class="hljs-number" data-reactid="433">10</span><!-- react-text: 434 -->, <!-- /react-text --><span class="hljs-number" data-reactid="435">8</span><!-- react-text: 436 -->, <!-- /react-text --><span class="hljs-number" data-reactid="437">10</span><!-- react-text: 438 -->, <!-- /react-text --><span class="hljs-number" data-reactid="439">11</span><!-- react-text: 440 -->,        <!-- /react-text --><span class="hljs-comment" data-reactid="441">// up</span><!-- react-text: 442 -->
    <!-- /react-text --><span class="hljs-number" data-reactid="443">12</span><!-- react-text: 444 -->, <!-- /react-text --><span class="hljs-number" data-reactid="445">13</span><!-- react-text: 446 -->, <!-- /react-text --><span class="hljs-number" data-reactid="447">14</span><!-- react-text: 448 -->, <!-- /react-text --><span class="hljs-number" data-reactid="449">12</span><!-- react-text: 450 -->, <!-- /react-text --><span class="hljs-number" data-reactid="451">14</span><!-- react-text: 452 -->, <!-- /react-text --><span class="hljs-number" data-reactid="453">15</span><!-- react-text: 454 -->,     <!-- /react-text --><span class="hljs-comment" data-reactid="455">// left</span><!-- react-text: 456 -->
    <!-- /react-text --><span class="hljs-number" data-reactid="457">16</span><!-- react-text: 458 -->, <!-- /react-text --><span class="hljs-number" data-reactid="459">17</span><!-- react-text: 460 -->, <!-- /react-text --><span class="hljs-number" data-reactid="461">18</span><!-- react-text: 462 -->, <!-- /react-text --><span class="hljs-number" data-reactid="463">16</span><!-- react-text: 464 -->, <!-- /react-text --><span class="hljs-number" data-reactid="465">18</span><!-- react-text: 466 -->, <!-- /react-text --><span class="hljs-number" data-reactid="467">19</span><!-- react-text: 468 -->,     <!-- /react-text --><span class="hljs-comment" data-reactid="469">// down</span><!-- react-text: 470 -->
    <!-- /react-text --><span class="hljs-number" data-reactid="471">20</span><!-- react-text: 472 -->, <!-- /react-text --><span class="hljs-number" data-reactid="473">21</span><!-- react-text: 474 -->, <!-- /react-text --><span class="hljs-number" data-reactid="475">22</span><!-- react-text: 476 -->, <!-- /react-text --><span class="hljs-number" data-reactid="477">20</span><!-- react-text: 478 -->, <!-- /react-text --><span class="hljs-number" data-reactid="479">22</span><!-- react-text: 480 -->, <!-- /react-text --><span class="hljs-number" data-reactid="481">23</span><!-- react-text: 482 -->      <!-- /react-text --><span class="hljs-comment" data-reactid="483">// back              </span><!-- react-text: 484 -->
])<!-- /react-text --></code></pre></li><li data-reactid="485"><p data-reactid="486">initVertexBuffers</p><ul data-reactid="487"><li data-reactid="488"><p data-reactid="489">初始化buffer</p><pre data-reactid="490"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="491"><span class="hljs-keyword" data-reactid="492">var</span><!-- react-text: 493 --> vertexBuffer = gl.createBuffer();
<!-- /react-text --><span class="hljs-keyword" data-reactid="494">var</span><!-- react-text: 495 --> indexBuffer = gl.createBuffer();
<!-- /react-text --><span class="hljs-keyword" data-reactid="496">if</span><!-- react-text: 497 --> (!vertexBuffer || !indexBuffer) {
    <!-- /react-text --><span class="hljs-built_in" data-reactid="498">console</span><!-- react-text: 499 -->.log(&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="500">039</span><!-- react-text: 501 -->;fail to create buffer&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="502">039</span><!-- react-text: 503 -->;);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="504">return</span><!-- react-text: 505 -->;
}<!-- /react-text --></code></pre></li><li data-reactid="506"><p data-reactid="507">绑定buffer</p><pre data-reactid="508"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="509"><span class="hljs-comment" data-reactid="510">// 绑定vertexBuffer并填入值vertices</span><!-- react-text: 511 -->
<!-- /react-text --><span class="hljs-comment" data-reactid="512">// 注意!! 顶点的原始数据必须用gl.ARRAY_BUFFER存储</span><!-- react-text: 513 -->
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);<!-- /react-text --></code></pre><pre data-reactid="514"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="515"><span class="hljs-comment" data-reactid="516">// 绑定indexBuffer并填入值indices</span><!-- react-text: 517 -->
<!-- /react-text --><span class="hljs-comment" data-reactid="518">// 注意!! 顶点的index必须用gl.ELEMENT_ARRAY_BUFFER存储</span><!-- react-text: 519 -->
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);<!-- /react-text --></code></pre></li><li data-reactid="520"><p data-reactid="521">初始化Attributes</p><ul data-reactid="522"><li data-reactid="523"><p data-reactid="524">定义attributes数组</p><pre data-reactid="525"><code data-query="{}" data-lang="data-lang" data-reactid="526">attributes是vertices数组的结构定义, 必须跟vertices数组对应起来

- vertices结构

    &lt;img src=&quot;http://eux-blog-static.bj.bcebos.com/vertex-object-structure.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A25%3A28Z%2F-1%2Fhost%2F1359f6ce7d9adf4c7a93cd950c25d3126d6cc3d9a5a1959bd8e7c2cfbe708749&quot; alt=&quot;image&quot; width=&quot;550&quot; height=&quot;94&quot; /&gt;
    
    如图vertices数组中10个数字表示一个顶点, 分别表示坐标位置; 法向量方向; 贴图TEX0的坐标位置; 贴图TEX1的坐标位置

    这种vertices结构叫*Array of structure*, 通常用3D软件生成的顶点数据都是这个结构;也可以为position, normal, color每种数据都建立一个buffer, 这种结构叫*Structure of Array*

    ```javascript
    /**
     * 根据上面的结构定义的attributes
     * size表示当前attribute由几个元素组成, 范围大小是1~4
     * strip表示由几个元素代表一个顶点, 每个attribute都相同
     * offset表示从第几个元素开始查找, 这个要算之前的attribute占用了多少元素
     **/
    var attributes = [
        {name: &amp;#039;a_position&amp;#039;, size: 3, strip: 10, offset: 0},
        {name: &amp;#039;a_normal&amp;#039;, size: 3, strip: 10, offset: 3},
        {name: &amp;#039;a_tex0&amp;#039;, size: 2, strip: 10, offset: 6},
        {name: &amp;#039;a_tex1&amp;#039;, size: 2, strip: 10, offset: 8}
    ];
    ```

```javascript
// 根据正方体vertices数组定义的attributes结构
var attributes = [
    {name: &amp;#039;a_position&amp;#039;, size: 3, strip: 10, offset: 0},
    {name: &amp;#039;a_color&amp;#039;, size: 3, strip: 10, offset: 3}
];
```
</code></pre><pre data-reactid="527"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="528"><span class="hljs-comment" data-reactid="529">// 记录FSIZE, 即顶点数组每个元素的byte数, 后面需要使用</span><!-- react-text: 530 -->
gl.FSIZE = vertices.BYTES_PER_ELEMENT;
<!-- /react-text --><span class="hljs-comment" data-reactid="531">// 遍历attributes并初始化</span><!-- react-text: 532 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="533">for</span><!-- react-text: 534 -->(<!-- /react-text --><span class="hljs-keyword" data-reactid="535">var</span><!-- react-text: 536 --> i = <!-- /react-text --><span class="hljs-number" data-reactid="537">0</span><!-- react-text: 538 -->; i &lt; attributes.length; i++) {
    initAttributes(attributes[i]);
}<!-- /react-text --></code></pre></li><li data-reactid="539"><p data-reactid="540">initAttributes</p><pre data-reactid="541"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="542"><span class="hljs-comment" data-reactid="543">// 为attribute分配存储空间</span><!-- react-text: 544 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="545">var</span><!-- react-text: 546 --> a_Loc = gl.getAttribLocation(gl.program, attribute.name);
<!-- /react-text --><span class="hljs-comment" data-reactid="547">// a_Loc是分配的存储空间地址, 如果小于0表示分配失败</span><!-- react-text: 548 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="549">if</span><!-- react-text: 550 --> (a_Loc &lt; <!-- /react-text --><span class="hljs-number" data-reactid="551">0</span><!-- react-text: 552 -->) {
    <!-- /react-text --><span class="hljs-built_in" data-reactid="553">console</span><!-- react-text: 554 -->.log(&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="555">039</span><!-- react-text: 556 -->;fail to get location <!-- /react-text --><span class="hljs-keyword" data-reactid="557">of</span><!-- react-text: 558 -->&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="559">039</span><!-- react-text: 560 -->; + attr.name);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="561">return</span><!-- react-text: 562 -->;
}<!-- /react-text --></code></pre><pre data-reactid="563"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="564"><span class="hljs-comment" data-reactid="565">// 定义attribute查找规则</span><!-- react-text: 566 -->
gl.vertexAttribPointer(
    a_Loc,
    attribute.size,    <!-- /react-text --><span class="hljs-comment" data-reactid="567">// 3</span><!-- react-text: 568 -->
    gl.FLOAT,          <!-- /react-text --><span class="hljs-comment" data-reactid="569">// 数据类型</span><!-- react-text: 570 -->
    <!-- /react-text --><span class="hljs-literal" data-reactid="571">false</span><!-- react-text: 572 -->,             <!-- /react-text --><span class="hljs-comment" data-reactid="573">// 实际类型跟FLOAT不符时的处理, 这里符合所以false</span><!-- react-text: 574 -->
    gl.FSIZE * attribute.strip,    <!-- /react-text --><span class="hljs-comment" data-reactid="575">// 4 * 6</span><!-- react-text: 576 -->
    gl.FSIZE * attribute.offset   <!-- /react-text --><span class="hljs-comment" data-reactid="577">// 4 * (0 | 3)</span><!-- react-text: 578 -->
);
<!-- /react-text --><span class="hljs-comment" data-reactid="579">// enable分配的存储位置</span><!-- react-text: 580 -->
gl.enableVertexAttribArray(a_Loc);<!-- /react-text --></code></pre></li><li data-reactid="581"><p data-reactid="582">初始化Uniforms</p><pre data-reactid="583"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="584"><span class="hljs-comment" data-reactid="585">// 定义uniforms数组: 变量名, 类型, 地址, 值</span><!-- react-text: 586 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="587">var</span><!-- react-text: 588 --> uniforms = [
    {<!-- /react-text --><span class="hljs-attr" data-reactid="589">name</span><!-- react-text: 590 -->: &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="591">039</span><!-- react-text: 592 -->;u_b_direct_light&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="593">039</span><!-- react-text: 594 -->;, <!-- /react-text --><span class="hljs-attr" data-reactid="595">type</span><!-- react-text: 596 -->: &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="597">039</span><!-- react-text: 598 -->;b&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="599">039</span><!-- react-text: 600 -->;, <!-- /react-text --><span class="hljs-attr" data-reactid="601">location</span><!-- react-text: 602 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="603">null</span><!-- react-text: 604 -->, <!-- /react-text --><span class="hljs-attr" data-reactid="605">value</span><!-- react-text: 606 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="607">null</span><!-- react-text: 608 -->},
    {<!-- /react-text --><span class="hljs-attr" data-reactid="609">name</span><!-- react-text: 610 -->: &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="611">039</span><!-- react-text: 612 -->;u_MvpMatrix&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="613">039</span><!-- react-text: 614 -->;, <!-- /react-text --><span class="hljs-attr" data-reactid="615">type</span><!-- react-text: 616 -->: &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="617">039</span><!-- react-text: 618 -->;mat4&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="619">039</span><!-- react-text: 620 -->;, <!-- /react-text --><span class="hljs-attr" data-reactid="621">location</span><!-- react-text: 622 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="623">null</span><!-- react-text: 624 -->, <!-- /react-text --><span class="hljs-attr" data-reactid="625">value</span><!-- react-text: 626 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="627">null</span><!-- react-text: 628 -->},
    {<!-- /react-text --><span class="hljs-attr" data-reactid="629">name</span><!-- react-text: 630 -->: &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="631">039</span><!-- react-text: 632 -->;u_MvMatrix&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="633">039</span><!-- react-text: 634 -->;, <!-- /react-text --><span class="hljs-attr" data-reactid="635">type</span><!-- react-text: 636 -->: &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="637">039</span><!-- react-text: 638 -->;mat4&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="639">039</span><!-- react-text: 640 -->;, <!-- /react-text --><span class="hljs-attr" data-reactid="641">location</span><!-- react-text: 642 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="643">null</span><!-- react-text: 644 -->, <!-- /react-text --><span class="hljs-attr" data-reactid="645">value</span><!-- react-text: 646 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="647">null</span><!-- react-text: 648 -->},
    <!-- /react-text --><span class="hljs-comment" data-reactid="649">// ... ...</span><!-- react-text: 650 -->
]<!-- /react-text --></code></pre><pre data-reactid="651"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="652"><span class="hljs-comment" data-reactid="653">// 遍历uniforms并初始化</span><!-- react-text: 654 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="655">for</span><!-- react-text: 656 -->(<!-- /react-text --><span class="hljs-keyword" data-reactid="657">var</span><!-- react-text: 658 --> i = <!-- /react-text --><span class="hljs-number" data-reactid="659">0</span><!-- react-text: 660 -->; i &lt; uniforms.length; i++) {
    initUniforms(uniforms[i]);
}<!-- /react-text --></code></pre><ul data-reactid="661"><li data-reactid="662"><p data-reactid="663">initUniforms</p><pre data-reactid="664"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="665"><span class="hljs-comment" data-reactid="666">// 分配uniform存储空间</span><!-- react-text: 667 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="668">var</span><!-- react-text: 669 --> u_Loc = gl.getUniformLocation(gl.program, uniform.name);
<!-- /react-text --><span class="hljs-keyword" data-reactid="670">if</span><!-- react-text: 671 --> (u_Loc &lt; <!-- /react-text --><span class="hljs-number" data-reactid="672">0</span><!-- react-text: 673 -->) {
    <!-- /react-text --><span class="hljs-built_in" data-reactid="674">console</span><!-- react-text: 675 -->.log(&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="676">039</span><!-- react-text: 677 -->;fail to get location <!-- /react-text --><span class="hljs-keyword" data-reactid="678">of</span><!-- react-text: 679 --> u_MvpMatrix&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="680">039</span><!-- react-text: 681 -->;);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="682">return</span><!-- react-text: 683 -->;
}
<!-- /react-text --><span class="hljs-keyword" data-reactid="684">else</span><!-- react-text: 685 --> {
    uniform.location = u_Loc;
}<!-- /react-text --></code></pre></li><li data-reactid="686"><p data-reactid="687">updateUniforms</p><pre data-reactid="688"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="689"><span class="hljs-comment" data-reactid="690">/**
 * 给uniform赋值, 不同的类型对应不同的方法
 * 其中f表示float, i表示integer, v表示vector; 一般matrix和vector都是数组
 * gl.uniformxxxx的第一个参数是之前缓存的uniform地址
 * 第二个参数表示是否需要转置矩阵(横竖反转), webGL里不具有这个功能, 必须传false
 * 第三个参数是uniform值, 可以是数组或单个数字, 数字可以是float或inter类型
 * 具体内容需要跟前面的api对应起来
 **/</span><!-- react-text: 691 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="692">if</span><!-- react-text: 693 --> (uniform.value) {
    <!-- /react-text --><span class="hljs-keyword" data-reactid="694">try</span><!-- react-text: 695 --> {
        <!-- /react-text --><span class="hljs-keyword" data-reactid="696">switch</span><!-- react-text: 697 --> (uniform.type) {
            <!-- /react-text --><span class="hljs-keyword" data-reactid="698">case</span><!-- react-text: 699 --> &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="700">039</span><!-- react-text: 701 -->;mat4&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="702">039</span><!-- react-text: 703 -->;:
                gl.uniformMatrix4fv(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="704">false</span><!-- react-text: 705 -->, uniform.value);
                <!-- /react-text --><span class="hljs-keyword" data-reactid="706">break</span><!-- react-text: 707 -->;
            <!-- /react-text --><span class="hljs-keyword" data-reactid="708">case</span><!-- react-text: 709 --> &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="710">039</span><!-- react-text: 711 -->;mat3&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="712">039</span><!-- react-text: 713 -->;:
                gl.uniformMatrix3fv(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="714">false</span><!-- react-text: 715 -->, uniform.value);
                <!-- /react-text --><span class="hljs-keyword" data-reactid="716">break</span><!-- react-text: 717 -->;
            <!-- /react-text --><span class="hljs-keyword" data-reactid="718">case</span><!-- react-text: 719 --> &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="720">039</span><!-- react-text: 721 -->;vec4&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="722">039</span><!-- react-text: 723 -->;:
                gl.uniformVec4fv(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="724">false</span><!-- react-text: 725 -->, uniform.value);
                <!-- /react-text --><span class="hljs-keyword" data-reactid="726">break</span><!-- react-text: 727 -->;
            <!-- /react-text --><span class="hljs-keyword" data-reactid="728">case</span><!-- react-text: 729 --> &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="730">039</span><!-- react-text: 731 -->;vec3&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="732">039</span><!-- react-text: 733 -->;:
                gl.uniformVec3fv(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="734">false</span><!-- react-text: 735 -->, uniform.value);
                <!-- /react-text --><span class="hljs-keyword" data-reactid="736">break</span><!-- react-text: 737 -->;
            <!-- /react-text --><span class="hljs-keyword" data-reactid="738">case</span><!-- react-text: 739 --> &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="740">039</span><!-- react-text: 741 -->;f&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="742">039</span><!-- react-text: 743 -->;:
                <!-- /react-text --><span class="hljs-keyword" data-reactid="744">if</span><!-- react-text: 745 --> (uniform.value.length) {
                    gl.uniform1fv(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="746">false</span><!-- react-text: 747 -->, uniform.value);
                }
                <!-- /react-text --><span class="hljs-keyword" data-reactid="748">else</span><!-- react-text: 749 --> {
                    gl.uniform1f(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="750">false</span><!-- react-text: 751 -->, uniform.value);
                }
                <!-- /react-text --><span class="hljs-keyword" data-reactid="752">break</span><!-- react-text: 753 -->;
            <!-- /react-text --><span class="hljs-keyword" data-reactid="754">case</span><!-- react-text: 755 --> &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="756">039</span><!-- react-text: 757 -->;i&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="758">039</span><!-- react-text: 759 -->;:
                <!-- /react-text --><span class="hljs-keyword" data-reactid="760">if</span><!-- react-text: 761 --> (uniform.value.length) {
                    gl.uniform1iv(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="762">false</span><!-- react-text: 763 -->, uniform.value);
                }
                <!-- /react-text --><span class="hljs-keyword" data-reactid="764">else</span><!-- react-text: 765 --> {
                    gl.uniform1i(uniform.location, <!-- /react-text --><span class="hljs-literal" data-reactid="766">false</span><!-- react-text: 767 -->, uniform.value);
                }
                <!-- /react-text --><span class="hljs-keyword" data-reactid="768">break</span><!-- react-text: 769 -->;
        }
    }
}<!-- /react-text --></code></pre></li></ul></li></ul></li></ul></li></ul></li><li data-reactid="770"><p data-reactid="771">初始化纹理(texture)</p><pre data-reactid="772"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="773"><span class="hljs-comment" data-reactid="774">// 如果需要使用纹理</span><!-- react-text: 775 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="776">if</span><!-- react-text: 777 --> (!initTextures(imageSrc)) {
    <!-- /react-text --><span class="hljs-built_in" data-reactid="778">console</span><!-- react-text: 779 -->.log(&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="780">039</span><!-- react-text: 781 -->;fail to initialize texture&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="782">039</span><!-- react-text: 783 -->;);
}<!-- /react-text --></code></pre><ul data-reactid="784"><li data-reactid="785"><p data-reactid="786">initTextures</p><pre data-reactid="787"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="788"><span class="hljs-comment" data-reactid="789">// 创建texture</span><!-- react-text: 790 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="791">var</span><!-- react-text: 792 --> texture = gl.createTexture();
<!-- /react-text --><span class="hljs-keyword" data-reactid="793">if</span><!-- react-text: 794 --> (!texture) {
    <!-- /react-text --><span class="hljs-built_in" data-reactid="795">console</span><!-- react-text: 796 -->.log(&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="797">039</span><!-- react-text: 798 -->;fail to create texture&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="799">039</span><!-- react-text: 800 -->;);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="801">return</span><!-- react-text: 802 -->;
}<!-- /react-text --></code></pre><pre data-reactid="803"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="804"><span class="hljs-comment" data-reactid="805">// 为u_Sampler分配空间, texture会是u_Sampler的值</span><!-- react-text: 806 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="807">var</span><!-- react-text: 808 --> u_Sampler = gl.getUniformLocation(gl.program, &amp;#<!-- /react-text --><span class="hljs-number" data-reactid="809">039</span><!-- react-text: 810 -->;u_Sampler&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="811">039</span><!-- react-text: 812 -->;);
<!-- /react-text --><span class="hljs-keyword" data-reactid="813">if</span><!-- react-text: 814 --> (u_Sampler &lt; <!-- /react-text --><span class="hljs-number" data-reactid="815">0</span><!-- react-text: 816 -->) {
    <!-- /react-text --><span class="hljs-built_in" data-reactid="817">console</span><!-- react-text: 818 -->.log(&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="819">039</span><!-- react-text: 820 -->;fail to get location <!-- /react-text --><span class="hljs-keyword" data-reactid="821">of</span><!-- react-text: 822 --> u_Sampler&amp;#<!-- /react-text --><span class="hljs-number" data-reactid="823">039</span><!-- react-text: 824 -->;);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="825">return</span><!-- react-text: 826 -->;
}<!-- /react-text --></code></pre><pre data-reactid="827"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="828"><span class="hljs-comment" data-reactid="829">// 加载图片并loadTexture</span><!-- react-text: 830 -->
<!-- /react-text --><span class="hljs-keyword" data-reactid="831">var</span><!-- react-text: 832 --> image = <!-- /react-text --><span class="hljs-keyword" data-reactid="833">new</span><!-- react-text: 834 --> Image();
image.src = <!-- /react-text --><span class="hljs-built_in" data-reactid="835">require</span><!-- react-text: 836 -->(imageSrc);
image.onload = <!-- /react-text --><span class="hljs-function" data-reactid="837"><span class="hljs-keyword" data-reactid="838">function</span><!-- react-text: 839 -->(<!-- /react-text --><span class="hljs-params" data-reactid="840"></span><!-- react-text: 841 -->) <!-- /react-text --></span><!-- react-text: 842 -->{
    loadTexture(texture, u_Sampler, image);
};<!-- /react-text --></code></pre><ul data-reactid="843"><li data-reactid="844"><p data-reactid="845">loadTexture</p><pre data-reactid="846"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="847"><span class="hljs-comment" data-reactid="848">/**
 * 翻转图片的Y坐标; 1表示enable前面的配置项
 * 因为贴图的uv(或st)坐标系跟html的xy坐标系, y轴方向正好相反
 * 所以之后要使用贴图的uv坐标通常需要这步操作
 **/</span><!-- react-text: 849 -->
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, <!-- /react-text --><span class="hljs-number" data-reactid="850">1</span><!-- react-text: 851 -->);<!-- /react-text --></code></pre><pre data-reactid="852"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="853"><span class="hljs-comment" data-reactid="854">/**
 * 一个program最多可以使用8个贴图, 从gl.TEXTURE0 到 gl.TEXTURE7
 * 这里只用了一个所以只active TEXTURE0
 **/</span><!-- react-text: 855 -->
gl.activeTexture(gl.TEXTURE0);<!-- /react-text --></code></pre><pre data-reactid="856"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="857"><span class="hljs-comment" data-reactid="858">/**
 * 绑定texture, 这一步是要告诉webGL texture的类型
 * 除了立方体贴图要用gl.TEXTURE_CUBE_MAP, 其它的基本都用gl.TEXTURE_2D
 **/</span><!-- react-text: 859 -->
gl.bindTexture(gl.TEXTURE_2D, texture);<!-- /react-text --></code></pre><pre data-reactid="860"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="861"><span class="hljs-comment" data-reactid="862">/**
 * 这一步设置应用贴图时的参数, 第一个参数指定贴图类型(2d或cude)
 * 后面两个参数分别是贴图处理方法(funcName)和对应的值(funcValue)
 * 后面详细介绍
 **/</span><!-- react-text: 863 -->
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);<!-- /react-text --></code></pre><ul data-reactid="864"><li data-reactid="865"><p data-reactid="866">texPrameter - funcName</p><pre data-reactid="867"><code data-query="{}" data-lang="data-lang" data-reactid="868">gl.TEXTURE_MAG_FILTER: 放大策略; 当贴图大小比目标区域小的时候的放大策略, 可以使用gl.NEAREST和gl.LINEAR两个值

gl.TEXTURE_MIN_FILTER: 缩小策略: 当贴图大小比目标区域大时的缩小策略, 可以使用gl.NEAREST和gl.LINEAR及MIPMAP的所有值

gl.TEXTURE_WRAP_S: s轴(横轴)填充策略: 可以使用REPEAT, MIRRORED_REPEAT, CLAMP_TO_EDGE三种策略, 默认REPEAT

gl.TEXTURE_WRAP_T: t轴(纵轴)填充策略: 可以使用REPEAT, MIRRORED_REPEAT, CLAMP_TO_EDGE三种策略, 默认REPEAT
</code></pre></li><li data-reactid="869"><p data-reactid="870">texPrameter - funcValue</p><pre data-reactid="871"><code data-query="{}" data-lang="data-lang" data-reactid="872">```
gl.NEAREST: 取与目标像素几何距离最近的点

gl.LINEAR: 取与目标像素距离最近的四个点做权重平均(or bilinear fetch); 一般比NEAREST更清晰, 但更花时间

MIPMAP ———— 把贴图标准化为类似16x16, 32x32, 64x64等一系列图片, 然后根据目标区域大小选取相应的图片处理; 使用MIPMAP的话后面需要手工加载不同级别的图片

    gl.NEAREST_MIPMAP_NEAREST: 取一个跟目标区域最相近的图片, 然后再用NEAREST选一个最近的点

    gl.LINEAR_MIPMAP_NEAREST: 取一个跟目标区域最相近的图片, 然后再用LINEAR的方式算出点

    gl.NEAREST_MIPMAP_LINEAR: 取跟目标区域大小最相近的较大较小两个图片, 然后做插值算出点

    gl.LINEAR_MIPMAP_LINEAR: 先取最相近的两个图片分别做LINEAR(bilinear fetch)算出两个点, 然后再做插值算出目标点; 这种方式叫: trilinear filtering, 是所有方式中质量最高的

gl.REPEAT: 复制

gl.MIRRORED_REPEAT: 镜像复制

gl.CLAMP_TO_EDGE: 用贴图的边缘颜色填充
```
</code></pre><pre data-reactid="873"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="874"><span class="hljs-comment" data-reactid="875">/**</span></code></pre></li></ul><ul data-reactid="876"><li data-reactid="877"><p data-reactid="878">将图片绑定到texture对象上, 第一个参数指定贴图类型(2d或cube)</p></li><li data-reactid="879"><p data-reactid="880">第二个参数指定MIPMAP级别, 不使用时默认传0, 如果使用MIPMAP则需要绑定0~n不同级别的图片</p></li><li data-reactid="881"><p data-reactid="882">第三个参数指定图片像素的数据类型, 有RGB, RGBA, ALPHA, LUMINANCE, LUMINANCE_ALPHA几种</p></li><li data-reactid="883"><p data-reactid="884">第四个参数指定贴图像素被使用时的数据类型, 需要跟第三个参数保持相同</p></li><li data-reactid="885"><p data-reactid="886">第五个参数指定贴图像素的数据类型, 有</p></li><li data-reactid="887"><p data-reactid="888">UNSIGNED_BYTE: 每个部分占1byte</p></li><li data-reactid="889"><p data-reactid="890">UNSIGNED_SHORT_5_6_5: RGB类型且分别占5,6,5 bits</p></li><li data-reactid="891"><p data-reactid="892">UNSIGNED_SHORT_4_4_4_4: RGBA类型且分别占4bits</p></li><li data-reactid="893"><p data-reactid="894">UNSIGNED_SHORT_5_5_5_1: RGBA类型前三个占4bits, 最后alpha占1bits</p></li><li data-reactid="895"><p data-reactid="896">最后一个参数是加载的image对象 **/ gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);</p><pre data-reactid="897"><code data-query="{}" data-lang="data-lang" data-reactid="898">```javascript
/**
</code></pre></li><li data-reactid="899"><p data-reactid="900">给之前分配空间的uniform: u_Sampler赋值</p></li><li data-reactid="901"><p data-reactid="902">这一步跟普通的uniform赋值一样, 只是后面的0对应gl.TEXTURE0</p></li><li data-reactid="903"><p data-reactid="904">如果之前绑定的是TEXTUREn这里需要传n</p></li><li data-reactid="905"><p data-reactid="906">在片段着色器中的声明方式:</p></li><li data-reactid="907"><p data-reactid="908">uniform sampler2D u_Sampler;</p></li><li data-reactid="909"><p data-reactid="910">如果是立方体贴图需要把sampler2D改成samplerCube **/ gl.uniform1i(u_Sampler, 0);</p><pre data-reactid="911"><code data-query="{}" data-lang="data-lang" data-reactid="912"></code></pre></li></ul></li></ul></li></ul></li><li data-reactid="913"><p data-reactid="914">开启深度检测(depth test)</p><pre data-reactid="915"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="916"><span class="hljs-comment" data-reactid="917">// 一般需要开启深度检测</span><!-- react-text: 918 -->
gl.enable(gl.DEPTH_TEST);<!-- /react-text --></code></pre></li><li data-reactid="919"><p data-reactid="920">开启其它可选的后处理</p><pre data-reactid="921"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="922"><!-- react-text: 923 -->gl.enable(gl.BLEND);
gl.enable(gl.STENCIL_TEST);
<!-- /react-text --><span class="hljs-comment" data-reactid="924">// ... ...</span><!-- react-text: 925 -->
<!-- /react-text --><span class="hljs-comment" data-reactid="926">// 除了enable之外一般还需要设置其它相关参数和方法, 如</span><!-- react-text: 927 -->
<!-- /react-text --><span class="hljs-comment" data-reactid="928">// gl.blendFunc(... ....);</span><!-- react-text: 929 -->
<!-- /react-text --><span class="hljs-comment" data-reactid="930">// gl.stencilFunc(... ....);</span></code></pre></li><li data-reactid="931"><p data-reactid="932">初始化颜色及buffer</p><pre data-reactid="933"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="934"><span class="hljs-comment" data-reactid="935">// 清空颜色</span><!-- react-text: 936 -->
gl.clearColor(<!-- /react-text --><span class="hljs-number" data-reactid="937">0.0</span><!-- react-text: 938 -->, <!-- /react-text --><span class="hljs-number" data-reactid="939">0.0</span><!-- react-text: 940 -->, <!-- /react-text --><span class="hljs-number" data-reactid="941">0.0</span><!-- react-text: 942 -->, <!-- /react-text --><span class="hljs-number" data-reactid="943">1.0</span><!-- react-text: 944 -->);<!-- /react-text --></code></pre><pre data-reactid="945"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="946"><span class="hljs-comment" data-reactid="947">// 清空buffer, 如果使用了stencilTest, 需要清空 gl.STENCIL_BUFFER_BIT</span><!-- react-text: 948 -->
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);<!-- /react-text --></code></pre></li></ul><h2 id="webgl渲染流程及代码" data-reactid="949"><a href="#webgl%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%BB%A3%E7%A0%81" aria-hidden="true" data-reactid="950"><span class="icon icon-link" data-reactid="951"></span></a><!-- react-text: 952 -->webGL渲染流程及代码<!-- /react-text --></h2><ul data-reactid="953"><li data-reactid="954"><p data-reactid="955">跟进用户交互及时间等参数更新uniform值 (参考updateUniforms)</p></li><li data-reactid="956"><p data-reactid="957">清空buffer (参考初始化颜色及buffer)</p></li><li data-reactid="958"><p data-reactid="959">绘制图形</p><ul data-reactid="960"><li data-reactid="961"><p data-reactid="962">drawElements: 使用的是之前初始化的indexBuffer (参考绑定vertexBuffer)</p><pre data-reactid="963"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="964"><span class="hljs-comment" data-reactid="965">/**
 * 第一个参数表示绘制的图元mode, 后面有详细介绍
 * 第二个参数表示需要绘制的顶点序号数量, 这里绘制全部所以是gl.n
 * 第三个参数表示存储的顶点序号的数据类型, 有gl.UNSIGNED_BYTE | gl.UNSIGNED_SHORT两种
 * 对应js里Uint8Array | Uint16Array两种数据定义
 * 第四个参数是offset, 从indexBuffer的第几个元素开始绘制
 **/</span><!-- react-text: 966 -->
gl.drawElements(gl.TRIANGLES, gl.n, gl.UNSIGNED_BYTE, <!-- /react-text --><span class="hljs-number" data-reactid="967">0</span><!-- react-text: 968 -->);        <!-- /react-text --></code></pre></li><li data-reactid="969"><p data-reactid="970">drawArrays: 使用的是之前初始化的vertexBuffer, 即顶点原始数据 (参考绑定indexBuffer)</p><pre data-reactid="971"><code data-query="{}" data-lang="data-lang" data-reactid="972">```javascript
/**
 * 第一个参数表示绘制的图元mode, 后面有详细介绍
 * 第二个参数是offset, 从vertexBuffer的第几个元素开始绘制
 * 第三个参数表示需要绘制的顶点序号数量
 **/
gl.drawArrays(gl.TRIANGLE_STRIP, 0, gl.n);
```
</code></pre><p data-reactid="973">drawArrays跟drawElement不同的是它只能顺序的使用vertexBuffer的顶点, 不能指定序号;</p><p data-reactid="974">因为3D建模工具导出的数据一般都会有顶点的复用, 不能顺序使用, 所以一般复杂模型都会使用indexBuffer绘制</p></li><li data-reactid="975"><p data-reactid="976">draw mode:</p><img src="http://eux-blog-static.bj.bcebos.com/draw-mode.png?authorization=bce-auth-v1%2Fcb0c7cb965b444ee8bc9e75e45308734%2F2017-12-13T08%3A26%3A27Z%2F-1%2Fhost%2Fbc9d30732869b61a5375c171fd63875c2bce7e65fa6ea3f522bb434408aeec56" alt="image" width="700" height="424" data-reactid="977"/><pre data-reactid="978"><code data-query="{}" data-lang="data-lang" data-reactid="979">gl.POINTS: 根据使用的是vertexBuffer还是indexBuffer, 顺序的画点

gl.LINES: 以v0-v1, v2-v3, v4-v5,的顺序画线

gl.LINE_STRIP: 以v0-v1-v2-v3-v4-v5的顺序画整条线

gl.LINE_LOOP: 以v0-v1-v2-v3-v4-v5-v0的顺序连接起点和终点

gl.TRIANGLES: 以v0-v1-v2, v3-v4-v5的顺序画三角形

gl.TRIANGLES_STRIP: 以v0-v1-v2, v2-v1-v3, v2-v3-v4, v4-v3-v5的顺序画连续的三角形

gl.TRIANGLES_FAN: 以v0-v1-v2, v0-v2-v3, v0-v3-v4, v0-v4-v5的顺序画扇形的三角形
</code></pre></li></ul></li></ul><h2 id="一些后续学习内容" data-reactid="980"><a href="#%E4%B8%80%E4%BA%9B%E5%90%8E%E7%BB%AD%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9" aria-hidden="true" data-reactid="981"><span class="icon icon-link" data-reactid="982"></span></a><!-- react-text: 983 -->一些后续学习内容:<!-- /react-text --></h2><ul data-reactid="984"><li data-reactid="985">理解和灵活运用 (坐标变换 &amp;图形变换) 部分的矩阵变换公式和api</li><li data-reactid="986">(光照 &amp;材质) 相关的高级光照效果</li><li data-reactid="987">(纹理贴图) 相关的高级贴图效果及uv贴图应用</li><li data-reactid="988"><!-- react-text: 989 -->顶点着色器和片段着色器的使用, <!-- /react-text --><a href="https://www.shadertoy.com/" data-reactid="990">shadertoy</a><!-- react-text: 991 --> 上有大量着色器可以参考<!-- /react-text --></li><li data-reactid="992">一些高级效果, 如阴影, 反射, 雾, 使用多个gl program, 用户键盘及鼠标交互, 动画及骨架原理等等... ...</li><li data-reactid="993">如何转换并使用3d建模工具(如blender)导出的模型相关数据</li></ul><h2 id="参考资料" data-reactid="994"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" aria-hidden="true" data-reactid="995"><span class="icon icon-link" data-reactid="996"></span></a><!-- react-text: 997 -->参考资料:<!-- /react-text --></h2><ul data-reactid="998"><li data-reactid="999">WebGL Programming Guide (webGL编程指南)</li><li data-reactid="1000">OpenGL ES 2.0 Programming Guide (OpenGL ES 2.0编程指南)</li><li data-reactid="1001"><a href="https://threejs.org/" data-reactid="1002">threejs</a><!-- react-text: 1003 --> 例子, 教程, 源码学习<!-- /react-text --></li></ul></article><div data-reactid="1004"></div><nav class="single-bar clearfix" data-reactid="1005"><span class="prev" data-reactid="1006"><a rel="prev" href="/blog/fe/how-to-write-babel-plugin" data-reactid="1007"><em class="eux-icon eux-icon-page-prev" data-reactid="1008"></em><!-- react-text: 1009 -->从零开始写Babel插件<!-- /react-text --></a></span><span class="next" data-reactid="1010"><a rel="next" href="/blog/fe/利用-javascript-实现富文本编辑器" data-reactid="1011"><em class="eux-icon eux-icon-page-next" data-reactid="1012"></em><!-- react-text: 1013 -->利用 javascript 实现富文本编辑器<!-- /react-text --></a></span></nav></div></div></div><footer class="footer" data-reactid="1014"><div class="eux-footer-area-wrapper container-singular" role="complementary" data-reactid="1015"><div class="inner clearfix" data-reactid="1016"><aside id="simple-links-2" class="widget sl-links-main" data-reactid="1017"><h2 class="widgettitle" data-reactid="1018">友情链接</h2><ul class="simple-links-list simple-links-2-list" id="simple-links-2-list" data-reactid="1019"><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="1020"><a target="_blank" href="http://sux.baidu.com/" title="百度 FEX 团队" data-reactid="1021">百度 FEX</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="1022"><a target="_blank" href="http://efe.baidu.com/" title="百度 EFE 团队" data-reactid="1023">百度 EFE</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="1024"><a target="_blank" href="http://sux.baidu.com/" title="百度 SUX 团队" data-reactid="1025">百度 SUX</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="1026"><a target="_blank" href="https://aotu.io/" title="京东凹凸实验室，面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。" data-reactid="1027">凹凸实验室</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="1028"><a target="_blank" href="https://fed.renren.com/" title="人人网FED" data-reactid="1029">人人网FED</a></li></ul></aside></div></div><div class="eux-icp" data-reactid="1030"><!-- react-text: 1031 -->百度EUX 版权所有 ©百度EUX    All rights reserved. 骄傲地采用 <!-- /react-text --><a target="_blank" href="https://github.com/picidaejs/picidaejs" data-reactid="1032">Picidae</a><!-- react-text: 1033 -->。<!-- /react-text --></div></footer></div>
</div>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>