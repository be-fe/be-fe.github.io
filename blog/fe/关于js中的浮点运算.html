<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 关于 js 中的浮点计算 | 百度EUX </title>
    <link rel="stylesheet" href="/style.css">
    <script>
      (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?d232748d06c1fe09a6db3db0077669b7";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();

      var _vds = _vds || [];
      window._vds = _vds;
      (function () {
        _vds.push(['setAccountId', '66707fb8b27442d5b3ccca57a56800fa']);
        _vds.push(['trackBot', false]);

        (function () {
          var vds = document.createElement('script');
          vds.type = 'text/javascript';
          vds.async = true;
          vds.src = '//dn-growing.qbox.me/vds.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(vds, s);
        })();
      })();
    </script>
</head>
<body>
<div id="root">
    <div class="main" data-reactroot="" data-reactid="1" data-react-checksum="1735004733"><!-- react-empty: 2 --><header class="eux-header clearfix" data-reactid="3"><div class="eux-header-top" data-reactid="4"><a href="javascript:void(0);" class="eux-portable-menu" data-reactid="5"><span data-reactid="6"></span><span data-reactid="7"></span><span data-reactid="8"></span></a><!-- react-empty: 9 --><nav class="menu-primary-container" data-reactid="10"><ul id="menu-primary" class="menu" data-reactid="11"><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-25" data-reactid="12"><a href="/" data-reactid="13">HOME</a></li><li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-ancestor current-menu-parent menu-item-has-children menu-item-45" data-reactid="14"><a href="/" data-reactid="15">BLOG</a><ul class="sub-menu" data-reactid="16"><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="17"><a href="/ue" data-reactid="18">交互</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="19"><a href="/ui" data-reactid="20">视觉</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="21"><a href="/fe" data-reactid="22">前端</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-menu-item menu-item-63" data-reactid="23"><a href="/team" data-reactid="24">团队</a></li></ul></li><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-46" data-reactid="25"><a href="/tools" data-reactid="26">TOOLS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-112" data-reactid="27"><a href="/works" data-reactid="28">WORKS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-138" data-reactid="29"><a href="/jobs" data-reactid="30">JOBS</a></li><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-50" data-reactid="31"><a href="/about-us" data-reactid="32">ABOUT US</a></li></ul></nav></div></header><div class="eux-singular clearfix" data-reactid="33"><div class="container-singular clearfix" data-reactid="34"><nav class="menu-categories-container" data-reactid="35"><ul id="menu-categories" class="menu" data-reactid="36"><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="37"><span data-reactid="38"><a href="/" data-reactid="39">全部</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="40"><span data-reactid="41"><a href="/ue" data-reactid="42">交互</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="43"><span data-reactid="44"><a href="/ui" data-reactid="45">视觉</a></span></li><li class="current-menu-item menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="46"><span data-reactid="47"><a href="/fe" data-reactid="48">前端</a></span></li><li class="menu-item menu-item-type-custom menu-item-object-custom current_page_item menu-item-55" data-reactid="49"><span data-reactid="50"><a href="/team" data-reactid="51">团队</a></span></li></ul></nav><div class="inner clearfix" data-reactid="52"><div class="article-meta" data-reactid="53"><h1 class="title" data-reactid="54">关于 js 中的浮点计算</h1><div class="eux-page-detail" data-reactid="55"><span data-reactid="56"><em data-reactid="57">by.</em><!-- react-text: 58 -->陈蔓青<!-- /react-text --></span><span data-reactid="59">2018-3-21</span></div></div><article data-reactid="60"><blockquote data-reactid="61"><p data-reactid="62">😄 阅读本文需要的：</p><ul data-reactid="63"><li data-reactid="64">能将十进制的整数或小数换算成二进制且知道原理</li><li data-reactid="65">知道原码补码反码，且掌握二进制的加减</li><li data-reactid="66">有好奇心有耐心</li></ul></blockquote><p data-reactid="67"><!-- react-text: 68 -->前几天偶然跟人家聊到 <!-- /react-text --><code data-reactid="69">javascript</code><!-- react-text: 70 --> 有一个很好玩的事情， <!-- /react-text --><code data-reactid="71">0.1 + 0.2 = 0.30000000000000004</code><!-- react-text: 72 -->。稍微有经验大概能反应出来这是存储时数据长度截取产生的原因，但是具体是计算机怎么计算的呢，自己也解释不清，于是带着好奇稍微探索了一下。 （ps：实际上并不是只有 <!-- /react-text --><code data-reactid="73">javascript</code><!-- react-text: 74 --> 存在这种问题，具体可以看看 <!-- /react-text --><a href="http://0.30000000000000004.com/" data-reactid="75">http://0.30000000000000004.com/</a><!-- react-text: 76 --> 这个网站。）<!-- /react-text --></p><h2 id="浮点数在计算机中的存储" data-reactid="77"><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8" aria-hidden="true" data-reactid="78"><span class="icon icon-link" data-reactid="79"></span></a><!-- react-text: 80 -->浮点数在计算机中的存储<!-- /react-text --></h2><h3 id="ieee标准" data-reactid="81"><a href="#ieee%E6%A0%87%E5%87%86" aria-hidden="true" data-reactid="82"><span class="icon icon-link" data-reactid="83"></span></a><!-- react-text: 84 -->IEEE标准<!-- /react-text --></h3><p data-reactid="85"><!-- react-text: 86 -->首先科普一下 js 中使用的二进制浮点数算术标准 <!-- /react-text --><a href="https://zh.wikipedia.org/zh-hans/IEEE_754" data-reactid="87">IEEE_754</a><!-- react-text: 88 --> 他采用的存储格式为：<!-- /react-text --></p><pre data-reactid="89"><code class="hljs language-mathjax" data-query="{}" data-lang="mathjax" data-reactid="90"><!-- react-text: 91 -->E =  (<!-- /react-text --><span class="hljs-number" data-reactid="92">-1</span><!-- react-text: 93 -->)^<!-- /react-text --><span class="hljs-number" data-reactid="94">1</span><!-- react-text: 95 --> × M × <!-- /react-text --><span class="hljs-number" data-reactid="96">2</span><!-- react-text: 97 -->^E<!-- /react-text --></code></pre><ul data-reactid="98"><li data-reactid="99">(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。</li><li data-reactid="100">M表示有效数字，大于等于1，小于2。</li><li data-reactid="101">2^E表示指数位。</li></ul><p data-reactid="102">举例来说，十进制的 5.0，写成二进制是 101.0，相当于 1.01×2^2。那么，按照上面 V 的格式，可以得出 s=0，M=1.01，E=2。 十进制的 -5.0，写成二进制是 -101.0，相当于 -1.01×2^2。那么，s = 1，M = 1.01，E = 2。</p><h3 id="存储格式" data-reactid="103"><a href="#%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F" aria-hidden="true" data-reactid="104"><span class="icon icon-link" data-reactid="105"></span></a><!-- react-text: 106 -->存储格式<!-- /react-text --></h3><p data-reactid="107">对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p><p data-reactid="108"><!-- react-text: 109 -->￼<!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/2018-03-18-17-58-24.png" data-reactid="110"/></p><p data-reactid="111">对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><p data-reactid="112"><!-- react-text: 113 -->￼<!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/2018-03-18-17-58-42.png" data-reactid="114"/></p><p data-reactid="115">这里只简单说一下第一种情况存储时的一些点：</p><h4 id="尾数-m" data-reactid="116"><a href="#%E5%B0%BE%E6%95%B0-m" aria-hidden="true" data-reactid="117"><span class="icon icon-link" data-reactid="118"></span></a><!-- react-text: 119 -->尾数 M<!-- /react-text --></h4><p data-reactid="120"><!-- react-text: 121 -->IEEE 754规定，在 <!-- /react-text --><strong data-reactid="122">计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分</strong><!-- react-text: 123 --> 。比如保存 1.01 的时候，只保存 01，等到读取的时候，再把第一位的 1 加上去。这样做的目的，是节省 1 位有效数字。以 32 位浮点数为例，留给 M 只有 23 位，将第一位的 1 舍去以后，等于可以保存 24位有效数字。<!-- /react-text --></p><h4 id="指数e" data-reactid="124"><a href="#%E6%8C%87%E6%95%B0e" aria-hidden="true" data-reactid="125"><span class="icon icon-link" data-reactid="126"></span></a><!-- react-text: 127 -->指数E<!-- /react-text --></h4><p data-reactid="128">指数 E 的情况稍微复杂一点点。</p><p data-reactid="129"><!-- react-text: 130 -->首先，E为一个无符号整数）。这意味着，如果 E 为 8 位，它的取值范围为 0~255；如果 E 为 11 位，它的取值范围为 0~2047。但是，我们知道，科学计数法中的 E 是可以出现负数的，所以 <!-- /react-text --><strong data-reactid="131">IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023</strong><!-- react-text: 132 -->。<!-- /react-text --></p><p data-reactid="133">比如，2^10 的 E 是10，当保存成 32 位浮点数时，必须保存成 10 + 127 = 137，即 10001001。如果要保存成 64 位浮点数的时候，就会保存成 10 + 1023 = 1033，即 10000001001。</p><p data-reactid="134">然后，指数E还可以再分成三种情况：</p><p data-reactid="135"><!-- react-text: 136 -->￼<!-- /react-text --><img src="http://eux-blog-static.bj.bcebos.com/2018-03-18-18-29-56.jpg" data-reactid="137"/></p><ol data-reactid="138"><li data-reactid="139">E 不全为 0 或不全为 1。这时，浮点数就采用上面的规则表示，即指数 E 的计算值减去 127（或1023），得到真实值，再将有效数字 M 前加上第一位的 1。</li><li data-reactid="140">E 全为 0。这时，浮点数的指数E等于 1-127（或者1-1023），有效数字M不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字。</li><li data-reactid="141">E 全为 1。这时，如果有效数字 M 全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。</li></ol><h3 id="浮点数转换为二进制方法" data-reactid="142"><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E6%B3%95" aria-hidden="true" data-reactid="143"><span class="icon icon-link" data-reactid="144"></span></a><!-- react-text: 145 -->浮点数转换为二进制方法<!-- /react-text --></h3><p data-reactid="146">浮点数转换成二进制，我们要将整数部分和小数部分分开，大概就是整数部分采用除2取余倒叙记录，小数部分采用乘2取整顺序记录。具体例子和实现方式可自行搜索。</p><p data-reactid="147">以 0.1 为例，0.1的二进制</p><pre data-reactid="148"><code data-query="{}" data-lang="data-lang" data-reactid="149">    0.1
x     2
-------
    0.2     0
x     2
-------
    0.4     0
x     2
-------
    0.8     0
x     2
-------
    0.6     1
x     2
-------
    0.2     1
------- 又从0.2开始循环了
</code></pre><p data-reactid="150"><!-- react-text: 151 -->于是，我们得到了 0.1 的二进制表示，为 <!-- /react-text --><code data-reactid="152">0.0001100110011(0011循环)</code><!-- react-text: 153 -->，即 <!-- /react-text --><code data-reactid="154">1.100110011(0011) * 2^-4</code><!-- react-text: 155 --> 在计算机中的存储表达里，符号 s=0，尾数 M = 1.100110011(0011)，阶码 <!-- /react-text --><code data-reactid="156">E = -4</code><!-- react-text: 157 -->，实际存储为 <!-- /react-text --><code data-reactid="158">-4+1023 = 1019</code><!-- react-text: 159 --> 的二进制 <!-- /react-text --><code data-reactid="160">1111111011</code><!-- react-text: 161 -->。由于 <!-- /react-text --><code data-reactid="162">javascript</code><!-- react-text: 163 --> 是双精度的，所以 0.1 在计算机中存储格式为：<!-- /react-text --></p><pre data-reactid="164"><code data-query="{}" data-lang="data-lang" data-reactid="165">0  01111111011  1001100110011001100110011001100110011001100110011010
--------------------------------------------------------------------
s  exp(11位)     frac(52位，注意存储时候前面的1会舍去，最后一位进1)
</code></pre><p data-reactid="166"><!-- react-text: 167 -->同理，0.2 的二进制表示为 <!-- /react-text --><code data-reactid="168">0.001100110011(0011循环)</code><!-- react-text: 169 -->，即 <!-- /react-text --><code data-reactid="170">1.100110011(0011)*2^-3</code><!-- react-text: 171 --> 在计算机中的存储表达里，符号 s=0，尾数 M = 1.100110011(0011)，阶码 <!-- /react-text --><code data-reactid="172">E = -3</code><!-- react-text: 173 -->，实际存储为 <!-- /react-text --><code data-reactid="174">-3+1023 = 1020</code><!-- react-text: 175 --> 的二进制 <!-- /react-text --><code data-reactid="176">1111111100</code><!-- react-text: 177 -->。在计算机中存储格式为：<!-- /react-text --></p><pre data-reactid="178"><code data-query="{}" data-lang="data-lang" data-reactid="179">0  01111111100  1001100110011001100110011001100110011001100110011010
--------------------------------------------------------------------
s  exp(11位)     frac(52位，注意存储时候前面的1会舍去，最后一位进1)
</code></pre><h2 id="运算" data-reactid="180"><a href="#%E8%BF%90%E7%AE%97" aria-hidden="true" data-reactid="181"><span class="icon icon-link" data-reactid="182"></span></a><!-- react-text: 183 -->运算<!-- /react-text --></h2><p data-reactid="184">存储讲完，接下来就该聊下浮点数的加减运算了，它一般有6个步骤完成，先补充一下理论知识：</p><p data-reactid="185"><!-- react-text: 186 -->（1）对<!-- /react-text --><code data-reactid="187">0</code><!-- react-text: 188 -->、<!-- /react-text --><code data-reactid="189">Infinity</code><!-- react-text: 190 --> 和 <!-- /react-text --><code data-reactid="191">NaN</code><!-- react-text: 192 --> 操作数作检查，若有一个操作数为NaN则直接返回NaN;若有一个操作数为0则直接返回另一个操作数;若有一个操作数为Infinity,若另一个操作数也是Infinity且符号相同则返回第一个操作数;若另一个操作数也是Infinity且符号不同则返回NaN;若其他情况则返回Infinity。<!-- /react-text --></p><p data-reactid="193"><img src="http://eux-blog-static.bj.bcebos.com/2018-03-19-11-11-29.jpg" data-reactid="194"/></p><p data-reactid="195"><!-- react-text: 196 -->（2）对阶：对阶是将两个进行运算的浮点数的阶码对齐的操作。因为只有使两浮点数的指数值部分相同，才能将相同的指数值作为公因数提出来，然后进行尾数的加减运算。具体方法为：求出两浮点数阶码的差，即<!-- /react-text --><code data-reactid="197">⊿E＝Ex-Ey</code><!-- react-text: 198 -->，将小阶码加上<!-- /react-text --><code data-reactid="199">⊿E</code><!-- react-text: 200 -->，使之与大阶码相等，同时将小阶码对应的浮点数的尾数右移相应位数，以保证该浮点数的值不变。几点注意：<!-- /react-text --></p><ul data-reactid="201"><li data-reactid="202">对阶的原则是小阶对大阶。因为若大阶对小阶，则尾数的数值部分的高位需移出，而小阶对大阶移出的是尾数的数值部分的低位，这样损失的精度更小。</li><li data-reactid="203">采用补码表示的尾数右移时，符号位保持不变。</li><li data-reactid="204">由于尾数右移时是将最低位移出，会损失一定的精度，为减少误差，可先保留若干移出的位，供以后舍入处理用。</li></ul><p data-reactid="205">（3）尾数运算：主要为进行完成对阶后的尾数相加减的相关操作（包含隐藏位），采用双符号法判断是否溢出。</p><p data-reactid="206">（4）结果规格化，主要分为三种 向右规格化：若上一步出现溢出，则尾数右移1位，阶码+1; 向左规格化：若上一步没有出现溢出，且数值域最高位与符号位数值相同，则尾数左移1位且阶码-1，直到数值域最高位为1为止。</p><p data-reactid="207"><!-- react-text: 208 -->（5）舍入处理：由于浮点数无法精确表示所有数值，因此在存储前必须对数值作舍入操作。具体有五种方式，这里我们只谈 IEEE 754 默认的舍入模式：<!-- /react-text --><strong data-reactid="209">就近舍入 Round to nearest, ties to even</strong><!-- react-text: 210 -->： 就是我们日常所说的四舍五入，当存在两个数一样接近时，取偶数值(如2.4舍入为2，2.6舍入为3；2.5舍入为2，1.5舍入为2)。 另外还有 round toward +∞，round toward -∞，round toward 0 这三种模式，有兴趣的可自行查相关资料。<!-- /react-text --></p><p data-reactid="211">（6）溢出判断：与定点数运算不同的是，浮点数的溢出是以其运算结果的阶码的值是否产生溢出来判断的。若阶码的值超过了阶码所能表示的最大正数，则为上溢，进一步，若此时浮点数为正数，则为正上溢，记为 +∞，若浮点数为负数，则为负上溢，记为-∞；若阶码的值超过了阶码所能表示的最小负数，则为下溢，进一步，若此时浮点数为正数，则为正下溢，若浮点数为负数，则为负下溢。正下溢和负下溢都作为 0 处理。</p><p data-reactid="212"><!-- react-text: 213 -->一堆理论扯完之后，我们来看 <!-- /react-text --><code data-reactid="214">0.1 + 0.2</code><!-- react-text: 215 --> 的运算过程。 原本的 0.1 和 0.2 的二进制表示<!-- /react-text --></p><pre data-reactid="216"><code data-query="{}" data-lang="data-lang" data-reactid="217">0.1 = 1.1001100110011001100110011001100110011001100110011010 * 2^-4
0.2 = 1.1001100110011001100110011001100110011001100110011010 * 2^-3
</code></pre><p data-reactid="218">可以看到，0.1 的阶码为 -4，0.2 的阶码为 -3，依照小阶对大阶的原则，我们需要将 0.1 的阶码变为 -3，因此其尾数部分需要右移一位。对阶之后 0.1 的存储为：</p><pre data-reactid="219"><code data-query="{}" data-lang="data-lang" data-reactid="220">0.1 = 0.11001100110011001100110011001100110011001100110011010 * 2^-3
</code></pre><p data-reactid="221">想右移一位导致尾数需要进行阶段，因为最后一位刚好是0，所以这里直接舍弃，因此 0.1 对阶之后的存储为</p><pre data-reactid="222"><code data-query="{}" data-lang="data-lang" data-reactid="223">0  01111111100  1100110011001100110011001100110011001100110011001101 
--------------------------------------------------------------------
s  exp(阶码-3)   frac
</code></pre><p data-reactid="224">然后我们就可以愉快的进行相加这个运算步骤了：</p><pre data-reactid="225"><code data-query="{}" data-lang="data-lang" data-reactid="226">   0  01111111100  1100110011001100110011001100110011001100110011001101
+  0  01111111100  1001100110011001100110011001100110011001100110011010
</code></pre><p data-reactid="227">计算的话，手动画一画也没啥大问题，不过身为程序员就比较懒了，这里我们写一个二进制相加的方法：</p><pre data-reactid="228"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="229"><span class="hljs-keyword" data-reactid="230">const</span><!-- react-text: 231 --> a = <!-- /react-text --><span class="hljs-string" data-reactid="232">&quot;1100110011001100110011001100110011001100110011001101&quot;</span><!-- react-text: 233 -->.split(<!-- /react-text --><span class="hljs-string" data-reactid="234">&#x27;&#x27;</span><!-- react-text: 235 -->);
<!-- /react-text --><span class="hljs-keyword" data-reactid="236">const</span><!-- react-text: 237 --> b = <!-- /react-text --><span class="hljs-string" data-reactid="238">&quot;1001100110011001100110011001100110011001100110011010&quot;</span><!-- react-text: 239 -->.split(<!-- /react-text --><span class="hljs-string" data-reactid="240">&#x27;&#x27;</span><!-- react-text: 241 -->);
<!-- /react-text --><span class="hljs-keyword" data-reactid="242">const</span><!-- react-text: 243 --> res = [];
<!-- /react-text --><span class="hljs-keyword" data-reactid="244">let</span><!-- react-text: 245 --> flag = <!-- /react-text --><span class="hljs-number" data-reactid="246">0</span><!-- react-text: 247 -->;
<!-- /react-text --><span class="hljs-keyword" data-reactid="248">for</span><!-- react-text: 249 --> (<!-- /react-text --><span class="hljs-keyword" data-reactid="250">let</span><!-- react-text: 251 --> i = a.length - <!-- /react-text --><span class="hljs-number" data-reactid="252">1</span><!-- react-text: 253 -->; i &gt;= <!-- /react-text --><span class="hljs-number" data-reactid="254">0</span><!-- react-text: 255 -->; i--) {
    <!-- /react-text --><span class="hljs-keyword" data-reactid="256">const</span><!-- react-text: 257 --> ai = <!-- /react-text --><span class="hljs-built_in" data-reactid="258">parseInt</span><!-- react-text: 259 -->(a[i]);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="260">const</span><!-- react-text: 261 --> bi = <!-- /react-text --><span class="hljs-built_in" data-reactid="262">parseInt</span><!-- react-text: 263 -->(b[i]);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="264">const</span><!-- react-text: 265 --> cur = (ai ^ bi) ^ flag; <!-- /react-text --><span class="hljs-comment" data-reactid="266">// 当前数值 </span><!-- react-text: 267 -->
    flag = (ai + bi + flag) &gt;= <!-- /react-text --><span class="hljs-number" data-reactid="268">2</span><!-- react-text: 269 --> ? <!-- /react-text --><span class="hljs-number" data-reactid="270">1</span><!-- react-text: 271 --> : <!-- /react-text --><span class="hljs-number" data-reactid="272">0</span><!-- react-text: 273 -->; <!-- /react-text --><span class="hljs-comment" data-reactid="274">// 进位</span><!-- react-text: 275 -->
    res.unshift(cur);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="276">if</span><!-- react-text: 277 --> (i === <!-- /react-text --><span class="hljs-number" data-reactid="278">0</span><!-- react-text: 279 --> &amp;&amp; flag === <!-- /react-text --><span class="hljs-number" data-reactid="280">1</span><!-- react-text: 281 -->) {
        res.unshift(flag);
    }
}
<!-- /react-text --><span class="hljs-built_in" data-reactid="282">console</span><!-- react-text: 283 -->.log(res.join(<!-- /react-text --><span class="hljs-string" data-reactid="284">&#x27;&#x27;</span><!-- react-text: 285 -->));
<!-- /react-text --><span class="hljs-comment" data-reactid="286">// 10110011001100110011001100110011001100110011001100111</span></code></pre><p data-reactid="287">得出：</p><pre data-reactid="288"><code data-query="{}" data-lang="data-lang" data-reactid="289">   0  01111111100   1100110011001100110011001100110011001100110011001101
+  0  01111111100   1001100110011001100110011001100110011001100110011010
-------------------------------------------------------------------
=  0  01111111100  10110011001100110011001100110011001100110011001100111
</code></pre><p data-reactid="290"><!-- react-text: 291 -->可以看到发生了进位，此时尾数超过52，因此阶码部分加1（乘以2），即阶码由原来的 -3 变为 -2，所以阶码部分为 <!-- /react-text --><code data-reactid="292">01111111101</code><!-- react-text: 293 -->。而尾数部分右移一位（除以2），进行舍入（最后一位是1因此最低位进位），得到52位新的二进制表示为：<!-- /react-text --></p><p data-reactid="294"><!-- react-text: 295 -->1011001100110011001100110011001100110011001100110011 <!-- /react-text --><del data-reactid="296"><!-- react-text: 297 -->1<!-- /react-text --><del data-reactid="298">1011001100110011001100110011001100110011001100110100</del></del></p><p data-reactid="299">所以，最终的计算结果在计算机中的存储表达如下：</p><pre data-reactid="300"><code data-query="{}" data-lang="data-lang" data-reactid="301">0  1111111101  1011001100110011001100110011001100110011001100110100
</code></pre><p data-reactid="302">将其转换成十进制数为：</p><pre data-reactid="303"><code data-query="{}" data-lang="data-lang" data-reactid="304">2^-2 + (1+(1*2^-1 + 0 * 2^-2+1*2^-3+1*2^-4+... ) = 0.3000000000000000444089209850062616169452667236328125
</code></pre><p data-reactid="305">由于精度问题，只取到 0.30000000000000004。</p><p data-reactid="306">然后看看 0.3.toString(2) 的结果 �</p><pre data-reactid="307"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="308"><span class="hljs-built_in" data-reactid="309">console</span><!-- react-text: 310 -->.log(<!-- /react-text --><span class="hljs-number" data-reactid="311">0.3</span><!-- react-text: 312 -->.toString(<!-- /react-text --><span class="hljs-number" data-reactid="313">2</span><!-- react-text: 314 -->) );
<!-- /react-text --><span class="hljs-comment" data-reactid="315">// 0.010011001100110011001100110011001100110011001100110011</span></code></pre><h2 id="写在最后" data-reactid="316"><a href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E" aria-hidden="true" data-reactid="317"><span class="icon icon-link" data-reactid="318"></span></a><!-- react-text: 319 -->写在最后<!-- /react-text --></h2><p data-reactid="320"><!-- react-text: 321 -->好了，我们已经知道为什么 <!-- /react-text --><code data-reactid="322">0.1 + 0.2 !== 0.3</code><!-- react-text: 323 --> 的原因了，主要由于 0.1 和 0.2 转为二进制的时候为无限循环小数，而计算机的存储位置有限因此会做一定的截取舍入处理，再进行加减就有一定的误差了。<!-- /react-text --></p><p data-reactid="324">另外，由于js并没有特别区分整型和浮点型，实际上整型在 js 里面也是用浮点数的结构存储的，不过放在了尾数部分，以便于在计算过程总能随意自由切换。所以实际应用中，由于一些精度问题，比如后端数据库传来一个 ID 字段可能就会大于这个值，调用 JSON.parse 的时候就会丢失精度了，因此对于某些过大过小的数字需要用字符串存储。那要怎么在 js 中尽可能准确的计算出结果，以及怎么判断两个小数是否相等呢，敬请期待下回分解～</p><h2 id="参考资料" data-reactid="325"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" aria-hidden="true" data-reactid="326"><span class="icon icon-link" data-reactid="327"></span></a><!-- react-text: 328 -->参考资料<!-- /react-text --></h2><ul data-reactid="329"><li data-reactid="330"><a href="https://en.wikipedia.org/wiki/IEEE_754-1985" data-reactid="331">IEEE_754-1985</a></li><li data-reactid="332"><a href="https://blog.angularindepth.com/how-to-round-binary-fractions-625c8fa3a1af" data-reactid="333">how to round binary fractions</a></li><li data-reactid="334"><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" data-reactid="335">浮点数的二进制表示</a></li><li data-reactid="336"><a href="http://www.cnblogs.com/fsjohnhuang/p/5109766.html" data-reactid="337">细说浮点数</a></li><li data-reactid="338"><a href="https://news.ycombinator.com/item?id=10558871" data-reactid="339">https://news.ycombinator.com/item?id=10558871</a></li></ul></article><div data-reactid="340"></div><nav class="single-bar clearfix" data-reactid="341"><span class="prev" data-reactid="342"><a rel="prev" href="/blog/fe/Chrome的First Paint" data-reactid="343"><em class="eux-icon eux-icon-page-prev" data-reactid="344"></em><!-- react-text: 345 -->Chrome的First Paint<!-- /react-text --></a></span><span class="next" data-reactid="346"><a rel="next" href="/blog/fe/riot-js-框架深入解析" data-reactid="347"><em class="eux-icon eux-icon-page-next" data-reactid="348"></em><!-- react-text: 349 -->Riot.js 框架深入解析<!-- /react-text --></a></span></nav></div></div></div><footer class="footer" data-reactid="350"><div class="eux-footer-area-wrapper container-singular" role="complementary" data-reactid="351"><div class="inner clearfix" data-reactid="352"><aside id="simple-links-2" class="widget sl-links-main" data-reactid="353"><h2 class="widgettitle" data-reactid="354">友情链接</h2><ul class="simple-links-list simple-links-2-list" id="simple-links-2-list" data-reactid="355"><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="356"><a target="_blank" href="http://sux.baidu.com/" title="百度 FEX 团队" data-reactid="357">百度 FEX</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="358"><a target="_blank" href="http://efe.baidu.com/" title="百度 EFE 团队" data-reactid="359">百度 EFE</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="360"><a target="_blank" href="http://sux.baidu.com/" title="百度 SUX 团队" data-reactid="361">百度 SUX</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="362"><a target="_blank" href="https://aotu.io/" title="京东凹凸实验室，面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。" data-reactid="363">凹凸实验室</a></li><li class="simple-links-item simple-links-widget-item" id="link-379" data-reactid="364"><a target="_blank" href="https://fed.renren.com/" title="人人网FED" data-reactid="365">人人网FED</a></li></ul></aside></div></div><div class="eux-icp" data-reactid="366"><!-- react-text: 367 -->百度EUX 版权所有 ©百度EUX    All rights reserved. 骄傲地采用 <!-- /react-text --><a target="_blank" href="https://github.com/picidaejs/picidaejs" data-reactid="368">Picidae</a><!-- react-text: 369 -->。<!-- /react-text --></div></footer></div>
</div>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>