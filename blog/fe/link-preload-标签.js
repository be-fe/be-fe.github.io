webpackJsonp([41,56],{813:function(s,a){s.exports={content:'<p>本文主要对 Preload 这一新标准介绍。目前 Preload 兼容性如下：<br><img src=https://bj.bcebos.com/v1/eux-blog-static/preload_state.png></p><h2 id=preload-标签是什么><a href=#preload-%E6%A0%87%E7%AD%BE%E6%98%AF%E4%BB%80%E4%B9%88 aria-hidden=true><span class="icon icon-link"></span></a>Preload 标签是什么</h2><p>Preload 作为一个新的 web 标准，旨在提高性能和为web开发人员提供更细粒度的加载控制。Preload使开发者能够自定义资源的加载逻辑，且无需忍受基于脚本的资源加载器带来的性能损失。</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"preload"</span>></span></code></pre><h2 id=类似的技术><a href=#%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%8A%80%E6%9C%AF aria-hidden=true><span class="icon icon-link"></span></a>类似的技术</h2><p>关于预加载，目前已经有几种方案</p><h3 id=dns-prefetch><a href=#dns-prefetch aria-hidden=true><span class="icon icon-link"></span></a>DNS prefetch</h3><p>DNS prefetching通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早的解析DNS。比如我们需要一个在example.com的图片或者视频文件。在<code>&lt;head></code>就可以这么写：</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"dns-prefetch"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"//example.com"</span>></span></code></pre><h3 id=preconnect><a href=#preconnect aria-hidden=true><span class="icon icon-link"></span></a>Preconnect</h3><p>和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。用法如下：</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"preconnect"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"http://example.com"</span>></span> </code></pre><h3 id=prefetch><a href=#prefetch aria-hidden=true><span class="icon icon-link"></span></a>Prefetch</h3><p>当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用。prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。</p><pre><code class="hljs language-html"data-query={} data-lang=html>\t\n<span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"prefetch"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"image.png"</span>></span></code></pre><h3 id=subresource><a href=#subresource aria-hidden=true><span class="icon icon-link"></span></a>Subresource</h3><p>subresource可以用来指定资源是最高优先级的。比如，在Chrome和Opera中我们可以加上下面的代码：</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"subresource"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"styles.css"</span>></span>  </code></pre><h3 id=prerender><a href=#prerender aria-hidden=true><span class="icon icon-link"></span></a>Prerender</h3><p>prerender是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"prerender"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"/thenextpage.html"</span>/></span></code></pre><h2 id=preload-的优势><a href=#preload-%E7%9A%84%E4%BC%98%E5%8A%BF aria-hidden=true><span class="icon icon-link"></span></a>Preload 的优势</h2><p>相对于类似的技术，Preload 有 as 属性，这让浏览器可做一些 subresource 和 prefetch 无法实现的事：</p><ul><li>浏览器可以设置正确的资源加载优先级</li><li>浏览器可以确保请求是符合内容安全策略的</li><li>浏览器能根据 as 的值发送适当的 Accept 头部信息</li><li>浏览器通过 as 值能得知资源类型</li></ul><p>Preload 的与众不同还体现在 onload 事件上（在 Chrome 中，prefetch 和 subresource 是不支持的）。preload 不会阻塞 windows 的 onload 事件，除非，preload资源的请求刚好来自于会阻塞 window 加载的资源。</p><h2 id=preload-用法举例><a href=#preload-%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B aria-hidden=true><span class="icon icon-link"></span></a>Preload 用法举例</h2><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"preload"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"a.js"</span> <span class=hljs-attr>as</span>=<span class=hljs-string>"script"</span>></span></code></pre><p>忽略 as 属性，或者错误的 as 属性会使 preload 等同于 XHR 请求，浏览器不知道加载的是什么， 因此会赋予此类资源非常低的加载优先级。</p><h2 id=preload-应用><a href=#preload-%E5%BA%94%E7%94%A8 aria-hidden=true><span class="icon icon-link"></span></a>Preload 应用</h2><h3 id=对字体的提前加载><a href=#%E5%AF%B9%E5%AD%97%E4%BD%93%E7%9A%84%E6%8F%90%E5%89%8D%E5%8A%A0%E8%BD%BD aria-hidden=true><span class="icon icon-link"></span></a>对字体的提前加载</h3><p>字体被隐藏在css中间，浏览器有时候不能很好的将他们放入预加载器中，为此我们可以借助preload</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"preload"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"font.woff"</span> <span class=hljs-attr>as</span>=<span class=hljs-string>"font"</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"font/woff"</span> <span class=hljs-attr>crossorigin</span>></span></code></pre><p>crossorigin 属性是必须的，即便是字体资源在自家服务器上，因为用户代理必须采用匿名模式来获取字体资源。</p><h3 id=基于标记语言的异步加载><a href=#%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD aria-hidden=true><span class="icon icon-link"></span></a>基于标记语言的异步加载</h3><p>css 异步加载</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"preload"</span> <span class=hljs-attr>as</span>=<span class=hljs-string>"style"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"asyncstyle.css"</span> <span class=hljs-attr>onload</span>=<span class=hljs-string>"this.rel=\'stylesheet\'"</span>></span></code></pre><p>js 异步加载</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>link</span> <span class=hljs-attr>rel</span>=<span class=hljs-string>"preload"</span> <span class=hljs-attr>as</span>=<span class=hljs-string>"script"</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"async_script.js"</span> <span class=hljs-attr>onload</span>=<span class=hljs-string>"var script = document.createElement(\'script\'); script.src = this.href; document.body.appendChild(script);"</span>></span></code></pre><p>async 属性会阻塞 window 的 onload 事件，这么写就没有问题了。</p><h3 id=动态加载，但不执行><a href=#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%89%A7%E8%A1%8C aria-hidden=true><span class="icon icon-link"></span></a>动态加载，但不执行</h3><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> link = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>"link"</span>);\nlink.href = <span class=hljs-string>"myscript.js"</span>;\nlink.rel = <span class=hljs-string>"preload"</span>;\nlink.as = <span class=hljs-string>"script"</span>;\n<span class=hljs-built_in>document</span>.head.appendChild(link);\n<span class=hljs-keyword>var</span> script = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>"script"</span>);\nscript.src = <span class=hljs-string>"myscript.js"</span>;\n<span class=hljs-built_in>document</span>.body.appendChild(script); </code></pre><h2 id=preload-在生产环境的案例><a href=#preload-%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%A1%88%E4%BE%8B aria-hidden=true><span class="icon icon-link"></span></a>Preload 在生产环境的案例</h2><h3 id=treebo-案例><a href=#treebo-%E6%A1%88%E4%BE%8B aria-hidden=true><span class="icon icon-link"></span></a>Treebo 案例</h3><p>Treebo，印度最大的旅馆网站之一，在 3G 网络下对其桌面版试验，在对其顶部图片和主要的 Webpack 打包文件使用 preload 之后，在首屏绘制和可交互延迟分别减少了 1s。</p><p><img src=https://bj.bcebos.com/v1/eux-blog-static/preload%E6%A1%88%E4%BE%8B1.png></p><p>同样的，在对自己的渐进式 Web 应用程序主要打包文件使用 preload 之后，Flipkart 在路由解析之前 节省了大量的主线程空闲时间（在 3G 网络下的低性能手机下）。</p><h1 id=参考文献><a href=#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE aria-hidden=true><span class="icon icon-link"></span></a>参考文献</h1><ul><li><a href=https://mp.weixin.qq.com/s/O5E2ASBEzfKOxgzCCJDlfw>深入研究Chrome：Preload与Prefetch原理，及其优先级</a></li><li><a href=https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/>Preload: What Is It Good For?</a></li></ul>',extra:{"_image-loader_":[]}}}});
//# sourceMappingURL=link-preload-标签.js.map