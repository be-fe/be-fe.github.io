webpackJsonp([23,56],{831:function(e,s){e.exports={content:'<h2 id=微信小程序><a href=#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F aria-hidden=true><span class="icon icon-link"></span></a>微信小程序</h2><p>微信小程序包含下面四种文件：</p><ul><li>js</li><li>json 配置文件</li><li>wxml 小程序专用 xml 文件</li><li>wxss 小程序专用 css 文件</li></ul><!-- more --><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>view</span>></span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>text</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"window"</span>></span>{{ text }}<span class=hljs-tag>&lt;/<span class=hljs-name>text</span>></span>\n<span class=hljs-tag>&lt;/<span class=hljs-name>view</span>></span> </code></pre><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>Page({\n  <span class=hljs-attr>data</span>:{\n    <span class=hljs-attr>text</span>:<span class=hljs-string>"这是一个页面"</span>\n  },\n  <span class=hljs-attr>onLoad</span>:<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>options</span>)</span>{\n    <span class=hljs-comment>// 页面初始化 options为页面跳转所带来的参数</span>\n  },\n  <span class=hljs-comment>// ........</span>\n}) </code></pre><p>微信小程序只能通过其 mvvm 的模板语法来动态改变页面，本身 js 并不支持 BOM 和 DOM 操作。</p><h2 id=从开发工具看微信小程序架构><a href=#%E4%BB%8E%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9C%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84 aria-hidden=true><span class="icon icon-link"></span></a>从开发工具看微信小程序架构</h2><p>在 mac 端直接解压应用 发现 app.nw 文件夹，即开发工具源码。可以知道该项目由 nw.js 编写； 在 package.json 文件下找到应用入口：<code>app/html/index.html</code>。入口 js 为 <code>dist/app.js</code> 我们可以看到整个编辑器的大致逻辑。<br>但我们关心的是构建过程，在 weapp 文件夹下存在 build.js 文件。没有找到有用的信息，只看到了 <code>upload</code> 模块，包括对大小限制，上传包命名。<br>为此怀疑，微信小程序本身和 RN 类似。是在服务端打包成 native 语言的。但是通过 android 边框测试发现，微信小程序根本不是 native 原生内容。</p><p>原生界面效果：</p><img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-a.jpg alt width=295 height=397><h3 id=编译过程><a href=#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B aria-hidden=true><span class="icon icon-link"></span></a>编译过程</h3><p>继续在 trans 文件夹下发现了编译模板。</p><ul><li>transWxmlToJs wxml 转 js</li><li>transWxssToCss wxss 转 css</li><li>transConfigToPf 模板页配置</li><li>transWxmlToHtml wxml 转 html</li><li>transManager 管理器</li></ul><p>用到的内容：</p><ul><li>发现用到了一个模板：<code>app.nw/app/dist/weapp/tpl/pageFrameTpl.js</code>, <code>app.mw/app.dist.weapp/tpl/appserviceTpl.js</code></li><li>wcc 可执行程序，wcc 用于转转 wxml 中的自定义 tag 为 virtual_dom</li><li>wcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 <code>wcsc xxx.wxss</code></li></ul><p>在模板中，我们发现使用了 <code>WAWebview.js</code> 文件，<code>WAService.js</code>文件。 在 transWxmlToJs 中我们发现一段 generateFuncReady 事件的函数。对比注册该事件的函数在 <code>WAWebview.js</code> 中。<br>我们尝试使用 wcc 对input.xml 文件进行编译。</p><blockquote><p>wcc -d input.xml</p></blockquote><p>生成了一段脚本：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-built_in>window</span>.__wcc_version__ = <span class=hljs-string>\'v0.6vv_20161230_fbi\'</span>\n<span class=hljs-keyword>var</span> $gwxc\n<span class=hljs-keyword>var</span> $gaic = \n$gwx = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>path, global</span>) </span>{\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>_</span>(<span class=hljs-params>a, b</span>) </span>{\n        b &amp&amp a.children.push(b);\n    }\n    ....</code></pre><p>通过代码我们发现，调用 $gwx 函数会再生成一个有返回值的函数(前提是 path 填写正确)；于是我们执行如下代码：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>$gwx(<span class=hljs-string>"input.xml"</span>)(<span class=hljs-string>"test"</span>)</code></pre><p>得出如下内容：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>{\n    <span class=hljs-string>"tag"</span>: <span class=hljs-string>"wx-page"</span>,\n    <span class=hljs-string>"children"</span>: [\n        {\n            <span class=hljs-string>"tag"</span>: <span class=hljs-string>"wx-view"</span>,\n            <span class=hljs-string>"attr"</span>: {\n                <span class=hljs-string>"class"</span>: <span class=hljs-string>"section"</span>\n            },\n            <span class=hljs-string>"children"</span>: [\n                {\n                    <span class=hljs-string>"tag"</span>: <span class=hljs-string>"wx-input"</span>,\n                    <span class=hljs-string>"attr"</span>: {\n                        <span class=hljs-string>"autoFocus"</span>: <span class=hljs-literal>true</span>,\n                        <span class=hljs-string>"placeholder"</span>: <span class=hljs-string>"这是一个可以自动聚焦的input"</span>\n                    },\n                    <span class=hljs-string>"children"</span>: []\n                }\n            ]\n        }\n    ]\n} </code></pre><p>这应该是一个类似 Virtual dom 的对象，交给了 WAWebivew.js 来渲染，标签名为 <code>wx-view</code>, <code>wx-input</code>。</p><h4 id=wawebviewjs><a href=#wawebviewjs aria-hidden=true><span class="icon icon-link"></span></a>WAWebview.js</h4><ol><li><p>代码在最一开始提供的是兼容性工具，还有一个 <code>WeixinJSBridge</code> 引入。</p></li><li><p>接下来是一个 <code>Reporter</code> 对象，它的作用就是发送错误和性能统计数据给后台。</p></li></ol><img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-b.jpg alt width=380 height=126><ol start=3><li><code>wx</code> 核心对象，包含了 <code>wx</code> 对象下的 <code>api</code>。但是这里的 <code>api</code> 数量远远少于官方的 <code>api</code> 文档数量。</li></ol><img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-c.jpg alt width=333 height=170><p>我们可以在代码里面发现，<code>wx</code> 下注册的 <code>api</code> 最终都会调用 <code>WeixinJSBridge</code> 方法。这个方法应该是在打包的时候端上注入的。我们也可以在 <code>WAServeice.js</code> 中找到该方法的定义。</p><img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-d.jpg alt width=773 height=179><p>所以我们得到了一个结论，<code>WAService.js</code> 是编辑器用来接受 <code>wx</code> 方法回调的代码。</p><ol start=4><li><p><code>wxparser</code> 对象，提供 <code>dom</code> 到 <code>wx element</code> 对象之间的映射操作，提供元素操作管理和事件管理功能。</p></li><li><p>之后代码是对 <code>exparser</code> 对象的处理，包括注册 <code>WeixinJSBridge</code> 全局事件，Virtual dom 算法实现，样式注入等。介绍几个组件重要的内容</p></li></ol><ul><li><p><code>exparser.registerBehavior</code> 注册组件基础行为，供组件继承。 <img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-e.jpg alt width=280 height=221></p></li><li><p><code>exparser.registerElement</code> 为各种内置组件，注册模板，行为，属性，监听器等内容 <img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-f.jpg alt width=350 height=186></p></li></ul><p>这里我们观察到，组件：<code>wx-video</code>, <code>wx-canvas</code>, <code>wx-contact-button</code>, <code>wx-map</code>, <code>wx-textarea</code> 等 behaviors 都含有 "wx-native" 属性。这是不是意味着，这类组件都是 native 原生实现的呢。我们打开边框检查，发现这类组件确实都是原生的组件。</p><p><a href=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-g.jpg></a></p><img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-h.jpg alt width=338 height=426><p>综上，微信小程序的界面有部分组件使用原生方式实现的，native 组件层在 WebView 层之上。大部分还是用前端实现的，这样解释了微信小程序的一个bug。</p><blockquote><p>微信官方文档：<br><img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-i.jpg alt width=568 height=53></p></blockquote><p>因为 scroll-view 是前端实现，在里面使用 native 组件，这样就无法监听滚动了。</p><h4 id=weixinjsbridge><a href=#weixinjsbridge aria-hidden=true><span class="icon icon-link"></span></a>WeixinJSBridge</h4><p>组件是需要数据来渲染的，查看文档我们知道发送请求的 api 为 <code>wx.request</code>;通过上面分析，我们知道 wx.request 实际调用的是 <code>WeixinJSBridge</code>。现在我们看看 <code>WeixinJSBridge</code></p><img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-j.jpg alt width=616 height=332><p><code>WeixinJSBridge</code> 真正发送处理数据请求的是这段代码；如果当前环境是 <code>ios</code>, 那么调用 <code>WKWebview</code> 的 <code>window.webkit.messageHandlers.invokeHandler.postMessage</code>。如果所处环境是 <code>android</code> 则调用 <code>WeixinJSCore.invokeHandler</code> (调用的时候，默认会带上当前 <code>webviewID</code>)。</p><h4 id=waservicejs><a href=#waservicejs aria-hidden=true><span class="icon icon-link"></span></a>WAService.js</h4><p>在对 <code>WeixinJSBridge.js</code> 分析中，我们并没有发现前端的通讯功能，路由能力，数据绑定等内容。进一步查看找到了一个 <code>WAService.js</code> 文件。 查看 <code>WAService.js</code> 文件源码：</p><ol><li>在代码最开始，跟 <code>WAWebview.js</code> 一样的 <code>WeixinJSBridge</code> 兼容模块</li><li>然后是跟 <code>WAWebview.js</code> 一样的 <code>Reporter</code> 模块。</li><li>比 <code>WAWebview.js</code> 中 <code>wx</code> 功能更为丰富 <code>wx</code> 接口模块。(剩余部分 <code>wx api</code> 都在这里)</li><li><code>appServiceEngine</code> 模块，提供 <code>Page</code>，<code>App</code>，<code>GetApp</code> 接口</li><li>为 <code>window</code> 对象添加 <code>AMD</code> 接口 <code>require define</code></li></ol><p>综上，<code>WAService.js</code> 主要实现的功能：</p><ul><li>App( ) 小程序的入口；Page( ) 页面的入口</li><li>wx API;</li><li>页面有的作用域，提供模块化能力</li><li>数据绑定、事件分发、生命周期管理、路由管理</li></ul><p>到这里我们得出结论，小程序的架构方案： <img src=https://eux-public.bj.bcebos.com/2018/08/15/tgy-wx-k.jpg alt width=800 height=440></p><p>整个小程序由两个 <code>webview</code> 组成，代码分为 <code>UI</code> 层和逻辑层。<code>UI</code> 层运行在第一个 <code>WebView</code> 当中，执行 <code>DOM</code> 操作和交互事件的响应，里面是 <code>WAWebview.js</code> 代码及编译后的内容。逻辑层执行在（第二个<code>webview</code> 中）独立的 <code>JS</code> 引擎中（iOS：<code>JavaScriptCore</code>, android：<code>X5</code> JS解析器；统称 <code>JSCore</code>；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。</p><p>当我们对 <code>view</code> 层进行事件操作后，会通过 <code>WeixinJSBridge</code> 将数据传递到 <code>Native</code> 系统层。<code>Native</code> 系统层决定是否要用 <code>native</code> 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 <code>WeixinJSBridge</code> 返给 <code>View</code> 层。<code>View</code> 渲染更新视图。</p><h2 id=架构的讨论><a href=#%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%A8%E8%AE%BA aria-hidden=true><span class="icon icon-link"></span></a>架构的讨论</h2><p>微信的这种架构，对逻辑和UI进行了完全隔离，小程序逻辑和UI完全运行在2个独立的Webview里面来处理。那么这么做的好处是啥？总感觉更加麻烦了。除了小程序外，还有人采用这种架构设计么？<br>在网上搜索了一下，目前使用这种架构的项目还真有一个：<a href=http://ued.qunar.com/yis/index.html>去哪儿最新的 YIS 框架</a></p><blockquote><p>YIS 采取了类似小程序的架构，分为逻辑层和UI层。UI 层运行在 WebView 中，而逻辑层运行在独立的 JS 引擎中。相应地，整个应用的代码，也分为两个大的部分，一部分运行在 WebView 中，一部分运行在JS引擎中。JS引擎计算DOM结构输出给WebView，WebView转发用户的点击事件给JS引擎。</p></blockquote><p>该项目做法和小程序十分类似，唯一缺少的就是没有 native 的组件吧。然而官方文档上也没有任何介绍，为什么要这么做，只是说更流畅了。</p><h3 id=一些看法><a href=#%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95 aria-hidden=true><span class="icon icon-link"></span></a>一些看法</h3><p>传统 web 页面显示需要经历一下几个步骤:</p><ol><li><code>webview</code> 初始化</li><li>加载 <code>HTML</code>, <code>CSS</code>, <code>JS</code></li><li>编译 <code>JS</code></li><li><code>Render</code> 计算</li><li><code>DOM Path</code></li></ol><p>而利用小程序架构后，我们就可以将上述过程拆解成两部分并行执行： <code>webview</code> 部分：</p><ol><li><code>webview</code> 初始化</li><li>加载 <code>HTML</code>，<code>CSS</code>, <code>JS</code> (经过拆分后，体积大幅度减小)</li><li>编译 <code>JS</code></li><li>等待页面需要的数据</li><li>反序列化数据</li><li>执行 <code>Patch</code></li><li>渲染页面</li><li>等待更多消息</li></ol><p><code>jscore</code> 部分：</p><ol><li>初始化</li><li>加载框架 <code>js</code> 代码</li><li>编译 <code>js</code></li><li>加载业务逻辑 <code>js</code> 代码</li><li>编译 <code>js</code></li><li>计算首屏虚拟 <code>DOM</code> 结构</li><li>序列化数据，传输</li><li>等待 <code>webview</code> 消息，或者 <code>Native</code> 消息</li></ol><p>这样渲染进程和逻辑进程分离，并行处理：加速首屏渲染速度；避免单线程模型下，<code>js</code> 运算时间过长，UI 出现卡顿。 完全采用数据驱动的方式，不能直接操作 DOM，利用定制开发规范的方式避免低质量的代码的出现。</p><p>当然这种架构方案也有一定的缺点：</p><ol><li>不能灵活操作 <code>DOM</code>，无法实现较为复杂的效果</li><li>部分和 <code>NA</code> 相关的视图有使用限制，如微信的 <code>scrollView</code> 内不能有 <code>textarea</code>。</li><li>页面大小、打开页面数量都受到限制</li><li>需要单独开发适配，不能复用现有代码资源。</li><li>在 jscore 中JS 体积比较大的情况下，其初始化时间会产生影响。</li><li>传输数据中，序列化和反序列化耗时需要考虑</li></ol><h1 id=参考资料><a href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 aria-hidden=true><span class="icon icon-link"></span></a>参考资料</h1><ul><li><a href=https://www.zhihu.com/question/50920642>微信小程序底层的实现原理是怎样的</a></li><li><a href=http://www.bbs0101.com/archives/1495.html>微信小程序架构解析，工作原理解析</a></li><li><a href=https://zhuanlan.zhihu.com/p/22754296>微信小程序架构分析</a></li></ul>',extra:{"_image-loader_":[]}}}});
//# sourceMappingURL=微信小程序架构原理.js.map