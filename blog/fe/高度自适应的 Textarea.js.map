{"version":3,"sources":["webpack:///blog/fe/高度自适应的 Textarea.js","webpack:///./doc/fe/高度自适应的 Textarea.md"],"names":["webpackJsonp","836","module","exports","content","extra","_image-loader_"],"mappings":"AAAAA,cAAc,GAAG,KAEXC,IACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,w9oBACAC,OACAC","file":"blog/fe/高度自适应的 Textarea.js","sourcesContent":["webpackJsonp([18,56],{\n\n/***/ 836:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<h2 id=背景介绍><a href=#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>背景介绍</h2><p>正如我们所知道的 <code>textarea</code> 是一个行内块元素 <code>display: inline-block</code> 并且它的默认宽高由 <code>cols</code> &amp <code>rows</code> 决定, 也就是说 <code>textarea</code> 的 <code>height</code> 并不会自适应于内容长度.</p><p><strong><em>textarea</em> 的宽高是如何决定的?</strong> 参考张鑫旭的文章 <a href=http://www.zhangxinxu.com/wordpress/2016/02/html-textarea-rows-height/>HTML textarea cols,rows属性和宽度高度关系研究</a></p><p>那么, 我们今天的任务就是来思考如何创建一个 <strong>高度内容自适应的 <em>textarea</em> 组件</strong>，我将介绍三种思路实现 <strong>高度内容自适应的 <em>textarea</em></strong>，具体代码 <a href=https://github.com/teeeemoji/TextareaAutoSizeSolutions>textareaAutoSizeSolutions</a></p><h2 id=方案概要><a href=#%E6%96%B9%E6%A1%88%E6%A6%82%E8%A6%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案概要</h2><p>这是三种方案的概述和实现思路的简介, 实现方案 &amp 遇到的坑 &amp 拓展知识点, 点击查看 <a href=https://github.com/teeeemoji/TextareaAutoSizeSolutions>teeeemoji 的 demo</a>.</p><h3 id=方案一-两次调整-textareastyleheight><a href=#%E6%96%B9%E6%A1%88%E4%B8%80-%E4%B8%A4%E6%AC%A1%E8%B0%83%E6%95%B4-textareastyleheight aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案一: 两次调整 textarea.style.height</h3><p><code>textarea</code> 的 <code>onchange</code> 触发 <code>resize</code> 方法，下面是 <code>resize</code> 方法的逻辑</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>textarea.style.height = <span class=hljs-string>'auto'</span>;<span class=hljs-comment>// 1. 让 textarea 的高度恢复默认</span>\\ntextarea.style.height = textarea.scrollHeight + <span class=hljs-string>'px'</span>;<span class=hljs-comment>// 2. textarea.scrollHeight 表示 *textarea* 内容的实际高度</span></code></pre><h3 id=方案二-利用一个-ghosttextarea-获得输入框内容高度-再将这个高度设置给真实的-textarea><a href=#%E6%96%B9%E6%A1%88%E4%BA%8C-%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%AA-ghosttextarea-%E8%8E%B7%E5%BE%97%E8%BE%93%E5%85%A5%E6%A1%86%E5%86%85%E5%AE%B9%E9%AB%98%E5%BA%A6-%E5%86%8D%E5%B0%86%E8%BF%99%E4%B8%AA%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E7%BB%99%E7%9C%9F%E5%AE%9E%E7%9A%84-textarea aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案二: 利用一个 ghostTextarea 获得输入框内容高度, 再将这个高度设置给真实的 <em>textarea</em></h3><p><code>textarea</code> 构建时创建 <strong>ghostTextarea</strong>, <code>onchange</code> 触发 <code>resize</code> 方法：</p><ol><li>创建 <em>textarea</em> 的时候, 同时创建一个一模一样的隐藏 ghostTextarea;</li><li>ghostTextarea 的属性全部克隆自 <code>textarea</code>, 但是 ghostTextarea 是 <strong>隐藏</strong> 的, 并且 <code>ghostTextarea.style.height = 0</code>; 也就是说 ghostTextarea.scrollHeight 就是 <code>textarea</code> 中内容的真是高度。</li></ol><p>resize 方法处理流程：</p><ol><li><code>textarea.value</code> 先设置给 ghostTextarea,</li><li>拿到 <code>ghostTextarea.scrollHeight</code></li><li>将 <code>textarea.style.height = ghostTextarea.scrollHeight</code></li></ol><h3 id=方案三-使用-div--p--contenteditable-代替-textarea-作为输入框><a href=#%E6%96%B9%E6%A1%88%E4%B8%89-%E4%BD%BF%E7%94%A8-div--p--contenteditable-%E4%BB%A3%E6%9B%BF-textarea-%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%A1%86 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案三: 使用 (div | p | ...).contenteditable 代替 <em>textarea</em> 作为输入框</h3><p><code>div</code> 是块级元素, 高度本身就是内容自适应的（除非设置 <code>max-width</code> or <code>min-widht</code>） 使用 <code>contenteditable</code> 让 <code>div</code> 代替 <code>textarea</code>, 省去各种计算高度的逻辑。</p><h2 id=方案对比><a href=#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案对比</h2><p>满分3分, 三种方案通过优化, 在用户体验和兼容性上都能达到满分. 因此差别仅仅在于这几个方案的实现难度. (仅仅是基于 react 组件的实现复杂度). 方案对比：</p><img src=https://eux-public.bj.bcebos.com/2018/06/07/34596181d6d29cff57903f61b.png alt width=656 height=173><p>毫无疑问方案一是最优选择, 多加1分以示奖励;</p><h2 id=方案一两次调整-textareastyleheight><a href=#%E6%96%B9%E6%A1%88%E4%B8%80%E4%B8%A4%E6%AC%A1%E8%B0%83%E6%95%B4-textareastyleheight aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案一两次调整 textarea.style.height</h2><h3 id=实现思路><a href=#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现思路</h3><ol><li>渲染一个 <code>textarea</code> 元素</li></ol><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>&lt;textarea\\n    ref={<span class=hljs-keyword>this</span>.bindRef}\\n    className={style[<span class=hljs-string>'textarea'</span>] + <span class=hljs-string>' '</span> + className}\\n    placeholder={placeholder}\\n    value={value}\\n    onChange={<span class=hljs-keyword>this</span>.handleChange} <span class=hljs-comment>// 看这里</span>\\n/></code></pre><ol start=2><li><code>textarea</code> 的 <code>onChange</code> 事件触发 <code>resize</code></li></ol><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>handleChange(e) {\\n    <span class=hljs-keyword>this</span>.props.onChange(e.target.value);\\n    <span class=hljs-keyword>this</span>.resize();\\t<span class=hljs-comment>// 看这里</span>\\n}</code></pre><ol start=3><li><code>resize</code> 事件的实现</li></ol><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 重新计算 textarea 的高度</span>\\nresize() {\\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.inputRef) {\\n        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'resizing...'</span>)\\n        <span class=hljs-keyword>this</span>.inputRef.style.height = <span class=hljs-string>'auto'</span>;\\n        <span class=hljs-keyword>this</span>.inputRef.style.height = <span class=hljs-keyword>this</span>.inputRef.scrollHeight + <span class=hljs-string>'px'</span>;\\n    }\\n}</code></pre><ol start=4><li>注意 <code>componentDidMount</code> 的时候, 执行一次 <code>resize</code> 方法, 初始化 <code>textarea</code> 的高度哦.</li></ol><h3 id=优化点><a href=#%E4%BC%98%E5%8C%96%E7%82%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>优化点</h3><p><strong>避免两次渲染,造成内容抖动</strong></p><p>在 <code>react</code> 中, 组件 <code>receiveProps</code> 的时候会 <code>render</code> 一次, 直接调整 <code>textarea</code> 的 <code>height</code> 也会浏览器的重绘，那么就会造成两次重绘, 并且两次重绘的时候, <code>textarea</code> 的内容可能会发生抖动.</p><p><strong>优化思路</strong>：先触发 <code>resize</code> 后触发 <code>render</code> <strong>用最简单的思路完美解决问题</strong></p><h2 id=方案二-利用一个-ghosttextarea-获得输入框内容高度-再将这个高度设置给真实的-textarea-1><a href=#%E6%96%B9%E6%A1%88%E4%BA%8C-%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%AA-ghosttextarea-%E8%8E%B7%E5%BE%97%E8%BE%93%E5%85%A5%E6%A1%86%E5%86%85%E5%AE%B9%E9%AB%98%E5%BA%A6-%E5%86%8D%E5%B0%86%E8%BF%99%E4%B8%AA%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E7%BB%99%E7%9C%9F%E5%AE%9E%E7%9A%84-textarea-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案二: 利用一个 ghostTextarea 获得输入框内容高度, 再将这个高度设置给真实的 <em>textarea</em></h2><h3 id=实现思路-1><a href=#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现思路</h3><p>同时渲染两个 <code>textarea</code>, 一个真实 <code>textarea</code> 一个隐藏 <code>textarea</code></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>return</span> (\\n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>className</span>=<span class=hljs-string>{style[</span>'<span class=hljs-attr>comp-textarea-with-ghost</span>']}></span>\\n        </span>&lt;textarea // 这个是真的\\n            ref={this.bindRef}\\n            className={style['textarea'] + ' ' + className}\\n            placeholder={placeholder}\\n            value={value}\\n            onChange={this.handleChange}\\n            style={{height}}\\n        />\\n        &lt;textarea // 这个是 ghostTextarea\\n            className={style['textarea-ghost']}\\n            ref={this.bindGhostRef}\\n            onChange={noop}\\n        />\\n    &lt;/div>\\n)</code></pre><p>初始化的时候拷贝属性，初始化必须使用工具方法将 <code>textarea</code> 的属性拷贝到 <code>ghostTextarea</code> 去. 因为 <code>textarea</code> 的样式再组件外也能控制, 因此初始化的时候 copy style 是最安全的。</p><p>这是所以要拷贝的属性的列表:</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> SIZING_STYLE = [\\n\\t<span class=hljs-string>'letter-spacing'</span>,\\n\\t<span class=hljs-string>'line-height'</span>,\\n\\t<span class=hljs-string>'font-family'</span>,\\n\\t<span class=hljs-string>'font-weight'</span>,\\n\\t<span class=hljs-string>'font-size'</span>,\\n\\t<span class=hljs-string>'font-style'</span>,\\n\\t<span class=hljs-string>'tab-size'</span>,\\n\\t<span class=hljs-string>'text-rendering'</span>,\\n\\t<span class=hljs-string>'text-transform'</span>,\\n\\t<span class=hljs-string>'width'</span>,\\n\\t<span class=hljs-string>'text-indent'</span>,\\n\\t<span class=hljs-string>'padding-top'</span>,\\n\\t<span class=hljs-string>'padding-right'</span>,\\n\\t<span class=hljs-string>'padding-bottom'</span>,\\n\\t<span class=hljs-string>'padding-left'</span>,\\n\\t<span class=hljs-string>'border-top-width'</span>,\\n\\t<span class=hljs-string>'border-right-width'</span>,\\n\\t<span class=hljs-string>'border-bottom-width'</span>,\\n\\t<span class=hljs-string>'border-left-width'</span>,\\n\\t<span class=hljs-string>'box-sizing'</span>\\n];</code></pre><p>这是 ghostTextarea 的隐藏属性列表:</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> HIDDEN_TEXTAREA_STYLE = {\\n\\t<span class=hljs-string>'min-height'</span>: <span class=hljs-string>'0'</span>,\\n\\t<span class=hljs-string>'max-height'</span>: <span class=hljs-string>'none'</span>,\\n\\t<span class=hljs-attr>height</span>: <span class=hljs-string>'0'</span>,\\n\\t<span class=hljs-attr>visibility</span>: <span class=hljs-string>'hidden'</span>,\\n\\t<span class=hljs-attr>overflow</span>: <span class=hljs-string>'hidden'</span>,\\n\\t<span class=hljs-attr>position</span>: <span class=hljs-string>'absolute'</span>,\\n\\t<span class=hljs-string>'z-index'</span>: <span class=hljs-string>'-1000'</span>,\\n\\t<span class=hljs-attr>top</span>: <span class=hljs-string>'0'</span>,\\n\\t<span class=hljs-attr>right</span>: <span class=hljs-string>'0'</span>,\\n};</code></pre><p>这是拷贝 <code>style</code> 的工具方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 拿到真实 textarea 的所有 style</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>calculateNodeStyling</span>(<span class=hljs-params>node</span>) </span>{\\n\\t<span class=hljs-keyword>const</span> style = <span class=hljs-built_in>window</span>.getComputedStyle(node);\\n\\t<span class=hljs-keyword>if</span> (style === <span class=hljs-literal>null</span>) {\\n\\t\\t<span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>;\\n\\t}\\n\\t<span class=hljs-keyword>return</span> SIZING_STYLE.reduce(<span class=hljs-function>(<span class=hljs-params>obj, name</span>) =></span> {\\n\\t\\tobj[name] = style.getPropertyValue(name);\\n\\t\\t\\t<span class=hljs-keyword>return</span> obj;\\n\\t}, {});\\n}\\n\\n<span class=hljs-comment>// 拷贝 真实 textarea 的 style 到 ghostTextarea</span>\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> copyStyle = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>toNode, fromNode</span>) </span>{\\n\\t<span class=hljs-keyword>const</span> nodeStyling = calculateNodeStyling(fromNode);\\n\\t<span class=hljs-keyword>if</span> (nodeStyling === <span class=hljs-literal>null</span>) {\\n\\t\\t<span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>;\\n\\t}\\n\\t<span class=hljs-built_in>Object</span>.keys(nodeStyling).forEach(<span class=hljs-function><span class=hljs-params>key</span> =></span> {\\n\\t\\ttoNode.style[key] = nodeStyling[key];\\n\\t});\\n\\t<span class=hljs-built_in>Object</span>.keys(HIDDEN_TEXTAREA_STYLE).forEach(<span class=hljs-function><span class=hljs-params>key</span> =></span> {\\n\\t\\ttoNode.style.setProperty(\\n\\t\\t\\tkey,\\n\\t\\t\\tHIDDEN_TEXTAREA_STYLE[key],\\n\\t\\t\\t<span class=hljs-string>'important'</span>,\\n\\t\\t);\\n\\t});\\n}</code></pre><p><em>textarea</em> 的 <code>onChange</code> 事件 先 reize 再触发 change 事件</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>handleChange(e) {\\n\\t<span class=hljs-keyword>this</span>.resize();\\n\\t<span class=hljs-keyword>let</span> value = e.target.value;\\n\\t<span class=hljs-keyword>this</span>.props.onChange(value);\\n}</code></pre><p><em>textarea</em> 的 resize 方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>resize() {\\n\\t<span class=hljs-built_in>console</span>.log(<span class=hljs-string>'resizing...'</span>)\\n\\t<span class=hljs-keyword>const</span> height = calculateGhostTextareaHeight(<span class=hljs-keyword>this</span>.ghostRef, <span class=hljs-keyword>this</span>.inputRef);\\n\\t<span class=hljs-keyword>this</span>.setState({height});\\n}</code></pre><p>calculateGhostTextareaHeight 工具方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 先将内容设置进 ghostTextarea, 再拿到 ghostTextarea.scrollHeight</span>\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> calculateGhostTextareaHeight = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>ghostTextarea, textarea</span>) </span>{\\n\\t<span class=hljs-keyword>if</span> (!ghostTextarea) {\\n\\t\\t<span class=hljs-keyword>return</span>;\\n\\t}\\n\\tghostTextarea.value = textarea.value || textarea.placeholder || <span class=hljs-string>'x'</span>\\n\\t<span class=hljs-keyword>return</span> ghostTextarea.scrollHeight;\\n}</code></pre><h3 id=优化点-1><a href=#%E4%BC%98%E5%8C%96%E7%82%B9-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>优化点</h3><h4 id=避免两次渲染造成内容抖动><a href=#%E9%81%BF%E5%85%8D%E4%B8%A4%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%80%A0%E6%88%90%E5%86%85%E5%AE%B9%E6%8A%96%E5%8A%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>避免两次渲染,造成内容抖动</h4><p>在 <code>react</code> 中, 组件 <code>receiveProps</code> 的时候会 <code>render</code> 一次, 给 <code>textarea</code> 设置 <code>height</code> 属性也会浏览器的重绘.那么就会造成两次重绘, 并且两次重绘的时候, <code>textarea</code> 的内容可能会发生抖动.</p><p>下面两种思路, 在 demo 中均有体现</p><p><strong>优化思路一: 合并祯渲染</strong></p><p>使用 <code>window.requestAnimationFrame</code> &amp <code>window.cancelAnimationFrame</code> 来取消第一祯的渲染, 而直接渲染高度已经调整好的 <code>textarea</code>;</p><p><strong>优化思路二: 减少渲染次数</strong></p><p>利用 <code>react</code> 批处理 <code>setState</code> 方法, 减少 <code>rerender</code> 的特性; 在 <code>textarea onChange</code> 方法中同时触发两个 <code>setState</code>; <img src=http://upload-images.jianshu.io/upload_images/4217515-05b7453c02c59c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=123.png width=1240 height=339></p><h3 id=更多优化思路><a href=#%E6%9B%B4%E5%A4%9A%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>更多优化思路</h3><ul><li>页面存在多个 <code>textarea</code> 的时候, 能不能考虑 复用同一个 <code>ghostTextarea</code></li></ul><h2 id=方案三-使用-divcontenteditable-代替-textarea><a href=#%E6%96%B9%E6%A1%88%E4%B8%89-%E4%BD%BF%E7%94%A8-divcontenteditable-%E4%BB%A3%E6%9B%BF-textarea aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案三: 使用 div.contenteditable 代替 <em>textarea</em></h2><h3 id=实现思路-2><a href=#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现思路</h3><p>渲染一个 <code>div.contenteditable=true</code></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>return</span> (\\n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>className</span>=<span class=hljs-string>{style[</span>'<span class=hljs-attr>comp-div-contenteditable</span>']}></span>\\n        </span>&lt;div\\n            ref={this.bindRef}\\n            className={classname(style['textarea'], className, {[style['empty']]: !value})}\\n            onChange={this.handleChange}\\n            onPaste={this.handlePaste}\\n            placeholder={placeholder}\\n            contentEditable\\n        />\\n    &lt;/div><span class=xml>\\n)</span></code></pre><p>获取 &amp 设置 编辑的内容： <code>textarea</code> 通过 <code>textarea.value</code> 来取值 or 设置值, 但换成了 <code>div</code> 之后, 就要使用 <code>div.innerHTML</code> or <code>div.innerText</code> 来取值 or 设置值.</p><p>使用 <code>div.innerHTML</code> 会出现以下两种问题:</p><ul><li><code>&amp</code> 会被转码成 <code>&ampamp;</code></li><li>空白符合并 使用 <code>div.innerText</code> 在低版本 firfox 上要做兼容处理.</li></ul><p>因此使用哪种方式 <strong>主要看需求</strong>.</p><p>placeholder 的实现:</p><p><code>div</code> 的 <code>placeholder</code> 属性是无效, 不会显示出来的, 现存一种最简单的方式, 使用纯 <code>css</code> 的方式实现 <code>div</code> 的 <code>placeholder</code></p><pre><code class=\\\"hljs language-css\\\"data-query={} data-lang=css><span class=hljs-selector-class>.textarea</span><span class=hljs-selector-attr>[placeholder]</span><span class=hljs-selector-pseudo>:empty</span><span class=hljs-selector-pseudo>:before</span> { <span class=hljs-comment>/*empty &amp before 两个伪类*/</span>\\n\\t<span class=hljs-attribute>content</span>: <span class=hljs-built_in>attr</span>(placeholder); <span class=hljs-comment>/*attr 函数*/</span>\\n\\t<span class=hljs-attribute>color</span>: <span class=hljs-number>#555</span>;\\n}</code></pre><h3 id=优化点-2><a href=#%E4%BC%98%E5%8C%96%E7%82%B9-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>优化点</h3><h4 id=去除支持富文本><a href=#%E5%8E%BB%E9%99%A4%E6%94%AF%E6%8C%81%E5%AF%8C%E6%96%87%E6%9C%AC aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>去除支持富文本</h4><p><code>div.contenteditable</code> 是默认支持富文本的, 可能会以 <strong>粘贴</strong> or <strong>拖拽</strong> 让输入框出现富文本;</p><img src=http://upload-images.jianshu.io/upload_images/4217515-942edb0bb73b3810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=234.png width=786 height=325><p>监听 div 的 onPaste 事件</p><pre><code data-query={} data-lang>handlePaste(e) {\\n    e.preventDefault();\\n    let text = e.clipboardData.getData('text/plain'); // 拿到纯文本\\n    document.execCommand('insertText', false, text); // 让浏览器执行插入文本操作\\n}\\n</code></pre><p><a href=http://www.zhangxinxu.com/wordpress/2016/01/contenteditable-plaintext-only/><strong>handlePaste 的更多兼容性处理</strong></a></p><h2 id=几个大网站的高度自适应-textarea-对比><a href=#%E5%87%A0%E4%B8%AA%E5%A4%A7%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94-textarea-%E5%AF%B9%E6%AF%94 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>几个大网站的高度自适应 <em>textarea</em> 对比</h2><p>我分别查看了<a href=weibo.com>微博</a>, <a href=ant.design>ant.design组件库</a>, <a href=www.zhihu.com>知乎</a> 的自适应输入框的实现.</p><h3 id=微博-采用方案二><a href=#%E5%BE%AE%E5%8D%9A-%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88%E4%BA%8C aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>微博: 采用方案二</h3><p>未输入时</p><img src=http://upload-images.jianshu.io/upload_images/4217515-ec0ae559ecac069f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=5aa4b41fdf0082f1c9.png width=648 height=247><p>输入后</p><img src=http://upload-images.jianshu.io/upload_images/4217515-6fd8b07173997039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=5aa4b4517a668254df.png width=639 height=344><p>但是微博的实现存在<strong>用户体验</strong>上的缺陷, <strong>会抖动!!!</strong></p><img src=http://upload-images.jianshu.io/upload_images/4217515-2bb4d2992db9c18f.gif?imageMogr2/auto-orient/strip alt=weibo.git.gif width=360 height=240><h3 id=antdesign-采用方案二><a href=#antdesign-%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88%E4%BA%8C aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>ant.design: 采用方案二</h3><p>体验超级棒哦</p><img src=http://upload-images.jianshu.io/upload_images/4217515-614691d5b58f4e18.gif?imageMogr2/auto-orient/strip alt=antd.gif width=360 height=240><h3 id=知乎-采用方案三><a href=#%E7%9F%A5%E4%B9%8E-%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88%E4%B8%89 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>知乎: 采用方案三</h3><p>看上去竟然存在 bug , 其实上面的截图也有</p><img src=http://upload-images.jianshu.io/upload_images/4217515-3210eab87c15f92f.gif?imageMogr2/auto-orient/strip alt=zhih.gif width=360 height=240><h2 id=参考链接列表><a href=#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>参考链接列表</h2><ul><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea>textarea mdn 文档</a>: 看看有哪些影响 textarea 宽高的属性</li><li><a href=http://www.zhangxinxu.com/wordpress/2016/02/html-textarea-rows-height/>HTML textarea cols,rows属性和宽度高度关系研究</a></li><li><a href=https://css-tricks.com/textarea-tricks/>CSS Tricks</a>: textarea 使用上的小技巧. 一些样式技巧.</li><li><a href=https://andreypopp.github.io/react-textarea-autosize/>开源的 react auto resize textarea</a>: 一个更好的方案二的实现, 源码优雅短小</li><li><a href=www.caniuse.com>can i use 兼容性检查工具</a>: execCommand, innerText, requireAnimationFrame, 等等各种各样属性的兼容性检查</li><li><a href=https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable>contenteditable MDN</a></li><li><a href=https://gist.github.com/Schniz/e398a630c81cfd8a3d1e>一个方案三的实现, a good demo</a></li><li><a href=http://www.zhangxinxu.com/wordpress/2016/01/contenteditable-plaintext-only/>小tip: 如何让contenteditable元素只能输入纯文本</a></li></ul>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// blog/fe/高度自适应的 Textarea.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<h2 id=背景介绍><a href=#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>背景介绍</h2><p>正如我们所知道的 <code>textarea</code> 是一个行内块元素 <code>display: inline-block</code> 并且它的默认宽高由 <code>cols</code> &amp <code>rows</code> 决定, 也就是说 <code>textarea</code> 的 <code>height</code> 并不会自适应于内容长度.</p><p><strong><em>textarea</em> 的宽高是如何决定的?</strong> 参考张鑫旭的文章 <a href=http://www.zhangxinxu.com/wordpress/2016/02/html-textarea-rows-height/>HTML textarea cols,rows属性和宽度高度关系研究</a></p><p>那么, 我们今天的任务就是来思考如何创建一个 <strong>高度内容自适应的 <em>textarea</em> 组件</strong>，我将介绍三种思路实现 <strong>高度内容自适应的 <em>textarea</em></strong>，具体代码 <a href=https://github.com/teeeemoji/TextareaAutoSizeSolutions>textareaAutoSizeSolutions</a></p><h2 id=方案概要><a href=#%E6%96%B9%E6%A1%88%E6%A6%82%E8%A6%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案概要</h2><p>这是三种方案的概述和实现思路的简介, 实现方案 &amp 遇到的坑 &amp 拓展知识点, 点击查看 <a href=https://github.com/teeeemoji/TextareaAutoSizeSolutions>teeeemoji 的 demo</a>.</p><h3 id=方案一-两次调整-textareastyleheight><a href=#%E6%96%B9%E6%A1%88%E4%B8%80-%E4%B8%A4%E6%AC%A1%E8%B0%83%E6%95%B4-textareastyleheight aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案一: 两次调整 textarea.style.height</h3><p><code>textarea</code> 的 <code>onchange</code> 触发 <code>resize</code> 方法，下面是 <code>resize</code> 方法的逻辑</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>textarea.style.height = <span class=hljs-string>'auto'</span>;<span class=hljs-comment>// 1. 让 textarea 的高度恢复默认</span>\\ntextarea.style.height = textarea.scrollHeight + <span class=hljs-string>'px'</span>;<span class=hljs-comment>// 2. textarea.scrollHeight 表示 *textarea* 内容的实际高度</span></code></pre><h3 id=方案二-利用一个-ghosttextarea-获得输入框内容高度-再将这个高度设置给真实的-textarea><a href=#%E6%96%B9%E6%A1%88%E4%BA%8C-%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%AA-ghosttextarea-%E8%8E%B7%E5%BE%97%E8%BE%93%E5%85%A5%E6%A1%86%E5%86%85%E5%AE%B9%E9%AB%98%E5%BA%A6-%E5%86%8D%E5%B0%86%E8%BF%99%E4%B8%AA%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E7%BB%99%E7%9C%9F%E5%AE%9E%E7%9A%84-textarea aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案二: 利用一个 ghostTextarea 获得输入框内容高度, 再将这个高度设置给真实的 <em>textarea</em></h3><p><code>textarea</code> 构建时创建 <strong>ghostTextarea</strong>, <code>onchange</code> 触发 <code>resize</code> 方法：</p><ol><li>创建 <em>textarea</em> 的时候, 同时创建一个一模一样的隐藏 ghostTextarea;</li><li>ghostTextarea 的属性全部克隆自 <code>textarea</code>, 但是 ghostTextarea 是 <strong>隐藏</strong> 的, 并且 <code>ghostTextarea.style.height = 0</code>; 也就是说 ghostTextarea.scrollHeight 就是 <code>textarea</code> 中内容的真是高度。</li></ol><p>resize 方法处理流程：</p><ol><li><code>textarea.value</code> 先设置给 ghostTextarea,</li><li>拿到 <code>ghostTextarea.scrollHeight</code></li><li>将 <code>textarea.style.height = ghostTextarea.scrollHeight</code></li></ol><h3 id=方案三-使用-div--p--contenteditable-代替-textarea-作为输入框><a href=#%E6%96%B9%E6%A1%88%E4%B8%89-%E4%BD%BF%E7%94%A8-div--p--contenteditable-%E4%BB%A3%E6%9B%BF-textarea-%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E6%A1%86 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案三: 使用 (div | p | ...).contenteditable 代替 <em>textarea</em> 作为输入框</h3><p><code>div</code> 是块级元素, 高度本身就是内容自适应的（除非设置 <code>max-width</code> or <code>min-widht</code>） 使用 <code>contenteditable</code> 让 <code>div</code> 代替 <code>textarea</code>, 省去各种计算高度的逻辑。</p><h2 id=方案对比><a href=#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案对比</h2><p>满分3分, 三种方案通过优化, 在用户体验和兼容性上都能达到满分. 因此差别仅仅在于这几个方案的实现难度. (仅仅是基于 react 组件的实现复杂度). 方案对比：</p><img src=https://eux-public.bj.bcebos.com/2018/06/07/34596181d6d29cff57903f61b.png alt width=656 height=173><p>毫无疑问方案一是最优选择, 多加1分以示奖励;</p><h2 id=方案一两次调整-textareastyleheight><a href=#%E6%96%B9%E6%A1%88%E4%B8%80%E4%B8%A4%E6%AC%A1%E8%B0%83%E6%95%B4-textareastyleheight aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案一两次调整 textarea.style.height</h2><h3 id=实现思路><a href=#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现思路</h3><ol><li>渲染一个 <code>textarea</code> 元素</li></ol><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>&lt;textarea\\n    ref={<span class=hljs-keyword>this</span>.bindRef}\\n    className={style[<span class=hljs-string>'textarea'</span>] + <span class=hljs-string>' '</span> + className}\\n    placeholder={placeholder}\\n    value={value}\\n    onChange={<span class=hljs-keyword>this</span>.handleChange} <span class=hljs-comment>// 看这里</span>\\n/></code></pre><ol start=2><li><code>textarea</code> 的 <code>onChange</code> 事件触发 <code>resize</code></li></ol><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>handleChange(e) {\\n    <span class=hljs-keyword>this</span>.props.onChange(e.target.value);\\n    <span class=hljs-keyword>this</span>.resize();\\t<span class=hljs-comment>// 看这里</span>\\n}</code></pre><ol start=3><li><code>resize</code> 事件的实现</li></ol><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 重新计算 textarea 的高度</span>\\nresize() {\\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.inputRef) {\\n        <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'resizing...'</span>)\\n        <span class=hljs-keyword>this</span>.inputRef.style.height = <span class=hljs-string>'auto'</span>;\\n        <span class=hljs-keyword>this</span>.inputRef.style.height = <span class=hljs-keyword>this</span>.inputRef.scrollHeight + <span class=hljs-string>'px'</span>;\\n    }\\n}</code></pre><ol start=4><li>注意 <code>componentDidMount</code> 的时候, 执行一次 <code>resize</code> 方法, 初始化 <code>textarea</code> 的高度哦.</li></ol><h3 id=优化点><a href=#%E4%BC%98%E5%8C%96%E7%82%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>优化点</h3><p><strong>避免两次渲染,造成内容抖动</strong></p><p>在 <code>react</code> 中, 组件 <code>receiveProps</code> 的时候会 <code>render</code> 一次, 直接调整 <code>textarea</code> 的 <code>height</code> 也会浏览器的重绘，那么就会造成两次重绘, 并且两次重绘的时候, <code>textarea</code> 的内容可能会发生抖动.</p><p><strong>优化思路</strong>：先触发 <code>resize</code> 后触发 <code>render</code> <strong>用最简单的思路完美解决问题</strong></p><h2 id=方案二-利用一个-ghosttextarea-获得输入框内容高度-再将这个高度设置给真实的-textarea-1><a href=#%E6%96%B9%E6%A1%88%E4%BA%8C-%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%AA-ghosttextarea-%E8%8E%B7%E5%BE%97%E8%BE%93%E5%85%A5%E6%A1%86%E5%86%85%E5%AE%B9%E9%AB%98%E5%BA%A6-%E5%86%8D%E5%B0%86%E8%BF%99%E4%B8%AA%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E7%BB%99%E7%9C%9F%E5%AE%9E%E7%9A%84-textarea-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案二: 利用一个 ghostTextarea 获得输入框内容高度, 再将这个高度设置给真实的 <em>textarea</em></h2><h3 id=实现思路-1><a href=#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现思路</h3><p>同时渲染两个 <code>textarea</code>, 一个真实 <code>textarea</code> 一个隐藏 <code>textarea</code></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>return</span> (\\n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>className</span>=<span class=hljs-string>{style[</span>'<span class=hljs-attr>comp-textarea-with-ghost</span>']}></span>\\n        </span>&lt;textarea // 这个是真的\\n            ref={this.bindRef}\\n            className={style['textarea'] + ' ' + className}\\n            placeholder={placeholder}\\n            value={value}\\n            onChange={this.handleChange}\\n            style={{height}}\\n        />\\n        &lt;textarea // 这个是 ghostTextarea\\n            className={style['textarea-ghost']}\\n            ref={this.bindGhostRef}\\n            onChange={noop}\\n        />\\n    &lt;/div>\\n)</code></pre><p>初始化的时候拷贝属性，初始化必须使用工具方法将 <code>textarea</code> 的属性拷贝到 <code>ghostTextarea</code> 去. 因为 <code>textarea</code> 的样式再组件外也能控制, 因此初始化的时候 copy style 是最安全的。</p><p>这是所以要拷贝的属性的列表:</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> SIZING_STYLE = [\\n\\t<span class=hljs-string>'letter-spacing'</span>,\\n\\t<span class=hljs-string>'line-height'</span>,\\n\\t<span class=hljs-string>'font-family'</span>,\\n\\t<span class=hljs-string>'font-weight'</span>,\\n\\t<span class=hljs-string>'font-size'</span>,\\n\\t<span class=hljs-string>'font-style'</span>,\\n\\t<span class=hljs-string>'tab-size'</span>,\\n\\t<span class=hljs-string>'text-rendering'</span>,\\n\\t<span class=hljs-string>'text-transform'</span>,\\n\\t<span class=hljs-string>'width'</span>,\\n\\t<span class=hljs-string>'text-indent'</span>,\\n\\t<span class=hljs-string>'padding-top'</span>,\\n\\t<span class=hljs-string>'padding-right'</span>,\\n\\t<span class=hljs-string>'padding-bottom'</span>,\\n\\t<span class=hljs-string>'padding-left'</span>,\\n\\t<span class=hljs-string>'border-top-width'</span>,\\n\\t<span class=hljs-string>'border-right-width'</span>,\\n\\t<span class=hljs-string>'border-bottom-width'</span>,\\n\\t<span class=hljs-string>'border-left-width'</span>,\\n\\t<span class=hljs-string>'box-sizing'</span>\\n];</code></pre><p>这是 ghostTextarea 的隐藏属性列表:</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> HIDDEN_TEXTAREA_STYLE = {\\n\\t<span class=hljs-string>'min-height'</span>: <span class=hljs-string>'0'</span>,\\n\\t<span class=hljs-string>'max-height'</span>: <span class=hljs-string>'none'</span>,\\n\\t<span class=hljs-attr>height</span>: <span class=hljs-string>'0'</span>,\\n\\t<span class=hljs-attr>visibility</span>: <span class=hljs-string>'hidden'</span>,\\n\\t<span class=hljs-attr>overflow</span>: <span class=hljs-string>'hidden'</span>,\\n\\t<span class=hljs-attr>position</span>: <span class=hljs-string>'absolute'</span>,\\n\\t<span class=hljs-string>'z-index'</span>: <span class=hljs-string>'-1000'</span>,\\n\\t<span class=hljs-attr>top</span>: <span class=hljs-string>'0'</span>,\\n\\t<span class=hljs-attr>right</span>: <span class=hljs-string>'0'</span>,\\n};</code></pre><p>这是拷贝 <code>style</code> 的工具方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 拿到真实 textarea 的所有 style</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>calculateNodeStyling</span>(<span class=hljs-params>node</span>) </span>{\\n\\t<span class=hljs-keyword>const</span> style = <span class=hljs-built_in>window</span>.getComputedStyle(node);\\n\\t<span class=hljs-keyword>if</span> (style === <span class=hljs-literal>null</span>) {\\n\\t\\t<span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>;\\n\\t}\\n\\t<span class=hljs-keyword>return</span> SIZING_STYLE.reduce(<span class=hljs-function>(<span class=hljs-params>obj, name</span>) =></span> {\\n\\t\\tobj[name] = style.getPropertyValue(name);\\n\\t\\t\\t<span class=hljs-keyword>return</span> obj;\\n\\t}, {});\\n}\\n\\n<span class=hljs-comment>// 拷贝 真实 textarea 的 style 到 ghostTextarea</span>\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> copyStyle = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>toNode, fromNode</span>) </span>{\\n\\t<span class=hljs-keyword>const</span> nodeStyling = calculateNodeStyling(fromNode);\\n\\t<span class=hljs-keyword>if</span> (nodeStyling === <span class=hljs-literal>null</span>) {\\n\\t\\t<span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>;\\n\\t}\\n\\t<span class=hljs-built_in>Object</span>.keys(nodeStyling).forEach(<span class=hljs-function><span class=hljs-params>key</span> =></span> {\\n\\t\\ttoNode.style[key] = nodeStyling[key];\\n\\t});\\n\\t<span class=hljs-built_in>Object</span>.keys(HIDDEN_TEXTAREA_STYLE).forEach(<span class=hljs-function><span class=hljs-params>key</span> =></span> {\\n\\t\\ttoNode.style.setProperty(\\n\\t\\t\\tkey,\\n\\t\\t\\tHIDDEN_TEXTAREA_STYLE[key],\\n\\t\\t\\t<span class=hljs-string>'important'</span>,\\n\\t\\t);\\n\\t});\\n}</code></pre><p><em>textarea</em> 的 <code>onChange</code> 事件 先 reize 再触发 change 事件</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>handleChange(e) {\\n\\t<span class=hljs-keyword>this</span>.resize();\\n\\t<span class=hljs-keyword>let</span> value = e.target.value;\\n\\t<span class=hljs-keyword>this</span>.props.onChange(value);\\n}</code></pre><p><em>textarea</em> 的 resize 方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>resize() {\\n\\t<span class=hljs-built_in>console</span>.log(<span class=hljs-string>'resizing...'</span>)\\n\\t<span class=hljs-keyword>const</span> height = calculateGhostTextareaHeight(<span class=hljs-keyword>this</span>.ghostRef, <span class=hljs-keyword>this</span>.inputRef);\\n\\t<span class=hljs-keyword>this</span>.setState({height});\\n}</code></pre><p>calculateGhostTextareaHeight 工具方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// 先将内容设置进 ghostTextarea, 再拿到 ghostTextarea.scrollHeight</span>\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> calculateGhostTextareaHeight = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>ghostTextarea, textarea</span>) </span>{\\n\\t<span class=hljs-keyword>if</span> (!ghostTextarea) {\\n\\t\\t<span class=hljs-keyword>return</span>;\\n\\t}\\n\\tghostTextarea.value = textarea.value || textarea.placeholder || <span class=hljs-string>'x'</span>\\n\\t<span class=hljs-keyword>return</span> ghostTextarea.scrollHeight;\\n}</code></pre><h3 id=优化点-1><a href=#%E4%BC%98%E5%8C%96%E7%82%B9-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>优化点</h3><h4 id=避免两次渲染造成内容抖动><a href=#%E9%81%BF%E5%85%8D%E4%B8%A4%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%80%A0%E6%88%90%E5%86%85%E5%AE%B9%E6%8A%96%E5%8A%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>避免两次渲染,造成内容抖动</h4><p>在 <code>react</code> 中, 组件 <code>receiveProps</code> 的时候会 <code>render</code> 一次, 给 <code>textarea</code> 设置 <code>height</code> 属性也会浏览器的重绘.那么就会造成两次重绘, 并且两次重绘的时候, <code>textarea</code> 的内容可能会发生抖动.</p><p>下面两种思路, 在 demo 中均有体现</p><p><strong>优化思路一: 合并祯渲染</strong></p><p>使用 <code>window.requestAnimationFrame</code> &amp <code>window.cancelAnimationFrame</code> 来取消第一祯的渲染, 而直接渲染高度已经调整好的 <code>textarea</code>;</p><p><strong>优化思路二: 减少渲染次数</strong></p><p>利用 <code>react</code> 批处理 <code>setState</code> 方法, 减少 <code>rerender</code> 的特性; 在 <code>textarea onChange</code> 方法中同时触发两个 <code>setState</code>; <img src=http://upload-images.jianshu.io/upload_images/4217515-05b7453c02c59c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=123.png width=1240 height=339></p><h3 id=更多优化思路><a href=#%E6%9B%B4%E5%A4%9A%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>更多优化思路</h3><ul><li>页面存在多个 <code>textarea</code> 的时候, 能不能考虑 复用同一个 <code>ghostTextarea</code></li></ul><h2 id=方案三-使用-divcontenteditable-代替-textarea><a href=#%E6%96%B9%E6%A1%88%E4%B8%89-%E4%BD%BF%E7%94%A8-divcontenteditable-%E4%BB%A3%E6%9B%BF-textarea aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方案三: 使用 div.contenteditable 代替 <em>textarea</em></h2><h3 id=实现思路-2><a href=#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现思路</h3><p>渲染一个 <code>div.contenteditable=true</code></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>return</span> (\\n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>className</span>=<span class=hljs-string>{style[</span>'<span class=hljs-attr>comp-div-contenteditable</span>']}></span>\\n        </span>&lt;div\\n            ref={this.bindRef}\\n            className={classname(style['textarea'], className, {[style['empty']]: !value})}\\n            onChange={this.handleChange}\\n            onPaste={this.handlePaste}\\n            placeholder={placeholder}\\n            contentEditable\\n        />\\n    &lt;/div><span class=xml>\\n)</span></code></pre><p>获取 &amp 设置 编辑的内容： <code>textarea</code> 通过 <code>textarea.value</code> 来取值 or 设置值, 但换成了 <code>div</code> 之后, 就要使用 <code>div.innerHTML</code> or <code>div.innerText</code> 来取值 or 设置值.</p><p>使用 <code>div.innerHTML</code> 会出现以下两种问题:</p><ul><li><code>&amp</code> 会被转码成 <code>&ampamp;</code></li><li>空白符合并 使用 <code>div.innerText</code> 在低版本 firfox 上要做兼容处理.</li></ul><p>因此使用哪种方式 <strong>主要看需求</strong>.</p><p>placeholder 的实现:</p><p><code>div</code> 的 <code>placeholder</code> 属性是无效, 不会显示出来的, 现存一种最简单的方式, 使用纯 <code>css</code> 的方式实现 <code>div</code> 的 <code>placeholder</code></p><pre><code class=\\\"hljs language-css\\\"data-query={} data-lang=css><span class=hljs-selector-class>.textarea</span><span class=hljs-selector-attr>[placeholder]</span><span class=hljs-selector-pseudo>:empty</span><span class=hljs-selector-pseudo>:before</span> { <span class=hljs-comment>/*empty &amp before 两个伪类*/</span>\\n\\t<span class=hljs-attribute>content</span>: <span class=hljs-built_in>attr</span>(placeholder); <span class=hljs-comment>/*attr 函数*/</span>\\n\\t<span class=hljs-attribute>color</span>: <span class=hljs-number>#555</span>;\\n}</code></pre><h3 id=优化点-2><a href=#%E4%BC%98%E5%8C%96%E7%82%B9-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>优化点</h3><h4 id=去除支持富文本><a href=#%E5%8E%BB%E9%99%A4%E6%94%AF%E6%8C%81%E5%AF%8C%E6%96%87%E6%9C%AC aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>去除支持富文本</h4><p><code>div.contenteditable</code> 是默认支持富文本的, 可能会以 <strong>粘贴</strong> or <strong>拖拽</strong> 让输入框出现富文本;</p><img src=http://upload-images.jianshu.io/upload_images/4217515-942edb0bb73b3810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=234.png width=786 height=325><p>监听 div 的 onPaste 事件</p><pre><code data-query={} data-lang>handlePaste(e) {\\n    e.preventDefault();\\n    let text = e.clipboardData.getData('text/plain'); // 拿到纯文本\\n    document.execCommand('insertText', false, text); // 让浏览器执行插入文本操作\\n}\\n</code></pre><p><a href=http://www.zhangxinxu.com/wordpress/2016/01/contenteditable-plaintext-only/><strong>handlePaste 的更多兼容性处理</strong></a></p><h2 id=几个大网站的高度自适应-textarea-对比><a href=#%E5%87%A0%E4%B8%AA%E5%A4%A7%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94-textarea-%E5%AF%B9%E6%AF%94 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>几个大网站的高度自适应 <em>textarea</em> 对比</h2><p>我分别查看了<a href=weibo.com>微博</a>, <a href=ant.design>ant.design组件库</a>, <a href=www.zhihu.com>知乎</a> 的自适应输入框的实现.</p><h3 id=微博-采用方案二><a href=#%E5%BE%AE%E5%8D%9A-%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88%E4%BA%8C aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>微博: 采用方案二</h3><p>未输入时</p><img src=http://upload-images.jianshu.io/upload_images/4217515-ec0ae559ecac069f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=5aa4b41fdf0082f1c9.png width=648 height=247><p>输入后</p><img src=http://upload-images.jianshu.io/upload_images/4217515-6fd8b07173997039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 alt=5aa4b4517a668254df.png width=639 height=344><p>但是微博的实现存在<strong>用户体验</strong>上的缺陷, <strong>会抖动!!!</strong></p><img src=http://upload-images.jianshu.io/upload_images/4217515-2bb4d2992db9c18f.gif?imageMogr2/auto-orient/strip alt=weibo.git.gif width=360 height=240><h3 id=antdesign-采用方案二><a href=#antdesign-%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88%E4%BA%8C aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>ant.design: 采用方案二</h3><p>体验超级棒哦</p><img src=http://upload-images.jianshu.io/upload_images/4217515-614691d5b58f4e18.gif?imageMogr2/auto-orient/strip alt=antd.gif width=360 height=240><h3 id=知乎-采用方案三><a href=#%E7%9F%A5%E4%B9%8E-%E9%87%87%E7%94%A8%E6%96%B9%E6%A1%88%E4%B8%89 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>知乎: 采用方案三</h3><p>看上去竟然存在 bug , 其实上面的截图也有</p><img src=http://upload-images.jianshu.io/upload_images/4217515-3210eab87c15f92f.gif?imageMogr2/auto-orient/strip alt=zhih.gif width=360 height=240><h2 id=参考链接列表><a href=#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>参考链接列表</h2><ul><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea>textarea mdn 文档</a>: 看看有哪些影响 textarea 宽高的属性</li><li><a href=http://www.zhangxinxu.com/wordpress/2016/02/html-textarea-rows-height/>HTML textarea cols,rows属性和宽度高度关系研究</a></li><li><a href=https://css-tricks.com/textarea-tricks/>CSS Tricks</a>: textarea 使用上的小技巧. 一些样式技巧.</li><li><a href=https://andreypopp.github.io/react-textarea-autosize/>开源的 react auto resize textarea</a>: 一个更好的方案二的实现, 源码优雅短小</li><li><a href=www.caniuse.com>can i use 兼容性检查工具</a>: execCommand, innerText, requireAnimationFrame, 等等各种各样属性的兼容性检查</li><li><a href=https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable>contenteditable MDN</a></li><li><a href=https://gist.github.com/Schniz/e398a630c81cfd8a3d1e>一个方案三的实现, a good demo</a></li><li><a href=http://www.zhangxinxu.com/wordpress/2016/01/contenteditable-plaintext-only/>小tip: 如何让contenteditable元素只能输入纯文本</a></li></ul>\",\n  \"extra\": {\n    \"_image-loader_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./doc/fe/高度自适应的 Textarea.md\n// module id = 836\n// module chunks = 18"],"sourceRoot":""}