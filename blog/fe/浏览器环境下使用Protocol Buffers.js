webpackJsonp([21,56],{833:function(s,a){s.exports={content:'<h3 id=在浏览器环境下使用protocol-buffers协议><a href=#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8protocol-buffers%E5%8D%8F%E8%AE%AE aria-hidden=true><span class="icon icon-link"></span></a>在浏览器环境下使用Protocol Buffers协议</h3><h4 id=什么是protocol-buffers？><a href=#%E4%BB%80%E4%B9%88%E6%98%AFprotocol-buffers%EF%BC%9F aria-hidden=true><span class="icon icon-link"></span></a>什么是Protocol Buffers？</h4><p>wiki上面有这样一段描述：</p><blockquote><p><strong>Protocol Buffers</strong> is a method of serializing structured data. It is useful in developing programs to communicate with each other over a wire or for storing data. The method involves an interface description language that describes the structure of some data and a program that generates source code from that description for generating or parsing a stream of bytes that represents the structured data.</p></blockquote><p>它是一种序列化数据格式，类似我们常用的JSON，XML。用的比较多的是在后台服务间进行数据通讯。</p><h3 id=概况：><a href=#%E6%A6%82%E5%86%B5%EF%BC%9A aria-hidden=true><span class="icon icon-link"></span></a>概况：</h3><h4 id=基本流程><a href=#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B aria-hidden=true><span class="icon icon-link"></span></a>基本流程</h4><h3 id=概况图前端应该怎么使用？><a href=#%E6%A6%82%E5%86%B5%E5%9B%BE%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F aria-hidden=true><span class="icon icon-link"></span></a><img src=http://eux-blog-static.bj.bcebos.com/%E6%A6%82%E5%86%B5%E5%9B%BE.png alt=概况图>前端应该怎么使用？</h3><p>在说怎么使用 Protocol Buffers 前先说一下具体涉及的几个概念：</p><ol><li>proto文件，用来定义需要的存储结构的文件。</li><li>proto文件编译器，用来将在proto文件定义的存储结构转化成需要运行的开发语言环境版本，比如转换为JS环境下版本。</li></ol><h4 id=1-编写proto文件><a href=#1-%E7%BC%96%E5%86%99proto%E6%96%87%E4%BB%B6 aria-hidden=true><span class="icon icon-link"></span></a>1. 编写proto文件</h4><p>下面这个例子是都是比较简单常用的数据类型；也可自定义一些数据类型，比如下面的ClassType，这个类型可以用到协议文件的任何结构里面。</p><pre><code class="hljs language-protobuf"data-query={} data-lang=protobuf><span class=hljs-comment>// common.proto</span>\n<span class=hljs-class><span class=hljs-keyword>enum</span> <span class=hljs-title>OSType</span></span>{\n    type_mac = <span class=hljs-number>1</span>;\n    type_win = <span class=hljs-number>2</span>;\n}</code></pre><pre><code class="hljs language-protobuf"data-query={} data-lang=protobuf><span class=hljs-comment>// msg.proto</span>\n<span class=hljs-keyword>import</span> <span class=hljs-string>"common.proto"</span>;\n\n<span class=hljs-class><span class=hljs-keyword>enum</span> <span class=hljs-title>ClassType</span></span>{\n    type_one = <span class=hljs-number>1</span>;\n    type_second = <span class=hljs-number>2</span>;\n}\n\n<span class=hljs-class><span class=hljs-keyword>message</span> <span class=hljs-title>oneMsg</span> </span>{\n    <span class=hljs-keyword>required</span> <span class=hljs-built_in>uint32</span> id = <span class=hljs-number>1</span>;\n \t<span class=hljs-keyword>required</span> <span class=hljs-built_in>string</span> name = <span class=hljs-number>2</span>;\n \t<span class=hljs-keyword>required</span> ClassType type = <span class=hljs-number>3</span>;\n \t<span class=hljs-keyword>optional</span> OSType osType = <span class=hljs-number>4</span>;\n}</code></pre><p>更多的字段说明可以参考官方说明：<a href=https://developers.google.com/protocol-buffers/docs/proto>https://developers.google.com/protocol-buffers/docs/proto</a></p><h4 id=2-选编译工具><a href=#2-%E9%80%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7 aria-hidden=true><span class="icon icon-link"></span></a>2. 选编译工具</h4><p><a href=https://github.com/google/protobuf/releases>goole官方工具</a> - google官方支持多语言，有一个统一的编译工具，不支持浏览器环境下的协议文件编译（也不建议这么做）。</p><p><a href=https://github.com/dcodeIO/protobuf.js>protobuf.js</a> - 第三方的一个针对JS环境的库</p><h4 id=3-编译proto文件基于protobufjs><a href=#3-%E7%BC%96%E8%AF%91proto%E6%96%87%E4%BB%B6%E5%9F%BA%E4%BA%8Eprotobufjs aria-hidden=true><span class="icon icon-link"></span></a>3. 编译proto文件(基于protobuf.js)</h4><ul><li><p>先install一下编译工具包</p><pre><code class="hljs language-shell"data-query={} data-lang=shell>npm install protobufjs --save</code></pre></li><li><p>使用编译工具把定义的proto文件编译成你想要的数据格式</p><pre><code class="hljs language-shell"data-query={} data-lang=shell><span class=hljs-meta>#</span><span class=bash> pbjs v6.7.0 参数格式</span>\npbjs -t json -w es6 -o msg.js msg.proto common.proto\n<span class=hljs-meta>\n#</span><span class=bash>pbjs v4.1.2 参数格式</span>\n<span class=hljs-meta>#</span><span class=bash>pbjs -s proto -t json  ./msg.proto > msg.json</span></code></pre><p>具体参数可以参考：<a href=https://github.com/dcodeIO/protobuf.js#pbjs-for-javascript>https://github.com/dcodeIO/protobuf.js#pbjs-for-javascript</a></p><p>常用的是<em>JSON</em>或者<em>JS模块</em>这两种模式；想直接使用proto文件？也是可以的，但是需要在生产环境引入protobuf.js的编译模块，并且性能会不如JS或者JSON这两种使用方式。</p><p>那JSON和JS模块这两个使用方式有什么区别？</p><p>本质上并没有任何区别！！！</p><p>但根据个人经验，如果用JSON的方式会更加可控，因为你可以选择性的使用这个JSON配置来在生产环境需要的时候再初始化协议相关工具函数。</p></li></ul><h4 id=4-使用产出的js工具函数处理数据><a href=#4-%E4%BD%BF%E7%94%A8%E4%BA%A7%E5%87%BA%E7%9A%84js%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE aria-hidden=true><span class="icon icon-link"></span></a>4. 使用产出的JS工具函数处理数据</h4><ul><li><p>序列化</p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-comment>// 基于protobufjs v6.7.0</span>\n<span class=hljs-keyword>import</span> * <span class=hljs-keyword>as</span> $protobuf <span class=hljs-keyword>from</span> <span class=hljs-string>"protobufjs/light"</span>;\n<span class=hljs-comment>// 基于protobufjs v4.1.2</span>\n<span class=hljs-comment>//import * as $protobuf from "protobufjs";</span>\n<span class=hljs-keyword>import</span> ProtoMsg <span class=hljs-keyword>from</span> <span class=hljs-string>\'msg.json\'</span>;\n\n<span class=hljs-comment>// 基于protobufjs v6.7.0</span>\n<span class=hljs-keyword>let</span> Msg = (<span class=hljs-keyword>new</span> $protobuf.Root()).addJSON(ProtoMsg);\n<span class=hljs-comment>// 基于protobufjs v4.1.2</span>\n<span class=hljs-comment>// let Msg = $protobuf.newBuilder({})["import"](ProtoMsg).build()</span>\n\nMsg.encode({\n    <span class=hljs-attr>id</span>: <span class=hljs-number>1</span>,\n    <span class=hljs-attr>name</span>: <span class=hljs-string>\'pb\'</span>\n    type: <span class=hljs-number>2</span>\n});\n<span class=hljs-comment>// &lt;Buffer></span></code></pre></li><li><p>反序列化</p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-comment>// 基于protobufjs v6.7.0</span>\n<span class=hljs-keyword>import</span> * <span class=hljs-keyword>as</span> $protobuf <span class=hljs-keyword>from</span> <span class=hljs-string>"protobufjs/light"</span>;\n<span class=hljs-comment>// 基于protobufjs v4.1.2</span>\n<span class=hljs-comment>//import * as $protobuf from "protobufjs";</span>\n<span class=hljs-keyword>import</span> ProtoMsg <span class=hljs-keyword>from</span> <span class=hljs-string>\'msg.json\'</span>;\n\n<span class=hljs-comment>// 基于protobufjs v6.7.0</span>\n<span class=hljs-keyword>let</span> Msg = (<span class=hljs-keyword>new</span> $protobuf.Root()).addJSON(ProtoMsg);\n<span class=hljs-comment>// 基于protobufjs v4.1.2</span>\n<span class=hljs-comment>// let Msg = $protobuf.newBuilder({})["import"](ProtoMsg).build()</span>\n\nMsg.decode(<span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>Buffer</span>></span>) // === {id: 1,name: \'pb\', type: 2}</span></code></pre></li></ul><p>###优势&amp劣势</p><p>####优势：</p><ul><li><strong>体积小</strong>, 相对XML和JSON，它表达同样的数据可以达到一个3到10倍的压缩效果。</li><li><strong>序列化和反序列化性能高</strong>，因为二进制序列的操作效率会比字符串要高，并且Protocol Buffers没有类似xml的词法文法分析，序列化和反序列化的步骤少很多。</li></ul><p>####劣势：</p><ul><li><strong>对于浏览器环境编译代码体积较大</strong>，因为预先加载数据的序列化和反序列化方法，会导致需要加载额外的js代码。</li><li>因为基于buffer，所以兼容性不如json和xml。</li></ul><h3 id=写在最后：><a href=#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E%EF%BC%9A aria-hidden=true><span class="icon icon-link"></span></a>写在最后：</h3><p>​ 在前端实践Protocol Buffers的过程中我们遇到好些代码体积和组织的问题；如果你的页面跟server数据通讯非常频繁的话可以考虑使用Protocol Buffers，比如频繁即时通讯；如果是控制台或者其他一些spa应用，还是需要权衡一下数据使用成本，代码体积和数据压缩的收益。</p><p>相关参考资料：</p><p><a href=https://developers.google.com/protocol-buffers/docs/overview>Protocol Buffers 官方</a></p><p><a href=https://github.com/google/protobuf>Protobuf</a></p><p><a href=https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html>Google Protocol Buffer 的使用和原理</a></p><p><a href=https://github.com/dcodeIO/protobuf.js>protobuf.js</a></p>',extra:{"_image-loader_":[]}}}});
//# sourceMappingURL=浏览器环境下使用Protocol Buffers.js.map