webpackJsonp([33,56],{821:function(n,a){n.exports={content:'<h4 id=为原生api添加功能，即继承原生api并进行扩展><a href=#%E4%B8%BA%E5%8E%9F%E7%94%9Fapi%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%8D%B3%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%94%9Fapi%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95 aria-hidden=true><span class="icon icon-link"></span></a>为原生API添加功能，即继承原生API并进行扩展</h4><p>这篇文章来源于一个需求：<strong>如何统计ajax请求从发起到成功返回所耗费的时间</strong>？ 如果在业务中每个请求的发起和结束时进行打点，计算差值的话，那么工作量将非常巨大，如果要求每个项目封装一个通用方法的话，对于我们这种有好几百个项目的部门来说也同样是不可能的，那么就需要对XMLHttpRequest本身进行功能扩展.</p><h4 id=实现原理解析><a href=#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90 aria-hidden=true><span class="icon icon-link"></span></a><strong>实现原理解析</strong></h4><p>不改变this指向的情况，比如下面这个例子，this指向始终是window,那么我们无需对this的指向做任何更改。</p><pre><code data-query={} data-lang>    //原函数\n    function a (v) {\n        console.log(v)\n    }\n\n    //创建一个变量b, 指向原函数，以保留原函数的功能\n    let b = a;\n\n    //覆写原函数\n    a = function (v) {\n        console.log(v + 1); //执行新增功能\n        b(v);      //执行原函数功能\n    }\n\n    a(1); // 2 1\n</code></pre><p>需要改变this指向</p><pre><code data-query={} data-lang>    //原函数\n    let obj = {\n        a: function(v) {\n            //这里this指向obj\n            this.v = v\n            console.log(this.v);\n        }\n    }\n\n    //创建一个变量b, 指针指向原函数, 但是对于b来说， this === window\n    let b = obj.a;\n\n    //覆写原函数\n    obj.a = function (v) {\n        let args = [].slice.call(arguments);\n        b.apply(this, args);      //原函数功能,需要将this重新指向obj\n        console.log(this.v + 1); //新增功能\n    }\n\n    obj.a(1); // 1 2\n</code></pre><p>实例1：在alert的时候console.log打印alert的值</p><pre><code data-query={} data-lang>(function () {\n    let a = alert;\n\n    alert = function (v) {\n        console.log(v);\n        a(v);\n    }\n\n    alert(1); // 控制台输出1，弹窗1\n})();\n</code></pre><p>实例2：在console.log的同时进行alert</p><pre><code data-query={} data-lang>(function () {\n    let a = console.log;\n\n    console.log = function () {\n        //将arguments转成数组，如果需要对参数做push、pop等操作的话需要转换，否则不需要\n        var args = [].slice.call(arguments);\n        a.apply(this, args); //这里就不能直接使用a(...args)\n        alert(args[0])\n    }\n\n    console.log(1); // 控制台输出1，弹窗1\n})();\n</code></pre><h4 id=方法总结><a href=#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93 aria-hidden=true><span class="icon icon-link"></span></a>方法总结</h4><p>step1：</p><p>先用一个变量，如<code>a</code>，指向原方法。</p><pre><code data-query={} data-lang>let a = console.log;\n</code></pre><p>step2：</p><p>新写一个函数覆盖原方法，增加你想要的扩展功能，并在其中调用step1中的<code>a</code>，并通过<code>apply</code>方法保证<code>a</code>执行的时候有正确的this指向和参数传递，保证原方法的正常使用。</p><pre><code data-query={} data-lang>console.log = function () {\n    var args = [].slice.call(arguments);\n    args.push(1); //如果对入参有修改，需要将arguments转换为Array.\n    a.apply(this, args); //这里就不能直接使用a(...args)\n    alert(args[0]);\n}\n</code></pre><p>虽然在一些情况下this指向不发生改变，无需使用apply，但是使用apply也可以得到正确的结果，从参数扩展、方便记忆的角度话可以统一成同一种模式。</p><p><strong>通过apply与call实现继承的方式</strong></p><ul><li>apply() 方法在<strong>指定 this 值和参数</strong>（参数以数组或类数组对象的形式存在）的情况下<strong>调用</strong>某个函数.</li><li>call() 方法在<strong>指定this值和若干个指定的参数值</strong>的前提下<strong>调用</strong>某个函数.</li><li><strong>注意</strong>： apply() 方法接受的是<strong>一个包含多个参数的数组</strong>，call() 方法接受的是<strong>若干个参数的列表</strong>.</li></ul><pre><code data-query={} data-lang>   fun.apply(thisArg, [argsArray])\n   fun.call(thisArg, ...argsArray)\n</code></pre><h4 id=参考资料><a href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 aria-hidden=true><span class="icon icon-link"></span></a>参考资料</h4><ul><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply>MDN Function.prototype.apply()</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call>MDN Function.prototype.call()</a></li></ul>',extra:{"_image-loader_":[]}}}});
//# sourceMappingURL=为原生api添加功能.js.map