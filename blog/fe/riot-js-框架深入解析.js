webpackJsonp([39,56],{815:function(s,a){s.exports={content:'<p>最近整理了下团队新人文档，对团队内使用的框架 riot.js 这部分内容做了一些总结。本文主要在 riot.js 源码 方面，分析一下 riot.js 的执行原理和使用优化。</p><h2 id=riotjs-简介><a href=#riotjs-%E7%AE%80%E4%BB%8B aria-hidden=true><span class="icon icon-link"></span></a>Riot.js 简介</h2><blockquote><p>Simple and elegant component-based UI library (Riot.js)</p></blockquote><p>riot.js 是一个简单优雅的 js UI框架。具有自定义标签，简单语法，API简单，体积小， 学习成本低等特点。riot.js 使用Model-View-Presenter (MVP)设计模式来组织代码， 这样它能够更模块化、更具可测试性且易于理解。riot.js 仅仅提供了帮助UI渲染相关的基础功能 ，并不具备其它复杂的功能，因此其体积很小，压缩后仅有 10.39KB (react.min.js 大约 47.6KB )， 很适合组件类的业务开发。</p><h3 id=hello-world><a href=#hello-world aria-hidden=true><span class="icon icon-link"></span></a>Hello world</h3><p>尝试 Riot.js 最简单的方法是使用 <a href=https://jsfiddle.net/CaelumTian/c9j9jvkz/>JSFiddle Hello Riot.js</a> 例子。你可以在浏览器中打开它。 或者你也可以创建一个 .html 文件，然后通过如下方式引入Riot.js:</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>&lt;script src=<span class=hljs-string>"https://cdn.jsdelivr.net/npm/riot@3.7/riot+compiler.min.js"</span>><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>scipt</span>></span></span> </code></pre><h3 id=自定义标签><a href=#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE aria-hidden=true><span class="icon icon-link"></span></a>自定义标签</h3><p>Riot.js 采用自定义标签的语法，每个自定义标签都可以看做是一个组件(Riot.js Tag 对象)，自定义标签将相关的 HTML 和 JavaScript 粘合在一起，成为一个可重用的组件。可以认为它同时具有 React 和 Polymer 的优点，但是语法更友好，学习成本更小。</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>&lt;riot-demo>  \n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>span</span>></span>{ title }<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>></span></span>   \n    &lt;script>\n        <span class=hljs-keyword>this</span>.title = <span class=hljs-string>"Hello World"</span>;\n    <span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></span>\n&lt;<span class=hljs-regexp>/riot-demo> </span></code></pre><p>在团队中，我们会使用 webpack 来构建 riot 项目。每个组件都被写成一个 <code>*.tag</code> 文件。</p><h2 id=riotjs-基本执行原理><a href=#riotjs-%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86 aria-hidden=true><span class="icon icon-link"></span></a>Riot.js 基本执行原理</h2><p>一个riot自定义标签在日常开发中从源码到呈现在页面上主要分为三步：编译（一般利用官方自带编译工具）、注册（riot.tag()）和加载（riot.mount()），如下图所示：<br><img src=https://caelumtian.github.io/2017/09/21/riot-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/a.png alt width=387 height=365></p><h3 id=编译><a href=#%E7%BC%96%E8%AF%91 aria-hidden=true><span class="icon icon-link"></span></a>编译</h3><p>编译阶段的主要工作就是将riot语法写的.tag文件转换为可执行的.js文件，这部分主要靠编译器来完成。例如：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>riot.tag2(<span class=hljs-string>\'content-demo\'</span>, <span class=hljs-string>\'&lt;h1>{message}&lt;/h1>\'</span>, <span class=hljs-string>\'\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>opts</span>) </span>{\n\t<span class=hljs-keyword>this</span>.message = <span class=hljs-string>\'hello world\'</span>;\n}); </code></pre><p>riot.tag2 函数在 riot.js 源码中的 core.js 文件中，代码如下：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tag2</span>(<span class=hljs-params>name, tmpl, css, attrs, fn</span>) </span>{\n    <span class=hljs-keyword>if</span> (css) styleManager.add(css, name)\n    <span class=hljs-comment>// tags implementation cache 标签接口缓存</span>\n    __TAG_IMPL[name] = {\n        name,\n        tmpl,\n        attrs,\n        fn\n    }\n    <span class=hljs-keyword>return</span> name\n}</code></pre><p>参数含义如下：</p><ul><li>name: riot 自定义标签的名称</li><li>tmpl: 标签的html内容</li><li>css: <code></code> 标签中的内容</li><li>attrs: riot 自定义标签的属性</li><li>fn: 用户自定义函数,即 <code></code> 标签中的内容</li></ul><p><code>riot.tag2()</code> 函数将 riot tag 注册到了 <code>__TAG_IMP</code> 对象中，方便之后的使用，css部分则被添加到了 <code>byName</code> 变量中，用于之后统一添加到页面中。在源代码中，还有一个 <code>riot.tag()</code>函数，这个函数用于直接直接创建一个 riot tag 实例的接口，而 <code>riot.tag2()</code> 是暴露给编辑器的接口，本质上功能是一样的。</p><h3 id=加载-riotmount><a href=#%E5%8A%A0%E8%BD%BD-riotmount aria-hidden=true><span class="icon icon-link"></span></a>加载 riot.mount()</h3><p>组件被注册好以后，并没有被渲染，直到我们调用 <code>riot.mount()</code> 函数后，相应的组件才会渲染到页面上。源码如下：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>mount</span>(<span class=hljs-params>selector, tagName, opts</span>) </span>{\n    <span class=hljs-keyword>const</span> tags = []\n    <span class=hljs-keyword>let</span> elem, allTags\n    <span class=hljs-comment>// root {HTMLElement} riot-tag 标签节点</span>\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>pushTagsTo</span>(<span class=hljs-params>root</span>) </span>{\n        <span class=hljs-keyword>if</span> (root.tagName) {\n            <span class=hljs-keyword>let</span> riotTag = getAttr(root, IS_DIRECTIVE),    <span class=hljs-comment>// 要么 data-is 要么 root.tagName 本身</span>\n                tag\n            <span class=hljs-comment>// ① 设置 data-is 属性指向</span>\n            <span class=hljs-keyword>if</span> (tagName &amp&amp riotTag !== tagName) {\n                riotTag = tagName\n                setAttr(root, IS_DIRECTIVE, tagName)\n            }\n            <span class=hljs-comment>// ② mountTo 创建一个新的 riot tag 实例</span>\n            tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n            <span class=hljs-keyword>if</span> (tag)\n                tags.push(tag)\n        } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (root.length)\n            each(root, pushTagsTo)\n    }\n    <span class=hljs-comment>// DOM 注入 style 标签</span>\n    styleManager.inject()\n    <span class=hljs-keyword>if</span> (isObject(tagName)) {\n        opts = tagName\n        tagName = <span class=hljs-number>0</span>\n    }\n    <span class=hljs-keyword>if</span> (isString(selector)) {\n        selector = selector === <span class=hljs-string>\'*\'</span> ?\n            allTags = selectTags() :\n            selector + selectTags(selector.split(<span class=hljs-regexp>/, */</span>))\n        <span class=hljs-comment>// ③ 利用 $$ 来判断 这些 tag 是否已经挂载在 html 上面</span>\n        elem = selector ? $$(selector) : []\n    } <span class=hljs-keyword>else</span>\n        elem = selector\n    <span class=hljs-comment>// 将所有元素挂载在根元素中</span>\n    <span class=hljs-keyword>if</span> (tagName === <span class=hljs-string>\'*\'</span>) {\n        tagName = allTags || selectTags()\n        <span class=hljs-keyword>if</span> (elem.tagName)\n            <span class=hljs-comment>// 查找elem下的 tagName</span>\n            elem = $$(tagName, elem)\n        <span class=hljs-keyword>else</span> {\n            <span class=hljs-comment>// 将查找到的所有节点都 放入 nodeList中</span>\n            <span class=hljs-keyword>var</span> nodeList = []\n            each(elem, _el => nodeList.push($$(tagName, _el)))\n            elem = nodeList\n        }\n        tagName = <span class=hljs-number>0</span>\n    }\n    pushTagsTo(elem)\n    <span class=hljs-keyword>return</span> tags\n}     </code></pre><p>当调用 riot.mount 后，通过 selector 参数来查找 html 页面上对应的节点。<code>不在 html 上的节点是不会被渲染的</code>。③处代码为查找过程，其中$$为 <code>document.querySelectAll</code>。之后调用 pushTagsTo 函数来渲染 riot tag。<br><code>IS_DIRECTIVE = \'data-is\'</code> 渲染前，要检查是否含有 tagName 参数，如果有的话即为 上述 riot.mount 的第三个用法。此时需要检测 root 的 data-is 属性值是否和 tagName 相等，如①处。不相等则将 root 设置其 data-is 为 tagName。</p><h3 id=取消注册-riotunregister><a href=#%E5%8F%96%E6%B6%88%E6%B3%A8%E5%86%8C-riotunregister aria-hidden=true><span class="icon icon-link"></span></a>取消注册 riot.unregister()</h3><p>riot.unregister() 源码十分简单，如下：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>unregister</span>(<span class=hljs-params>name</span>) </span>{\n    __TAG_IMPL[name] = <span class=hljs-literal>null</span>\n}</code></pre><h2 id=riotjs-组件><a href=#riotjs-%E7%BB%84%E4%BB%B6 aria-hidden=true><span class="icon icon-link"></span></a>Riot.js 组件</h2><p>在 Riot.js 中，每个自定义标签都可以看成是一个组件，每个组件其实本质上都是一个 <code>Tag</code> 对象, 里面包含了对象的各种属性和方法</p><h3 id=tag-类><a href=#tag-%E7%B1%BB aria-hidden=true><span class="icon icon-link"></span></a>Tag 类</h3><p><code>Tag</code> 类简化源代码如下：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-comment>// impl 包含组件的模板，逻辑等属性  </span>\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Tag</span>(<span class=hljs-params>impl = {}, conf = {}, innerHTML</span>) </span>{\n    ...各种属性初始化\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'__\'</span>, {...})\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'_riot_id\'</span>, ++__uid)\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'refs\'</span>, {})\n    ...\n    <span class=hljs-comment>// 定义组件更新方法</span>\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'update\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tagUpdate</span>(<span class=hljs-params>data</span>)</span>{...}.bind(<span class=hljs-keyword>this</span>))\n    <span class=hljs-comment>// 定义组件 mixin 方法</span>\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'update\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tagMixin</span>(<span class=hljs-params>data</span>)</span>{...}.bind(<span class=hljs-keyword>this</span>))\n    <span class=hljs-comment>// 定义组件加载方法</span>\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'mount\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tagMount</span>(<span class=hljs-params>data</span>)</span>{...}.bind(<span class=hljs-keyword>this</span>))\n    <span class=hljs-comment>// 定义组件卸载方法</span>\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'mount\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tagUnmount</span>(<span class=hljs-params>data</span>)</span>{...}.bind(<span class=hljs-keyword>this</span>))\n}</code></pre><h3 id=组件的生命周期><a href=#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F aria-hidden=true><span class="icon icon-link"></span></a>组件的生命周期</h3><p>riot 组件状态分为以下几个部分：</p><ul><li>before-mount：标签被加载之前</li><li>mount：标签实例被加载到页面上以后</li><li>update：允许在更新之前重新计算上下文数据</li><li>updated：标签模板更新后</li><li>before-unmount：标签实例被卸载之前</li><li>unmount：标签实例被从页面上卸载后</li></ul><img src=https://caelumtian.github.io/images/b.png alt width=675 height=848><p>riot.js 采用事件驱动的方式来进行通讯，我们可以采用如下函数来监听上面的事件，例如处理 update 事件：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>&lt;riot-demo>\n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=actionscript>\n        <span class=hljs-keyword>this</span>.on(<span class=hljs-string>\'update\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>()</span> </span>{\n            <span class=hljs-comment>// 标签更新后的处理</span>\n        })\n    </span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></span>\n&lt;<span class=hljs-regexp>/riot-demo></span></code></pre><h3 id=再谈组件加载><a href=#%E5%86%8D%E8%B0%88%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD aria-hidden=true><span class="icon icon-link"></span></a>再谈组件加载</h3><p>当我们调用 riot.mount() 渲染指定组件的时候，riot 会从 <code>__TAG_IMPL</code> 中获取相对应的已经注册好的模板内容，并生成相应的 Tag 实例对象。并且触发其上的 Tag.mount() 函数，最后将 Tag 对象缓存到 <code>__TAGS_CACHE</code> 中。代码如下：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>mountTo</span>(<span class=hljs-params>root, tagName, opts, ctx</span>) </span>{\n    <span class=hljs-keyword>var</span> impl = __TAG_IMPL[tagName],   <span class=hljs-comment>// 获取 html 模板</span>\n        implClass = __TAG_IMPL[tagName].class, <span class=hljs-comment>// ?</span>\n        tag = ctx || (implClass ? <span class=hljs-built_in>Object</span>.create(implClass.prototype) : {}),\n        innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n    <span class=hljs-keyword>var</span> conf = extend({\n        <span class=hljs-attr>root</span>: root,\n        <span class=hljs-attr>opts</span>: opts\n    }, {\n        <span class=hljs-attr>parent</span>: opts ? opts.parent : <span class=hljs-literal>null</span>\n    })\n    <span class=hljs-keyword>if</span> (impl &amp&amp root) Tag.apply(tag, [impl, conf, innerHTML]);\n    <span class=hljs-keyword>if</span> (tag &amp&amp tag.mount) {\n        tag.mount(<span class=hljs-literal>true</span>)\n        <span class=hljs-comment>// add this tag to the virtualDom variable</span>\n        <span class=hljs-keyword>if</span> (!contains(__TAGS_CACHE, tag)) __TAGS_CACHE.push(tag)\n    }\n    <span class=hljs-keyword>return</span> tag\n}</code></pre><p>组件加载阶段，首先会整理标签上所有的 attribute 的内容，区分普通属性，和带有表达式 expr 的属性。</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'mount\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tagMount</span>(<span class=hljs-params></span>) </span>{\n    ...\n    parseAttributes.apply(parent, [root, root.attributes, (attr, expr) => {\n        <span class=hljs-comment>// 检测 expr 是否在 RefExpr 的原型链中</span>\n        <span class=hljs-keyword>if</span> (!isAnonymous &amp&amp RefExpr.isPrototypeOf(expr)) expr.tag = <span class=hljs-keyword>this</span>;\n        <span class=hljs-comment>// 挂载在 root.attributs 上面 root 为组件所在的 dom 对象</span>\n        attr.expr = expr\n        instAttrs.push(attr)\n    }])   \n    <span class=hljs-comment>// impl 对象包含组件上的各种属性，包括模板，逻辑等内容</span>\n    implAttrs = []\n    walkAttrs(impl.attrs, (k, v) => {\n        implAttrs.push({\n            <span class=hljs-attr>name</span>: k,\n            <span class=hljs-attr>value</span>: v\n        })\n    })\n    <span class=hljs-comment>// 检查的是 implAttrs</span>\n    parseAttributes.apply(<span class=hljs-keyword>this</span>, [root, implAttrs, (attr, expr) => {\n        <span class=hljs-keyword>if</span> (expr) expressions.push(expr)   <span class=hljs-comment>//插入表达式</span>\n        <span class=hljs-keyword>else</span> setAttr(root, attr.name, attr.value)\n    }])\n    ... \n}).bind(<span class=hljs-keyword>this</span>)</code></pre><p>初始化这些表达式内容，然后为组件添加全局注册的mixin 内容。接下来，会执行我们为组件添加的函数内容，此时触发 before-mount 事件。触发完毕后，解析标签上的表达式，比如 if each 等内容，然后执行组件的 update() 函数。</p><p>在 update() 函数中，首先会检查用户是否定义了组件的 shouldUpdate() 函数，如果有定义则传入两个参数，第一个是想要更新的内容(即调用this.update() 时传入的参数)。第二个为接收的父组件更新的 opts 内容。若该函数返回值为 true 则更新渲染，否则放弃。 (这里需要注意，Tag.mount() 阶段由于组件尚未处于记载完毕状态，因此不会触发 shouldUpdate() 函数)。</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'update\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tagUpdate</span>(<span class=hljs-params>data</span>) </span>{\n    ...\n    <span class=hljs-comment>// shouldUpdate 返回值检测</span>\n    <span class=hljs-keyword>if</span> (canTrigger &amp&amp <span class=hljs-keyword>this</span>.isMounted &amp&amp isFunction(<span class=hljs-keyword>this</span>.shouldUpdate) &amp&amp !<span class=hljs-keyword>this</span>.shouldUpdate(data, nextOpts)) {\n        <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>\n    }\n    ...\n    <span class=hljs-comment>// 扩展opts</span>\n    extend(opts, nextOpts)\n    <span class=hljs-keyword>if</span> (canTrigger) <span class=hljs-keyword>this</span>.trigger(<span class=hljs-string>\'update\'</span>, data)\n    update.call(<span class=hljs-keyword>this</span>, expressions)\n    <span class=hljs-keyword>if</span> (canTrigger) <span class=hljs-keyword>this</span>.trigger(<span class=hljs-string>\'updated\'</span>)\n    <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>\n}).bind(<span class=hljs-keyword>this</span>);</code></pre><p>之后会触发 update 事件，开始渲染新的组件。渲染完毕后触发 updated 事件。</p><p>加载完毕后，修改组件状态 defineProperty(this, \'isMounted\', true)。如果渲染的组件不是作为子组件的话，我们就触发自身的 mount 事件。否则的话，需要等到父组件加载完毕后，或者更新完毕后(已经加载过了)，再触发。</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'mount\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>tagMount</span>(<span class=hljs-params></span>) </span>{\n    ...\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'root\'</span>, root)\n    defineProperty(<span class=hljs-keyword>this</span>, <span class=hljs-string>\'isMounted\'</span>, <span class=hljs-literal>true</span>)\n    <span class=hljs-keyword>if</span> (skipAnonymous) <span class=hljs-keyword>return</span>\n    <span class=hljs-comment>// 如果不是子组件则触发</span>\n    <span class=hljs-keyword>if</span> (!<span class=hljs-keyword>this</span>.parent) {\n        <span class=hljs-keyword>this</span>.trigger(<span class=hljs-string>\'mount\'</span>)\n    }\n    <span class=hljs-comment>// 否则需要等待父组件的状态渲染状态</span>\n    <span class=hljs-keyword>else</span> {\n        <span class=hljs-keyword>const</span> p = getImmediateCustomParentTag(<span class=hljs-keyword>this</span>.parent)\n        p.one(!p.isMounted ? <span class=hljs-string>\'mount\'</span> : <span class=hljs-string>\'updated\'</span>, () => {\n            <span class=hljs-keyword>this</span>.trigger(<span class=hljs-string>\'mount\'</span>)\n        })\n    }\n    <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>\n}).bind(<span class=hljs-keyword>this</span>) </code></pre><p>当我们调用 tag.unmount 卸载组件的时候，首先会触发 before-unmount 事件。再接下来清除所有的属性和事件监听等内容后，触发 ‘unmount’ 事件。</p><h2 id=组件更新原理><a href=#%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86 aria-hidden=true><span class="icon icon-link"></span></a>组件更新原理</h2><p>在 riot.js 中，想要更新组件我们必须手动调用 tag.update() 方法才可以或者通过绑定 dom 事件触发(通过模板绑定的事件，会在回调执行完毕后自动触发 tag.update )，并不能做到实时的更新处理。例如：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>&lt;riot-demo>\n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>h1</span>></span>{ title }<span class=hljs-tag>&lt;/<span class=hljs-name>h1</span>></span></span>\n    &lt;button click={ handleClick }>修改内容&lt;<span class=hljs-regexp>/button>\n    &lt;script>\n        this.title = "标题"\n        handleClick() {\n            this.title = "新标题";\n            this.update();   /</span><span class=hljs-regexp>/ 调用 update 方法才能重新渲染组件\n        }\n    &lt;/</span>script>\n<span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>riot-demo</span>></span></span></code></pre><p>riot.js 并没有提供 virtual dom 的功能，而是实现了一个粗粒度的 virtual dom。riot.js 为每个组件创建的 tag 对象中都保存一个 expressions 数组，更新的时候遍历 expressions 数组，对比旧值，如果有变化就更新DOM。这种更新机制类似angular的脏检查，但是仅有一轮检查（单项数据流）。更新处理依照模板类型来处理：</p><ul><li>文本内容的，直接： dom.nodeValue = value</li><li>值为空，而且关联的 DOM 属性是 checked/selected 等这种没有属性值的，移除对应的属性</li><li>值为函数的，则进行事件绑定</li><li>属性名为 if，则做条件判断处理</li><li>做了 show/hide 的语法糖处理</li></ul><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>toggleVisibility</span>(<span class=hljs-params>dom, show</span>) </span>{\n    dom.style.display = show ? <span class=hljs-string>\'\'</span> : <span class=hljs-string>\'none\'</span>\n    dom[<span class=hljs-string>\'hidden\'</span>] = show ? <span class=hljs-literal>false</span> : <span class=hljs-literal>true</span>\n}</code></pre><ul><li>普通属性的，直接设置其值</li></ul><p>riot.js 和 react 一样也有 props(静态，riot 中为 opts) 和本身数据(动态)，具有和 react 一样的输入。但是输出的时候，由于没有 virtual dom UI的更新并没有集中处理，是分散的。<br>riot.js 采用的这种方式，代码量上大大的减少，但是也带来了比较严重的性能问题。</p><h3 id=更新性能问题><a href=#%E6%9B%B4%E6%96%B0%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98 aria-hidden=true><span class="icon icon-link"></span></a>更新性能问题</h3><p>首先我们来看一段 vue 代码：</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>id</span>=<span class=hljs-string>"demo"</span>></span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>ul</span>></span>\n        <span class=hljs-tag>&lt;<span class=hljs-name>li</span> <span class=hljs-attr>v-for</span>=<span class=hljs-string>"item in items"</span>></span>\n            {{ item.name }} --- {{ item.age }}\n        <span class=hljs-tag>&lt;/<span class=hljs-name>li</span>></span>\n    <span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>></span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>button</span> <span class=hljs-attr>v-on:click</span>=<span class=hljs-string>"handleClick"</span>></span>更新列表项<span class=hljs-tag>&lt;/<span class=hljs-name>button</span>></span>\n<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span> </code></pre><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> demo = <span class=hljs-keyword>new</span> Vue({\n    <span class=hljs-attr>el</span>: <span class=hljs-string>\'#demo\'</span>,\n    <span class=hljs-attr>data</span>: {\n        <span class=hljs-attr>items</span>: [\n          { <span class=hljs-attr>name</span>: <span class=hljs-string>\'tgy\'</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>23</span>},\n        ]\n    },\n    <span class=hljs-attr>methods</span>: {\n        <span class=hljs-attr>handleClick</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\n            <span class=hljs-keyword>this</span>.items = [\n                { <span class=hljs-attr>name</span>: <span class=hljs-string>\'tgy\'</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>23</span>},\n                { <span class=hljs-attr>name</span>: <span class=hljs-string>\'hy\'</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>22</span>},\n            ]\n        }\n    },\n    <span class=hljs-attr>mounted</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\n         <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"组件挂载完毕"</span>);\n         <span class=hljs-built_in>document</span>.querySelector(<span class=hljs-string>"li"</span>).extraType = <span class=hljs-string>"origin"</span>;\n    },\n    <span class=hljs-attr>updated</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\n         <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"组件更新完毕"</span>);\n         <span class=hljs-built_in>console</span>.log(<span class=hljs-built_in>document</span>.querySelector(<span class=hljs-string>"li"</span>).extraType);\n    }\n}) </code></pre><p>代码很简单，单击按钮，为列表添加一条新数据。在组件挂载完毕后，为第一个 li 的 property 上面添加了 extraType 属性。列表更新后，再去访问这个 li 的 extraType 属性。运行结果如下：</p><img src=https://caelumtian.github.io/2017/10/18/riot-js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/b.png alt width=142 height=69><p>不出意料，可以正常访问到 li 的type属性。这说明了，在更新过程中，第一个 li 节点仅仅是 textContent 发生了改变而不是重新创建的。这样的结果得益于 virtual dom 算法，保证更新最小变动。同样的我们用 riot 来重写上面的代码。</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>content-demo</span>></span>\n   <span class=hljs-tag>&lt;<span class=hljs-name>ul</span>></span>\n      <span class=hljs-tag>&lt;<span class=hljs-name>li</span> <span class=hljs-attr>each</span>=<span class=hljs-string>{</span> <span class=hljs-attr>items</span> }></span>{ name } -- { age }<span class=hljs-tag>&lt;/<span class=hljs-name>li</span>></span>\n   <span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>></span>\n   <span class=hljs-tag>&lt;<span class=hljs-name>button</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"btn"</span> <span class=hljs-attr>click</span>=<span class=hljs-string>{</span> <span class=hljs-attr>handleClick</span> }></span>订阅内容<span class=hljs-tag>&lt;/<span class=hljs-name>button</span>></span>  \n   <span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>\n        <span class=hljs-keyword>let</span> self = <span class=hljs-keyword>this</span>;\n        <span class=hljs-keyword>this</span>.items = [\n            {<span class=hljs-string>"name"</span>: <span class=hljs-string>"tgy"</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>23</span>}\n        ];\n        handleClick() {\n            <span class=hljs-keyword>this</span>.items = [\n                {<span class=hljs-string>"name"</span>: <span class=hljs-string>"tgy"</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>23</span>},\n                {<span class=hljs-string>"name"</span>: <span class=hljs-string>"hy"</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>22</span>}\n            ]\n        }\n        <span class=hljs-keyword>this</span>.on(<span class=hljs-string>\'mount\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\n            <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"组件加载完毕"</span>);\n            <span class=hljs-built_in>document</span>.querySelector(<span class=hljs-string>"li"</span>).extraType = <span class=hljs-string>"origin"</span>;\n        })\n        <span class=hljs-keyword>this</span>.on(<span class=hljs-string>\'updated\'</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\n            <span class=hljs-built_in>console</span>.log(<span class=hljs-string>"组件更新完毕"</span>);\n            <span class=hljs-built_in>console</span>.log(<span class=hljs-built_in>document</span>.querySelector(<span class=hljs-string>"li"</span>).extraType);\n        })\n   </span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>\n<span class=hljs-tag>&lt;/<span class=hljs-name>content-demo</span>></span></code></pre><p>查看运行结果：</p><img src=https://caelumtian.github.io/2017/10/18/riot-js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/c.png alt width=165 height=66><p>extraType 找不到了，所有的 li 节点都被重新构建了。这里面发生了什么，查看源码 /tag/each.js。渲染逻辑代码如下：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>_each</span>(<span class=hljs-params>dom, parent, expr</span>) </span>{\n    ...\n    expr.update = <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>updateEach</span>(<span class=hljs-params></span>) </span>{\n        ...\n        each(items, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>item, i</span>) </span>{\n            <span class=hljs-comment>// 仅仅记录 items 是对象的</span>\n            <span class=hljs-keyword>var</span>\n                doReorder = mustReorder &amp&amp <span class=hljs-keyword>typeof</span> item === T_OBJECT &amp&amp !hasKeys,\n                <span class=hljs-comment>// 旧数据</span>\n                oldPos = oldItems.indexOf(item),\n                <span class=hljs-comment>// 是新的</span>\n                isNew = oldPos === <span class=hljs-number>-1</span>,\n                pos = !isNew &amp&amp doReorder ? oldPos : i,\n                tag = tags[pos],\n                <span class=hljs-comment>// 必须追加</span>\n                mustAppend = i >= oldItems.length,\n                <span class=hljs-comment>// 必须创建 isNew</span>\n                mustCreate = doReorder &amp&amp isNew || !doReorder &amp&amp !tag\n                <span class=hljs-comment>// 有key值得时候需要 mkitem</span>\n            item = !hasKeys &amp&amp expr.key ? mkitem(expr, item, i) : item\n            <span class=hljs-comment>// 必须创建一个新 tag </span>\n            <span class=hljs-keyword>if</span> (mustCreate) {\n                tag = <span class=hljs-keyword>new</span> Tag(impl, {\n                    parent,\n                    isLoop,\n                    isAnonymous,\n                    tagName,\n                    <span class=hljs-attr>root</span>: dom.cloneNode(isAnonymous),\n                    item,\n                    <span class=hljs-attr>index</span>: i,\n                }, dom.innerHTML)\n\n                <span class=hljs-comment>// mount the tag</span>\n                tag.mount()\n                <span class=hljs-keyword>if</span> (mustAppend)\n                    append.apply(tag, [frag || root, isVirtual])\n                <span class=hljs-keyword>else</span>\n                    insert.apply(tag, [root, tags[i], isVirtual])\n\n                <span class=hljs-keyword>if</span> (!mustAppend) oldItems.splice(i, <span class=hljs-number>0</span>, item)\n                tags.splice(i, <span class=hljs-number>0</span>, tag)\n                <span class=hljs-keyword>if</span> (child) arrayishAdd(parent.tags, tagName, tag, <span class=hljs-literal>true</span>)\n            } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (pos !== i &amp&amp doReorder) {\n                <span class=hljs-comment>// move</span>\n                <span class=hljs-comment>// 移动</span>\n                <span class=hljs-keyword>if</span> (contains(items, oldItems[pos])) {\n                    move.apply(tag, [root, tags[i], isVirtual])\n                    <span class=hljs-comment>// move the old tag instance</span>\n                    tags.splice(i, <span class=hljs-number>0</span>, tags.splice(pos, <span class=hljs-number>1</span>)[<span class=hljs-number>0</span>])\n                    <span class=hljs-comment>// move the old item</span>\n                    oldItems.splice(i, <span class=hljs-number>0</span>, oldItems.splice(pos, <span class=hljs-number>1</span>)[<span class=hljs-number>0</span>])\n                }\n                <span class=hljs-keyword>if</span> (expr.pos) tag[expr.pos] = i\n                <span class=hljs-keyword>if</span> (!child &amp&amp tag.tags) moveNestedTags.call(tag, i)\n            }\n            <span class=hljs-comment>// 缓存原始数据到节点上</span>\n            tag.__.item = item\n            tag.__.index = i\n            tag.__.parent = parent;\n            <span class=hljs-comment>// 如果不是创建的，我们需要更新节点内容。</span>\n            <span class=hljs-keyword>if</span> (!mustCreate) tag.update(item)\n        })\n        <span class=hljs-comment>// remove the redundant tags</span>\n        <span class=hljs-comment>// 删除多余的标签</span>\n        unmountRedundant(items, tags)\n        <span class=hljs-comment>// 记录旧的数据</span>\n        <span class=hljs-comment>// clone the items array</span>\n        oldItems = items.slice()\n        <span class=hljs-comment>// dom 插入节点</span>\n        root.insertBefore(frag, placeholder)\n    }\n}  </code></pre><p>这段为列表渲染逻辑，遍历新的数据items中的每一下 item。在原始数据 oldItems 中去查找(oldItems.indexOf(itemId))，是否存在 item 项。如果不存在，则标记 isNews 为 true。之后走到 if 的 mustCreaete 为 true 的分支，去创建一个新的 tag(将 li 节点看成是一个tag)。以此类推，当全部创建完毕后，删除旧的节点(unmountRedundant(items, tags))。在断点下，可以清楚看到节点的变化情况：</p><img src=https://caelumtian.github.io/2017/10/18/riot-js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/d.gif alt width=178 height=72><h3 id=优化更新><a href=#%E4%BC%98%E5%8C%96%E6%9B%B4%E6%96%B0 aria-hidden=true><span class="icon icon-link"></span></a>优化更新</h3><p>综上所述，riot.js 的更新逻辑仅仅是判断新旧数据项是否为同一对象。为此，为了减少 DOM 的变动，降低渲染逻辑。我们修改<code>handleClick</code>函数：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript>handleClick() {\n    <span class=hljs-keyword>this</span>.items.push({<span class=hljs-string>"name"</span>: <span class=hljs-string>"hy"</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>22</span>})\n} </code></pre><p>这样输出结果就会和 vue 的保持一致，并没有创建新的 tag，而是利用了已经存在的内容。源码中，这种情况下 isNews 为 false，从而避开了 创建标签。而仅仅是通过 <code>tags.splice(i, 0, tags.splice(pos, 1)[0]);</code> 来移动位置，<code>if (!mustCreate) { tag.update(item); }</code> 更新节点内容。<br>保证数据项对象地址不变，仅仅是修改上面的不可变对象的值，将大大的提高 riot.js 的渲染效率。</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-comment>// 更新第一个li内容  </span>\n\n<span class=hljs-comment>// 不推荐写法，对象发生变化；</span>\n<span class=hljs-keyword>this</span>.items[<span class=hljs-number>0</span>] = {<span class=hljs-string>"name"</span>: <span class=hljs-string>"hy"</span>, <span class=hljs-attr>age</span>: <span class=hljs-number>23</span>};   \n\n<span class=hljs-comment>// 推荐写法，仅仅是修改对象中的值</span>\n<span class=hljs-keyword>this</span>.items[<span class=hljs-number>0</span>].name = <span class=hljs-string>"hy"</span>;\n<span class=hljs-keyword>this</span>.items[<span class=hljs-number>0</span>].age = <span class=hljs-number>22</span>;</code></pre><p>保证源数据对象的不变，仅仅改变其上面的值，这样就能减少 riot.js 渲染过程中，创建新的 <code>tag</code> 对象的开销。</p><h1 id=参考资料><a href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 aria-hidden=true><span class="icon icon-link"></span></a>参考资料</h1><ul><li><a href=https://techblog.toutiao.com/2016/12/13/riotjs/>头条PC站基于RIOT的组件化开发实践</a></li><li><a href=http://imweb.io/topic/573e766f1156025b1dce9404>深入探讨前端UI框架</a></li><li><a href=https://gist.github.com/teabyii/7f6bddf5934915081c5d>Riot 源码阅读笔记</a></li><li><a href=https://github.com/riot/riot/blob/7fe907d161731568c4d7755ab05493ddec12c6fd/lib/browser/tag>Riot.js 源代码</a></li><li><a href=http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html>MVC，MVP 和 MVVM 的图示</a></li></ul>',
extra:{"_image-loader_":[]}}}});
//# sourceMappingURL=riot-js-框架深入解析.js.map