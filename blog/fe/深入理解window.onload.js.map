{"version":3,"sources":["webpack:///blog/fe/深入理解window.onload.js","webpack:///./doc/fe/深入理解window.onload.md"],"names":["webpackJsonp","835","module","exports","content","extra","_image-loader_"],"mappings":"AAAAA,cAAc,GAAG,KAEXC,IACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,ygPACAC,OACAC","file":"blog/fe/深入理解window.onload.js","sourcesContent":["webpackJsonp([19,56],{\n\n/***/ 835:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<p><strong>现象：</strong>在一个 Hybrid 应用中，用户反馈弱网条件下页面的进度条总是不消失，最后发现是页面接口先于其他资源返回，而接口中包含大量图片导致了 <code>onload</code> 会推迟，从而客户端控制的进度条不会消失，页面调用客户端的方法不会执行。</p><h4 id=先放结论><a href=#%E5%85%88%E6%94%BE%E7%BB%93%E8%AE%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>先放结论</h4><p><strong>onload的触发时机：</strong> JS 加载并执行完毕且页面中所有外链资源加载完成之后大约 3 - 4ms（这个值跟机型和浏览器有关）</p><p><strong>最佳实践：</strong> JS代码的执行要放到onload里。如果是服务端渲染带图片的列表，图片最好由JS异步加载，避免阻塞onload。</p><h4 id=1、onload不是立即触发的><a href=#1%E3%80%81onload%E4%B8%8D%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%A7%A6%E5%8F%91%E7%9A%84 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>1、onload不是立即触发的</h4><p>请问下面哪个alert先触发？</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n}\\nsetTimeout(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n    alert(<span class=hljs-string>'timeout'</span>);\\n}, <span class=hljs-number>2</span>)</code></pre><p>答案是 <code>timeout</code> 先触发。而在我的电脑上，把 <code>timeout</code> 的值调成 5 或 5 以上，就是 <code>onload</code> 先触发了。</p><h4 id=2、js的执行对onload有影响><a href=#2%E3%80%81js%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AF%B9onload%E6%9C%89%E5%BD%B1%E5%93%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>2、JS的执行对onload有影响</h4><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n}\\n<span class=hljs-keyword>var</span> a\\n<span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; <span class=hljs-number>100000000</span>; i++) {\\n    a = a + i;\\n}</code></pre><p>你会发现 onload 会等很久才触发，因此JS的执行最好放在onload之后。</p><h4 id=3、动态加载的资源可能对onload产生影响><a href=#3%E3%80%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%B5%84%E6%BA%90%E5%8F%AF%E8%83%BD%E5%AF%B9onload%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>3、动态加载的资源可能对onload产生影响</h4><pre><code class=\\\"hljs language-html\\\"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>body</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>body</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>\\n  <span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n  }\\n  <span class=hljs-built_in>document</span>.body.innerHTML = <span class=hljs-string>'&lt;img src=\\\"a.png\\\"> .... &lt;img src=\\\"z.png\\\">'</span>;\\n</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><p>我们把网速调的慢一点，我们会很清晰的发现这种 JS 动态加进去的图片也会阻塞 <code>onload</code>，只有 a-z 图片都加载完成，onload 才会触发。而我们改成下面：</p><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    setTimeout(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n       <span class=hljs-built_in>document</span>.body.innerHTML = <span class=hljs-string>'&lt;img src=\\\"a.png\\\"> .... &lt;img src=\\\"z.png\\\">'</span>;\\n    }, <span class=hljs-number>10</span>)\\n    alert(<span class=hljs-string>'onload'</span>);\\n}</code></pre><p>这时就会发现，onload 马上就触发了，不必等待图片加载完成。</p><p>再讲一个更实际的例子：</p><pre><code class=\\\"hljs language-html\\\"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>img</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"aaa.png\\\"</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>\\n<span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n}\\n$.ajax({\\n    <span class=hljs-attr>url</span>: imgList,\\n  \\t<span class=hljs-attr>success</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>arr</span>) </span>{\\n        arr.forEach(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n            $(<span class=hljs-string>'body'</span>).append(<span class=hljs-string>'&lt;img src=\\\"'</span> + arr.imgUrl + <span class=hljs-string>'\\\">'</span>)\\n        })\\n    }\\n})\\n</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><p>假设 aaa.png 加载时间为 100ms，ajax 接口返回时间为 50ms，那么假设 imgList 中有 100 张图片，那么 onload 的时间就会被推迟到这 100 张图片都加载完成之后。</p><p>而如果 aaa.png 加载时间为 50ms，接口请求为 100ms 的时候，就不会有这个问题。但是我们没法保证接口请求一定慢于图片请求。</p><p>因此<strong>带图片的列表请求需要放在 window.onload 之后执行</strong>。</p><h4 id=4、onload和客户端方法的对应><a href=#4%E3%80%81onload%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>4、onload和客户端方法的对应</h4><p>iOS 中判断 webview 加载完成的 <strong>webViewDidFinishLoad</strong> 方法，Android 中判断 <code>webview</code> 加载完成的 <strong>onPageFinished</strong> 方法本质触发时机上都对应页面上的 <code>window.onload</code>，一般来说会稍晚于 <code>window.onload</code>（某些特殊情况会早于 <code>window.onload</code>，比如页面里有 <code>iframe</code> 等情况）。</p><p>也就是说 <strong>对 onload 有影响的因素也同样会影响这些 Native 方法</strong>。而在 Hybrid 开发中，一些 Native 和 Web 之间的交互和调用往往要在<code>webViewDidFinishLoad / onPageFinished</code> 之后。因此如果 <code>onload</code> 的触发被推迟了，那么这些 <code>Native</code> 相关的调用也都会被推迟。</p><p><strong>因此如果是Hybrid应用，尤其要注意让onload尽快触发。</strong></p><h4 id=5、百度统计对onload的影响><a href=#5%E3%80%81%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E5%AF%B9onload%E7%9A%84%E5%BD%B1%E5%93%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>5、百度统计对onload的影响</h4><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-keyword>var</span> _hmt = _hmt || [];\\n    (<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n      <span class=hljs-keyword>var</span> hm = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>\\\"script\\\"</span>);\\n      hm.src = <span class=hljs-string>\\\"https://hm.baidu.com/hm.js?2fdsasa8f9f2f0e59e7db6c398edfbfcb1f\\\"</span>;\\n      <span class=hljs-keyword>var</span> s = <span class=hljs-built_in>document</span>.getElementsByTagName(<span class=hljs-string>\\\"script\\\"</span>)[<span class=hljs-number>0</span>];\\n      s.parentNode.insertBefore(hm, s);\\n})();</code></pre><p>上面是百度统计的代码，我们可以看到它动态加载了一个 <code>script</code>，而这个 <code>script</code> 会马上以一个小 gif 的形式发送一个上报请求，经过测试，如果页面上没有其它元素，这个 <strong>小 gif 加载完成后才会触发 onload</strong>，那么总加载时间就是 script 加载时间 + gif 加载时间。</p><p>因此应该尽量把百度统计代码提前，避免百度统计拖慢 onload 时间。百度统计官方也是<strong>建议将统计代码放在 head 中</strong>。</p><h4 id=现实示例：><a href=#%E7%8E%B0%E5%AE%9E%E7%A4%BA%E4%BE%8B%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>现实示例：</h4><p>我们把网速调整到slow 3G模拟弱网环境，测试一个线上的带图片列表的项目： 下面是把JS代码放在onload里执行的效果，<strong>7秒</strong> 左右onload触发。 <img src=http://qiniu.fe-learn.com/assets/58f000c8ad5fc1447e00c25b3f5b18c1.png></p><p>下面是把JS代码放在onload外，直接顺序执行的效果，因为要等待所有图片加载完成，等了 <strong>44秒</strong> 左右onload才触发。 <img src=http://qiniu.fe-learn.com/assets/90267ba6fc4f77e9dcdb53f1efa9ccdf.jpg></p>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// blog/fe/深入理解window.onload.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<p><strong>现象：</strong>在一个 Hybrid 应用中，用户反馈弱网条件下页面的进度条总是不消失，最后发现是页面接口先于其他资源返回，而接口中包含大量图片导致了 <code>onload</code> 会推迟，从而客户端控制的进度条不会消失，页面调用客户端的方法不会执行。</p><h4 id=先放结论><a href=#%E5%85%88%E6%94%BE%E7%BB%93%E8%AE%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>先放结论</h4><p><strong>onload的触发时机：</strong> JS 加载并执行完毕且页面中所有外链资源加载完成之后大约 3 - 4ms（这个值跟机型和浏览器有关）</p><p><strong>最佳实践：</strong> JS代码的执行要放到onload里。如果是服务端渲染带图片的列表，图片最好由JS异步加载，避免阻塞onload。</p><h4 id=1、onload不是立即触发的><a href=#1%E3%80%81onload%E4%B8%8D%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%A7%A6%E5%8F%91%E7%9A%84 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>1、onload不是立即触发的</h4><p>请问下面哪个alert先触发？</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n}\\nsetTimeout(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n    alert(<span class=hljs-string>'timeout'</span>);\\n}, <span class=hljs-number>2</span>)</code></pre><p>答案是 <code>timeout</code> 先触发。而在我的电脑上，把 <code>timeout</code> 的值调成 5 或 5 以上，就是 <code>onload</code> 先触发了。</p><h4 id=2、js的执行对onload有影响><a href=#2%E3%80%81js%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AF%B9onload%E6%9C%89%E5%BD%B1%E5%93%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>2、JS的执行对onload有影响</h4><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n}\\n<span class=hljs-keyword>var</span> a\\n<span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; <span class=hljs-number>100000000</span>; i++) {\\n    a = a + i;\\n}</code></pre><p>你会发现 onload 会等很久才触发，因此JS的执行最好放在onload之后。</p><h4 id=3、动态加载的资源可能对onload产生影响><a href=#3%E3%80%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%B5%84%E6%BA%90%E5%8F%AF%E8%83%BD%E5%AF%B9onload%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>3、动态加载的资源可能对onload产生影响</h4><pre><code class=\\\"hljs language-html\\\"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>body</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>body</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>\\n  <span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n  }\\n  <span class=hljs-built_in>document</span>.body.innerHTML = <span class=hljs-string>'&lt;img src=\\\"a.png\\\"> .... &lt;img src=\\\"z.png\\\">'</span>;\\n</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><p>我们把网速调的慢一点，我们会很清晰的发现这种 JS 动态加进去的图片也会阻塞 <code>onload</code>，只有 a-z 图片都加载完成，onload 才会触发。而我们改成下面：</p><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    setTimeout(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n       <span class=hljs-built_in>document</span>.body.innerHTML = <span class=hljs-string>'&lt;img src=\\\"a.png\\\"> .... &lt;img src=\\\"z.png\\\">'</span>;\\n    }, <span class=hljs-number>10</span>)\\n    alert(<span class=hljs-string>'onload'</span>);\\n}</code></pre><p>这时就会发现，onload 马上就触发了，不必等待图片加载完成。</p><p>再讲一个更实际的例子：</p><pre><code class=\\\"hljs language-html\\\"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>img</span> <span class=hljs-attr>src</span>=<span class=hljs-string>\\\"aaa.png\\\"</span>></span>\\n<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>\\n<span class=hljs-built_in>window</span>.onload = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    alert(<span class=hljs-string>'onload'</span>);\\n}\\n$.ajax({\\n    <span class=hljs-attr>url</span>: imgList,\\n  \\t<span class=hljs-attr>success</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>arr</span>) </span>{\\n        arr.forEach(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n            $(<span class=hljs-string>'body'</span>).append(<span class=hljs-string>'&lt;img src=\\\"'</span> + arr.imgUrl + <span class=hljs-string>'\\\">'</span>)\\n        })\\n    }\\n})\\n</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre><p>假设 aaa.png 加载时间为 100ms，ajax 接口返回时间为 50ms，那么假设 imgList 中有 100 张图片，那么 onload 的时间就会被推迟到这 100 张图片都加载完成之后。</p><p>而如果 aaa.png 加载时间为 50ms，接口请求为 100ms 的时候，就不会有这个问题。但是我们没法保证接口请求一定慢于图片请求。</p><p>因此<strong>带图片的列表请求需要放在 window.onload 之后执行</strong>。</p><h4 id=4、onload和客户端方法的对应><a href=#4%E3%80%81onload%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>4、onload和客户端方法的对应</h4><p>iOS 中判断 webview 加载完成的 <strong>webViewDidFinishLoad</strong> 方法，Android 中判断 <code>webview</code> 加载完成的 <strong>onPageFinished</strong> 方法本质触发时机上都对应页面上的 <code>window.onload</code>，一般来说会稍晚于 <code>window.onload</code>（某些特殊情况会早于 <code>window.onload</code>，比如页面里有 <code>iframe</code> 等情况）。</p><p>也就是说 <strong>对 onload 有影响的因素也同样会影响这些 Native 方法</strong>。而在 Hybrid 开发中，一些 Native 和 Web 之间的交互和调用往往要在<code>webViewDidFinishLoad / onPageFinished</code> 之后。因此如果 <code>onload</code> 的触发被推迟了，那么这些 <code>Native</code> 相关的调用也都会被推迟。</p><p><strong>因此如果是Hybrid应用，尤其要注意让onload尽快触发。</strong></p><h4 id=5、百度统计对onload的影响><a href=#5%E3%80%81%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E5%AF%B9onload%E7%9A%84%E5%BD%B1%E5%93%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>5、百度统计对onload的影响</h4><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-keyword>var</span> _hmt = _hmt || [];\\n    (<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n      <span class=hljs-keyword>var</span> hm = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>\\\"script\\\"</span>);\\n      hm.src = <span class=hljs-string>\\\"https://hm.baidu.com/hm.js?2fdsasa8f9f2f0e59e7db6c398edfbfcb1f\\\"</span>;\\n      <span class=hljs-keyword>var</span> s = <span class=hljs-built_in>document</span>.getElementsByTagName(<span class=hljs-string>\\\"script\\\"</span>)[<span class=hljs-number>0</span>];\\n      s.parentNode.insertBefore(hm, s);\\n})();</code></pre><p>上面是百度统计的代码，我们可以看到它动态加载了一个 <code>script</code>，而这个 <code>script</code> 会马上以一个小 gif 的形式发送一个上报请求，经过测试，如果页面上没有其它元素，这个 <strong>小 gif 加载完成后才会触发 onload</strong>，那么总加载时间就是 script 加载时间 + gif 加载时间。</p><p>因此应该尽量把百度统计代码提前，避免百度统计拖慢 onload 时间。百度统计官方也是<strong>建议将统计代码放在 head 中</strong>。</p><h4 id=现实示例：><a href=#%E7%8E%B0%E5%AE%9E%E7%A4%BA%E4%BE%8B%EF%BC%9A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>现实示例：</h4><p>我们把网速调整到slow 3G模拟弱网环境，测试一个线上的带图片列表的项目： 下面是把JS代码放在onload里执行的效果，<strong>7秒</strong> 左右onload触发。 <img src=http://qiniu.fe-learn.com/assets/58f000c8ad5fc1447e00c25b3f5b18c1.png></p><p>下面是把JS代码放在onload外，直接顺序执行的效果，因为要等待所有图片加载完成，等了 <strong>44秒</strong> 左右onload才触发。 <img src=http://qiniu.fe-learn.com/assets/90267ba6fc4f77e9dcdb53f1efa9ccdf.jpg></p>\",\n  \"extra\": {\n    \"_image-loader_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./doc/fe/深入理解window.onload.md\n// module id = 835\n// module chunks = 19"],"sourceRoot":""}